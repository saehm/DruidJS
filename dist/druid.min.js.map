{"version":3,"sources":["webpack://druid/webpack/universalModuleDefinition","webpack://druid/webpack/bootstrap","webpack://druid/webpack/runtime/define property getters","webpack://druid/webpack/runtime/hasOwnProperty shorthand","webpack://druid/webpack/runtime/make namespace object","webpack://druid/webpack/startup","webpack://druid/./numerical/neumair_sum.js","webpack://druid/./metrics/euclidean_squared.js","webpack://druid/./metrics/euclidean.js","webpack://druid/./matrix/k_nearest_neighbors.js","webpack://druid/./matrix/Matrix.js","webpack://druid/./matrix/distance_matrix.js","webpack://druid/./matrix/linspace.js","webpack://druid/./matrix/norm.js","webpack://druid/./util/randomizer.js","webpack://druid/./util/max.js","webpack://druid/./numerical/kahan_sum.js","webpack://druid/./metrics/cosine.js","webpack://druid/./metrics/manhattan.js","webpack://druid/./metrics/chebyshev.js","webpack://druid/./metrics/canberra.js","webpack://druid/./datastructure/Heap.js","webpack://druid/./knn/BallTree.js","webpack://druid/./linear_algebra/qr.js","webpack://druid/./linear_algebra/simultaneous_poweriteration.js","webpack://druid/./dimred/DR.js","webpack://druid/./dimred/PCA.js","webpack://druid/./dimred/MDS.js","webpack://druid/./dimred/ISOMAP.js","webpack://druid/./dimred/FASTMAP.js","webpack://druid/./dimred/LDA.js","webpack://druid/./dimred/LLE.js","webpack://druid/./dimred/LTSA.js","webpack://druid/./dimred/TSNE.js","webpack://druid/./optimization/powell.js","webpack://druid/./dimred/UMAP.js","webpack://druid/./dimred/TriMap.js","webpack://druid/./clustering/Hierarchical_Clustering.js","webpack://druid/./clustering/KMeans.js","webpack://druid/./clustering/KMedoids.js","webpack://druid/./clustering/OPTICS.js","webpack://druid/./dimred/LSP.js","webpack://druid/./dimred/TopoMap.js","webpack://druid/./dimred/SAMMON.js"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","__webpack_exports__","summands","n","length","sum","compensation","i","summand","t","Math","abs","a","b","s","Array","x","y","neumair_sum","sqrt","euclidean_squared","A","k","distance_matrix","metric","euclidean","rows","shape","D","dmatrix","nN","row","from","map","distance","col","sort","slice","iterator","Matrix","constructor","cols","iterate_rows","_rows","_cols","_data","Float64Array","j","type","clone","isArray","m","_","data","subarray","set_row","values","offset","result_col","entry","set_entry","transpose","inverse","B","h","i_max","max_val","val","h_val","i_val","f","B_row_row","B_i_j","dot","join","I","A_i","B_i","C","e","outer","l","concat","rows_A","cols_A","rows_B","cols_B","X","set_block","offset_row","offset_col","get_block","start_row","start_col","end_row","end_col","new_row","new_col","gather","row_indices","col_indices","N","R","row_index","col_index","_apply_array","v","_apply_rowwise_array","_apply_colwise_array","_apply","value_rows","value_cols","mult","divide","add","sub","min_row_col","min","result","randomizer","tol","b_i","T","random","r","d","z","alpha","r_next","beta","mean","L","U","LU","M","MT","MtM","MMt","eigenvectors","V","eigenvalues","Sigma","simultaneous_poweriteration","sigma","dist","start","end","number","max","round","vector","fill","Randomizer","_seed","_N","_M","_MATRIX_A","_UPPER_MASK","_LOWER_MASK","_mt","_mti","seed","Date","getTime","mt","mti","random_int","mag01","kk","N_M","M_N","choice","sample","index_list","linspace","random_index","splice","rand","undefined","sum_a","sum_b","acos","res","push","Heap","elements","accessor","comparator","heapify","_accessor","_container","_comparator","heap","container","floor","_heapify_down","_swap","index_a","index_b","_heapify_up","index","parentIndex","element","node","start_index","left","right","pop","item","toArray","raw_data","BallTree","_Node","pivot","child1","child2","radius","_Leaf","points","_metric","_root","_construct","c","_greatest_spread","sorted_elements","p_index","p","Infinity","spread","reduce","acc","current","search","_search","Q","first","q","q_dot_v","q_","v_","v_norm","norm","max_iterations","qr","oldR","QR","diag","to2dArray","DR","_parameter_list","list","_type","_D","_d","_randomizer","_is_initialized","parameter","name","parameter_list","findIndex","para","transform","check_init","Y","generator","init","args","gen","PCA","super","O","X_cent","projection","MDS","ai_","a_j","a__","_d_X","d_X","d_Y","top_sum","bottom_sum","pow","ISOMAP","neighbors","kNearestNeighbors","H","_k","G","other","find","FASTMAP","_choose_distant_objects","a_index","b_index","max_dist","d_ai","d_bi","_col","old_dist","d_ab","y_i","LDA","labels","_labels","unique_labels","label_id","forEach","count","X_mean","V_mean","label","v_mean","meanCols","id","S_b","S_w","row_v","LLE","k_nearest_neighbors","W","nN_row","Z","C_trace","w","solve_CG","IW","LTSA","I_i","X_i","g","G_i_t","W_i","TSNE","perplexity","epsilon","_iter","Htarget","log","_perplexity","Delta","P","_ystep","_gains","prow","betamin","betamax","done","num","psum","pj","exp","Hhere","Pout","N2","_P","iterations","next","iter","ystep","gains","_epsilon","dim","pmul","Qu","qsum","dsum","dhere","qu","grad","premult","ymean","gid","sid","gainid","newgain","sign","newsid","x0","max_iter","pfx","fx","convergence","fxi","dx","UMAP","n_neighbors","local_connectivity","min_dist","_spread","_set_op_mix_ratio","_repulsion_strength","_negative_sample_rate","_n_epochs","_initial_alpha","_find_ab_params","xv","yv","xv_i","powell","error","_compute_membership_strengths","distances","sigmas","rhos","_smooth_knn_dist","knn","SMOOTH_K_TOLERANCE","MIN_K_DIST_SCALE","_local_connectivity","target","log2","x_i","reverse","lo","hi","mid","search_result","non_zero_dist","filter","non_zero_dist_length","interpolation","mean_ithd","mean_d","_fuzzy_simplicial_set","distances_i","transposed_result","prod_matrix","_make_epochs_per_sample","n_epochs","weights","_weights","Float32Array","weights_max","n_samples","_tocoo","graph","rows_n","cols_n","_min_dist","_a","_b","_graph","_n_neighbors","_head","_tail","_epochs_per_sample","_epochs_per_negative_sample","_epoch_of_next_sample","_epoch_of_next_negative_sample","_clip","_optimize_layout","head_embedding","tail_embedding","head","tail","_alpha","repulsion_strength","epochs_per_sample","epochs_per_negative_sample","epoch_of_next_negative_sample","epoch_of_next_sample","clip","tail_length","grad_coeff","grad_d","n_neg_samples","TriMap","weight_adj","pca","_c","n_inliers","n_outliers","n_random","triplets","_generate_triplets","lr","vel","gain","_weight_adj","n_extra","nbrs","knn_distances","sig","_find_p","_sample_knn_triplets","n_triplets","outlier_distances","_find_weights","random_triplets","random_weights","_sample_random_triplets","max_weight","isNaN","max_weight_2","n_i","sort_indices","__argsort","n_j","sim","samples","_rejection_sample","out","max_int","rejects","interval","indexOf","p_sim","p_out","indices","_grad","y_ij","y_ik","d_ij","d_ik","n_viol","loss","n_knn_triplets","Y_id","Y_jd","Y_kd","gs","go","max_iteration","_next","gamma","old_C","_update_embedding","new_gain","Hierarchical_Clustering","matrix","linkage","_id","_matrix","_linkage","do","get_clusters","clusters","depth","_traverse","leaves","_n","d_min","_d_min","_distance_matrix","_clusters","c_size","_c_size","Uint16Array","Cluster","p_max","c1","c2","c1_cluster","c2_cluster","new_cluster","unshift","centroid","size","_calculate_centroid","l_size","r_size","l_centroid","r_centroid","new_centroid","isLeaf","KMeans","K","_K","_cluster_centroids","_get_random_centroids","_furthest_point","candidates","Ad","cluster_centroids","random_point","init_points","sample_size","furthest_point","_iteration","clusters_changed","Ai","min_cluster","_compute_centroid","cluster_counter","ci","iteration_result","KMedoids","_A","_max_iter","log10","_cluster_medoids","_get_random_medoids","x_j","_nearest_medoid","index_nearest","medoids","finish","cache","x_o","DeltaTD","xs","d_j","distance_nearest","deltaTD","d_oj","_get_distance","d_n","d_s","distance_second","nearest","second","x_m","m1","m2","cluster_medoids","ceil","TD","TD0","S","S_j","S_o","delta","OPTICS","min_points","_min_points","_ordered_list","_DB","ordered_list","DB","cluster_index","_cluster_index","processed","_get_neighbors","_core_distance","seeds","reachability_distance","_update","_expand_cluster","core_distance","new_reachability_distance","cluster","empty","outliers","get_cluster_affirmation","LSP","control_points","DR_parameters","KNN","nc","c_i","Y_C","XA","iterate","AT","ATA","ATb","TopoMap","u","points_u","__disjoint_set","children","points_v","hull_u","__hull","hull_v","t_u","__align_hull","t_v","__transform_component","__lazy_distance_matrix","D_ij","_make_minimum_spanning_tree","disjoint_set","DisjointSet","F","E","set_u","set_v","union","_Emst","__hull_cross","ax","ay","bx","by","sx","sy","x1","y1","x2","y2","lower","upper","__findAngle","p1x","p1y","p2x","p2y","vec","cos","sin","hull","topEdge","d2","v1","v2","transformation","__transform","px","py","tx","ty","yOffset","cx","cy","Emst","components","component_u","component_v","__align_components","_list","Set","make_set","has","parent","node_x","node_y","SAMMON","max_halves","Distance_matrix","console","distance_inverse_matrix","Y_i","distance_inverse","Distance","Distance_inverse_matrix","_distance_inverse_matrix","_Distance_matrix","_Distance_inverse_matrix","_delta","_ones","_E","__distance_matrix","_step","ones","delta_one","dinv3","Y2","Y_old","__webpack_modules__"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,IACQ,mBAAXG,QAAyBA,OAAOC,IAC9CD,OAAO,GAAIH,GACe,iBAAZC,QACdA,QAAe,MAAID,IAEnBD,EAAY,MAAIC,IARlB,CASGK,MAAM,WACT,M,uBCTIC,EAAsB,CCA1B,EAAwB,CAACL,EAASM,KACjC,IAAI,IAAIC,KAAOD,EACXD,EAAoBG,EAAEF,EAAYC,KAASF,EAAoBG,EAAER,EAASO,IAC5EE,OAAOC,eAAeV,EAASO,EAAK,CAAEI,YAAY,EAAMC,IAAKN,EAAWC,MCJ3E,EAAwB,CAACM,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,GCClF,EAAyBd,IACH,oBAAXkB,QAA0BA,OAAOC,aAC1CV,OAAOC,eAAeV,EAASkB,OAAOC,YAAa,CAAEC,MAAO,WAE7DX,OAAOC,eAAeV,EAAS,aAAc,CAAEoB,OAAO,MCFnDC,EAAsB,G,iBCKX,WAASC,GACpB,IAAIC,EAAID,EAASE,OACbC,EAAM,EACNC,EAAe,EAEnB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,IAAKI,EAAG,CACxB,IAAIC,EAAUN,EAASK,GACnBE,EAAIJ,EAAMG,EACVE,KAAKC,IAAIN,IAAQK,KAAKC,IAAIH,GAC1BF,GAAiBD,EAAMI,EAAKD,EAE5BF,GAAiBE,EAAUC,EAAKJ,EAEpCA,EAAMI,EAEV,OAAOJ,EAAMC,ECdF,WAASM,EAAGC,GACvB,GAAID,EAAER,QAAUS,EAAET,OAAQ,OAC1B,IAAID,EAAIS,EAAER,OACNU,EAAI,IAAIC,MAAMZ,GAClB,IAAK,IAAII,EAAI,EAAGA,EAAIJ,IAAKI,EAAG,CACxB,IAAIS,EAAIJ,EAAEL,GACNU,EAAIJ,EAAEN,GACVO,EAAEP,IAAOS,EAAIC,IAAMD,EAAIC,GAE3B,OAAOC,EAAYJ,GCTR,WAASF,EAAGC,GACvB,OAAOH,KAAKS,KAAKC,EAAkBR,EAAGC,ICA3B,WAASQ,EAAGC,EAAGC,EAAkB,KAAMC,EAASC,GAC3D,MAAMC,EAAOL,EAAEM,MAAM,GACrB,IAAIC,EAAIL,GAAmBM,EAAQR,EAAGG,GAUlCM,EAAK,IAAIf,MAAMW,GACnB,IAAK,IAAIK,EAAM,EAAGA,EAAML,IAAQK,EAC5BD,EAAGC,GAAOhB,MAAMiB,KAAKJ,EAAEG,IAAIA,IAAME,KAAI,CAACC,EAAUC,KACjC,CACH,EAAKJ,EACL,EAAKI,EACL,SAAYD,MAGnBE,MAAK,CAACxB,EAAGC,IAAMD,EAAEsB,SAAWrB,EAAEqB,WAC9BG,MAAM,EAAGf,EAAI,GAEtB,OAAOQ,E,glBC2HNhC,OAAOwC,SAtJL,MAAMC,EAqBTC,YAAYd,EAAK,KAAMe,EAAK,KAAMzC,EAAM,MAIpC,G,6GAJ0C,QAiI1BhB,KAAK0D,cAhIrB1D,KAAK2D,MAAQjB,EACb1C,KAAK4D,MAAQH,EACbzD,KAAK6D,MAAQ,KACTnB,GAAQe,EAAM,CACd,IAAKzC,EAED,OADAhB,KAAK6D,MAAQ,IAAIC,aAAapB,EAAOe,GAC9BzD,KAEX,GAAsB,mBAAXgB,EAAuB,CAC9BhB,KAAK6D,MAAQ,IAAIC,aAAapB,EAAOe,GACrC,IAAK,IAAIV,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BnD,KAAK6D,MAAMd,EAAMU,EAAON,GAAOnC,EAAM+B,EAAKI,GAGlD,OAAOnD,KAEX,GAAsB,iBAAXgB,EAAqB,CAC5B,GAAc,UAAVA,EACA,OAAO,IAAIuC,EAAOb,EAAMe,EAAM,GAElC,GAAc,aAAVzC,GAAkC,MAAVA,EAAe,CACvChB,KAAK6D,MAAQ,IAAIC,aAAapB,EAAOe,GACrC,IAAK,IAAIV,EAAM,EAAGA,EAAML,IAAQK,EAC5B/C,KAAK6D,MAAMd,EAAMU,EAAOV,GAAO,EAEnC,OAAO/C,KAEX,GAAc,WAAVgB,GAAsB0B,GAAQe,EAAM,CACpCzD,KAAK6D,MAAQ,IAAIC,aAAapB,EAAOe,GACrCzC,EAAQ,CAACO,EAAGwC,KAAOxC,IAAMwC,EAAI,EAAI,GAAM,EAAIrB,EAC3C,IAAK,IAAIK,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BnD,KAAK6D,MAAMd,EAAMU,EAAON,GAAOnC,EAAM+B,EAAKI,GAGlD,OAAOnD,MAGf,GAAsB,iBAAXgB,EAAqB,CAC5BhB,KAAK6D,MAAQ,IAAIC,aAAapB,EAAOe,GACrC,IAAK,IAAIV,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BnD,KAAK6D,MAAMd,EAAMU,EAAON,GAAOnC,EAGvC,OAAOhB,MAGf,OAAOA,KAaA,YAACqC,EAAG2B,EAAK,OAChB,GAAI3B,aAAakB,EACb,OAAOlB,EAAE4B,QACN,KAAIlC,MAAMmC,QAAQ7B,IAAMA,aAAayB,cAwBrC,IAAkB,iBAAPzB,EACd,OAAO,IAAIkB,EAAO,EAAG,EAAGlB,GAExB,KAAM,QA3BgD,CACtD,IAAI8B,EAAI9B,EAAEjB,OACV,GAAU,IAAN+C,EAAS,KAAM,iBAEnB,KAAKpC,MAAMmC,QAAQ7B,EAAE,KAASA,EAAE,aAAcyB,cAAe,CACzD,GAAa,QAATE,EACA,OAAO,IAAIT,EAAO,EAAGY,GAAG,CAACC,EAAGL,IAAM1B,EAAE0B,KACjC,GAAa,QAATC,EACP,OAAO,IAAIT,EAAOY,EAAG,GAAI5C,GAAMc,EAAEd,KAC9B,GAAa,SAATyC,EACP,OAAO,IAAIT,EAAOY,EAAGA,GAAG,CAAC5C,EAAGwC,IAAOxC,GAAKwC,EAAK1B,EAAEd,GAAK,IAEpD,KAAM,2BAGP,GAAIQ,MAAMmC,QAAQ7B,EAAE,KAAOA,EAAE,aAAcyB,aAAc,CAC5D,IAAI3C,EAAIkB,EAAE,GAAGjB,OACb,IAAK,IAAI2B,EAAM,EAAGA,EAAMoB,IAAKpB,EACzB,GAAIV,EAAEU,GAAK3B,SAAWD,EAClB,KAAM,wBAGd,OAAO,IAAIoC,EAAOY,EAAGhD,GAAG,CAACI,EAAGwC,IAAM1B,EAAEd,GAAGwC,OAcnDhB,IAAIA,GAMA,MAAMsB,EAAOrE,KAAK6D,MACZJ,EAAOzD,KAAK4D,MAClB,OAAOS,EAAKC,SAASvB,EAAMU,GAAOV,EAAM,GAAKU,GAMpC,gBACT,MAAMA,EAAOzD,KAAK4D,MACZlB,EAAO1C,KAAK2D,MACZU,EAAOrE,KAAK6D,MAElB,IAAK,IAAId,EAAM,EAAGA,EAAML,IAAQK,QACtBsB,EAAKC,SAASvB,EAAMU,GAAOV,EAAM,GAAKU,GAepDc,QAAQxB,EAAKyB,GACT,IAAIf,EAAOzD,KAAK4D,MAChB,GAAI7B,MAAMmC,QAAQM,IAAWA,EAAOpD,SAAWqC,EAAM,CACjD,IAAIgB,EAAS1B,EAAMU,EACnB,IAAK,IAAIN,EAAM,EAAGA,EAAMM,IAAQN,EAC5BnD,KAAK6D,MAAMY,EAAStB,GAAOqB,EAAOrB,QAEnC,GAAIqB,aAAkBjB,GAAUiB,EAAO7B,MAAM,KAAOc,GAA4B,IAApBe,EAAO7B,MAAM,GAAU,CACtF,IAAI8B,EAAS1B,EAAMU,EACnB,IAAK,IAAIN,EAAM,EAAGA,EAAMM,IAAQN,EAC5BnD,KAAK6D,MAAMY,EAAStB,GAAOqB,EAAOX,MAAMV,GAGhD,OAAOnD,KAQXmD,IAAIA,GACA,IAAIuB,EAAa,IAAIZ,aAAa9D,KAAK2D,OACvC,IAAK,IAAIZ,EAAM,EAAGA,EAAM/C,KAAK2D,QAASZ,EAClC2B,EAAW3B,GAAO/C,KAAK6D,MAAMd,EAAM/C,KAAK4D,MAAQT,GAEpD,OAAOuB,EASXC,MAAM5B,EAAKI,GACP,OAAOnD,KAAK6D,MAAMd,EAAM/C,KAAK4D,MAAQT,GAUzCyB,UAAU7B,EAAKI,EAAKnC,GAEhB,OADAhB,KAAK6D,MAAMd,EAAM/C,KAAK4D,MAAQT,GAAOnC,EAC9BhB,KAOX6E,YAEI,OADQ,IAAItB,EAAOvD,KAAK4D,MAAO5D,KAAK2D,OAAO,CAACZ,EAAKI,IAAQnD,KAAK2E,MAAMxB,EAAKJ,KAQxE,QACD,OAAO/C,KAAK6E,YAOhBC,UACI,MAAMpC,EAAO1C,KAAK2D,MACZF,EAAOzD,KAAK4D,MAClB,IAAImB,EAAI,IAAIxB,EAAOb,EAAM,EAAIe,GAAM,CAAClC,EAAEwC,IAC9BA,GAAKN,EACGlC,IAAOwC,EAAIN,EAAS,EAAI,EAEzBzD,KAAK2E,MAAMpD,EAAGwC,KAGzBiB,EAAI,EACJ1C,EAAI,EACR,KAAO0C,EAAItC,GAAQJ,EAAImB,GAAM,CACzB,IAAIwB,EAAQ,EACZ,IAAIC,GAAU,IACd,IAAK,IAAI3D,EAAIyD,EAAGzD,EAAImB,IAAQnB,EAAG,CAC3B,IAAI4D,EAAMzD,KAAKC,IAAIoD,EAAEJ,MAAMpD,EAAEe,IACzB4C,EAAUC,IACVF,EAAQ1D,EACR2D,EAAUC,GAGlB,GAAyB,GAArBJ,EAAEJ,MAAMM,EAAO3C,GACfA,QACG,CAEH,IAAK,IAAIyB,EAAI,EAAGA,EAAI,EAAIN,IAAQM,EAAG,CAC/B,IAAIqB,EAAQL,EAAEJ,MAAMK,EAAGjB,GACnBsB,EAAQN,EAAEJ,MAAMM,EAAOlB,GAC3BgB,EAAEH,UAAUI,EAAGjB,EAAGqB,GAClBL,EAAEH,UAAUK,EAAOlB,EAAGsB,GAE1B,IAAK,IAAI9D,EAAIyD,EAAI,EAAGzD,EAAImB,IAAQnB,EAAG,CAC/B,IAAI+D,EAAIP,EAAEJ,MAAMpD,EAAGe,GAAKyC,EAAEJ,MAAMK,EAAG1C,GACnCyC,EAAEH,UAAUrD,EAAGe,EAAG,GAClB,IAAK,IAAIyB,EAAIzB,EAAI,EAAGyB,EAAI,EAAIN,IAAQM,EAChCgB,EAAEH,UAAUrD,EAAGwC,EAAGgB,EAAEJ,MAAMpD,EAAGwC,GAAKgB,EAAEJ,MAAMK,EAAGjB,GAAKuB,GAG1DN,IACA1C,KAIR,IAAK,IAAIS,EAAM,EAAGA,EAAML,IAAQK,EAAK,CACjC,IAAIuC,EAAIP,EAAEJ,MAAM5B,EAAKA,GACrB,IAAK,IAAII,EAAMJ,EAAKI,EAAM,EAAIM,IAAQN,EAClC4B,EAAEH,UAAU7B,EAAKI,EAAK4B,EAAEJ,MAAM5B,EAAKI,GAAOmC,GAIlD,IAAK,IAAIvC,EAAML,EAAO,EAAGK,GAAO,IAAKA,EAAK,CACtC,IAAIwC,EAAYR,EAAEJ,MAAM5B,EAAKA,GAC7B,IAAK,IAAIxB,EAAI,EAAGA,EAAIwB,EAAKxB,IAAK,CAC1B,IACI+D,EADUP,EAAEJ,MAAMpD,EAAGwB,GACPwC,EAClB,IAAK,IAAIxB,EAAIxC,EAAGwC,EAAI,EAAIN,IAAQM,EAAG,CAC/B,IAAIyB,EAAQT,EAAEJ,MAAMpD,EAAEwC,GAEtByB,GADcT,EAAEJ,MAAM5B,EAAKgB,GACDuB,EAC1BP,EAAEH,UAAUrD,EAAGwC,EAAGyB,KAK9B,OAAO,IAAIjC,EAAOb,EAAMe,GAAM,CAAClC,EAAEwC,IAAMgB,EAAEJ,MAAMpD,EAAGwC,EAAIN,KAQ1DgC,IAAIV,GACA,GAAIA,aAAaxB,EAAQ,CACrB,IAAIlB,EAAIrC,KACR,GAAIqC,EAAEM,MAAM,KAAOoC,EAAEpC,MAAM,GACvB,KAAO,oBAAmBN,EAAEM,MAAM+C,KAAK,yBAAyBX,EAAEpC,MAAM+C,KAAK,0CACrErD,EAAEM,MAAM,iBAAiBoC,EAAEpC,MAAM,4CAG7C,IAAIgD,EAAItD,EAAEM,MAAM,GAUhB,OATQ,IAAIY,EAAOlB,EAAEM,MAAM,GAAIoC,EAAEpC,MAAM,IAAI,CAACI,EAAKI,KAC7C,MAAMyC,EAAMvD,EAAEU,IAAIA,GACZ8C,EAAMd,EAAE5B,IAAIA,GAClB,IAAI9B,EAAM,EACV,IAAK,IAAIE,EAAI,EAAGA,EAAIoE,IAAKpE,EACrBF,GAAOuE,EAAIrE,GAAKsE,EAAItE,GAExB,OAAOF,KAGR,GAAIU,MAAMmC,QAAQa,IAAOA,aAAajB,aAAe,CACxD,IAAIpB,EAAO1C,KAAK2D,MAChB,GAAIoB,EAAE3D,SAAWsB,EACb,KAAO,mBAAkBA,oBAAuBqC,EAAE3D,8BAEtD,IAAI0E,EAAI,IAAI/D,MAAMW,GAClB,IAAK,IAAIK,EAAM,EAAGA,EAAML,IAAQK,EAC5B+C,EAAE/C,GAAOb,EAAYlC,KAAK+C,IAAIA,GAAKE,KAAI8C,GAAKA,EAAIhB,EAAEhC,MAEtD,OAAO+C,EAEP,KAAO,4BASfE,MAAMjB,GACF,IAAI1C,EAAIrC,KACJiG,EAAI5D,EAAEwB,MAAMzC,OAEhB,GAAI6E,GADIlB,EAAElB,MAAMzC,OACJ,OACZ,IAAI0E,EAAI,IAAIvC,EAQZ,OAPAuC,EAAEnD,MAAQ,CAACsD,EAAGA,EAAG,CAAC1E,EAAGwC,IACbxC,GAAKwC,EACE1B,EAAEwB,MAAMtC,GAAKwD,EAAElB,MAAME,GAErB+B,EAAEnB,MAAMZ,EAAGxC,IAGnBuE,EAiBXI,OAAOnB,EAAGf,EAAK,cACX,MAAM3B,EAAIrC,MACHmG,EAAQC,GAAU/D,EAAEM,OACpB0D,EAAQC,GAAUvB,EAAEpC,MAC3B,GAAY,cAARqB,EAAsB,CACtB,GAAImC,GAAUE,EAAQ,KAAO,sEAAqEF,iBAAsBE,UACxH,MAAME,EAAI,IAAIhD,EAAO4C,EAAQC,EAASE,EAAQ,SAG9C,OAFAC,EAAEC,UAAU,EAAG,EAAGnE,GAClBkE,EAAEC,UAAU,EAAGJ,EAAQrB,GAChBwB,EACJ,GAAY,YAARvC,EAAoB,CAC3B,GAAIoC,GAAUE,EAAQ,KAAO,uEAAsEF,oBAAyBE,aAC5H,MAAMC,EAAI,IAAIhD,EAAO4C,EAASE,EAAQD,EAAQ,SAG9C,OAFAG,EAAEC,UAAU,EAAG,EAAGnE,GAClBkE,EAAEC,UAAUL,EAAQ,EAAGpB,GAChBwB,EACJ,GAAY,QAARvC,EAAgB,CACvB,MAAMuC,EAAI,IAAIhD,EAAO4C,EAASE,EAAQD,EAASE,EAAQ,SAGvD,OAFAC,EAAEC,UAAU,EAAG,EAAGnE,GAClBkE,EAAEC,UAAUL,EAAQC,EAAQrB,GACrBwB,EAEP,KAAO,wDAAuDvC,KAWtEwC,UAAUC,EAAYC,EAAY3B,GAC9B,IAAMrC,EAAMe,GAASsB,EAAEpC,MACvB,IAAK,IAAII,EAAM,EAAGA,EAAML,IAAQK,EAC5B,KAAIA,EAAM/C,KAAK2D,OACf,IAAK,IAAIR,EAAM,EAAGA,EAAMM,IAAQN,EACxBA,EAAMnD,KAAK4D,OACf5D,KAAK4E,UAAU7B,EAAM0D,EAAYtD,EAAMuD,EAAY3B,EAAEJ,MAAM5B,EAAKI,IAGxE,OAAOnD,KAoBX2G,UAAUC,EAAWC,EAAWC,EAAU,KAAMC,EAAU,MACtD,MAAQrE,EAAMe,GAASzD,KAAK2C,MAQ5B,GADAoE,EAAUA,GAAWtD,GADrBqD,EAAUA,GAAWpE,IAENkE,GAAaG,GAAWF,EACnC,KAAO,0JAGSC,kBAAwBF,gBAAwBG,sBAA4BF,KAEhG,MAAMN,EAAI,IAAIhD,EAAOuD,EAAUF,EAAWG,EAAUF,EAAW,SAC/D,IAAK,IAAI9D,EAAM6D,EAAWI,EAAU,EAAGjE,EAAM+D,IAAW/D,IAAOiE,EAC3D,IAAK,IAAI7D,EAAM0D,EAAWI,EAAU,EAAG9D,EAAM4D,IAAW5D,IAAO8D,EAC3DV,EAAE3B,UAAUoC,EAASC,EAASjH,KAAK2E,MAAM5B,EAAKI,IAGtD,OAAOoD,EAUXW,OAAOC,EAAaC,GAChB,MAAMC,EAAIF,EAAY/F,OAChBwB,EAAIwE,EAAYhG,OAEhBkG,EAAI,IAAI/D,EAAO8D,EAAGzE,GACxB,IAAK,IAAIrB,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMgG,EAAYJ,EAAY5F,GAC9B,IAAK,IAAIwC,EAAI,EAAGA,EAAIsD,IAAKtD,EAAG,CACxB,MAAMyD,EAAYJ,EAAYrD,GAC9BuD,EAAE1C,UAAUrD,EAAGwC,EAAG/D,KAAK2E,MAAM4C,EAAWC,KAIhD,OAAOF,EAQXG,aAAanC,EAAGoC,GACZ,MAAMrD,EAAOrE,KAAK6D,OACVnB,EAAMe,GAASzD,KAAK2C,MAC5B,IAAK,IAAII,EAAM,EAAGA,EAAML,IAAQK,EAAK,CACjC,MAAM0B,EAAS1B,EAAMU,EACrB,IAAK,IAAIN,EAAM,EAAGA,EAAMM,IAAQN,EAAK,CACjC,MAAM5B,EAAIkD,EAAStB,EACnBkB,EAAK9C,GAAK+D,EAAEjB,EAAK9C,GAAImG,EAAE3E,EAAKI,KAGpC,OAAOnD,KAGX2H,qBAAqBnD,EAAQc,GACzB,OAAOtF,KAAKyH,aAAanC,GAAG,CAAClB,EAAGL,IAAMS,EAAOT,KAGjD6D,qBAAqBpD,EAAQc,GACzB,MAAMjB,EAAOrE,KAAK6D,OACVnB,EAAMe,GAASzD,KAAK2C,MAC5B,IAAK,IAAII,EAAM,EAAGA,EAAML,IAAQK,EAAK,CACjC,MAAM0B,EAAS1B,EAAMU,EACrB,IAAK,IAAIN,EAAM,EAAGA,EAAMM,IAAQN,EAAK,CACjC,MAAM5B,EAAIkD,EAAStB,EACnBkB,EAAK9C,GAAK+D,EAAEjB,EAAK9C,GAAIiD,EAAOzB,KAGpC,OAAO/C,KAGX6H,OAAO7G,EAAOsE,GACV,IAAIjB,EAAOrE,KAAK6D,MAChB,GAAI7C,aAAiBuC,EAAQ,CACzB,IAAMuE,EAAYC,GAAe/G,EAAM2B,OACjCD,EAAMe,GAASzD,KAAK2C,MAC1B,GAAmB,IAAfmF,EAAkB,CAClB,GAAIrE,IAASsE,EACT,KAAO,sBAEX,IAAK,IAAIhF,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BkB,EAAKtB,EAAMU,EAAON,GAAOmC,EAAEjB,EAAKtB,EAAMU,EAAON,GAAMnC,EAAM2D,MAAM,EAAGxB,SAGvE,GAAmB,IAAf4E,EAAkB,CACzB,GAAIrF,IAASoF,EACT,KAAO,sBAEX,IAAK,IAAI/E,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BkB,EAAKtB,EAAMU,EAAON,GAAOmC,EAAEjB,EAAKtB,EAAMU,EAAON,GAAMnC,EAAM2D,MAAM5B,EAAK,QAGzE,IAAIL,GAAQoF,GAAcrE,GAAQsE,EAOrC,KAAO,QANP,IAAK,IAAIhF,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BkB,EAAKtB,EAAMU,EAAON,GAAOmC,EAAEjB,EAAKtB,EAAMU,EAAON,GAAMnC,EAAM2D,MAAM5B,EAAKI,UAM7E,GAAIpB,MAAMmC,QAAQlD,GAAQ,CAC7B,IAAI0B,EAAO1C,KAAK2D,MACZF,EAAOzD,KAAK4D,MAChB,GAAI5C,EAAMI,SAAWsB,EACjB,IAAK,IAAIK,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BkB,EAAKtB,EAAMU,EAAON,GAAOmC,EAAEjB,EAAKtB,EAAMU,EAAON,GAAMnC,EAAM+B,QAG9D,IAAI/B,EAAMI,SAAWqC,EAOxB,KAAO,QANP,IAAK,IAAIV,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BkB,EAAKtB,EAAMU,EAAON,GAAOmC,EAAEjB,EAAKtB,EAAMU,EAAON,GAAMnC,EAAMmC,UAOrE,IAAK,IAAI5B,EAAI,EAAGJ,EAAInB,KAAK2D,MAAQ3D,KAAK4D,MAAOrC,EAAIJ,IAAKI,EAClD8C,EAAK9C,GAAK+D,EAAEjB,EAAK9C,GAAIP,GAG7B,OAAOhB,KAOXiE,QACI,IAAIc,EAAI,IAAIxB,EAIZ,OAHAwB,EAAEpB,MAAQ3D,KAAK2D,MACfoB,EAAEnB,MAAQ5D,KAAK4D,MACfmB,EAAElB,MAAQ7D,KAAK6D,MAAMR,MAAM,GACpB0B,EAGXiD,KAAKhH,GACD,OAAOhB,KAAKiE,QAAQ4D,OAAO7G,GAAO,CAACY,EAAEC,IAAMD,EAAIC,IAGnDoG,OAAOjH,GACH,OAAOhB,KAAKiE,QAAQ4D,OAAO7G,GAAO,CAACY,EAAEC,IAAMD,EAAIC,IAGnDqG,IAAIlH,GACA,OAAOhB,KAAKiE,QAAQ4D,OAAO7G,GAAO,CAACY,EAAEC,IAAMD,EAAIC,IAGnDsG,IAAInH,GACA,OAAOhB,KAAKiE,QAAQ4D,OAAO7G,GAAO,CAACY,EAAEC,IAAMD,EAAIC,IAO1C,YACL,MAAO,CAAC7B,KAAK2D,MAAO3D,KAAK4D,OAQpB,WAAElB,EAAMe,EAAMzC,EAAQ,KAAM,KACjChB,KAAK2D,MAAQjB,EACb1C,KAAK4D,MAAQH,EACbzD,KAAK6D,MAAQ,IAAIC,aAAapB,EAAOe,GACrC,IAAK,IAAIV,EAAM,EAAGA,EAAML,IAAQK,EAC5B,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BnD,KAAK6D,MAAMd,EAAMU,EAAON,GAAOnC,EAAM+B,EAAKI,GAGlD,OAAOnD,KAOE,gBAYT,MAAO,IAAIA,KAAK0D,gBAOZ,WACJ,MAAMhB,EAAO1C,KAAK2D,MACZF,EAAOzD,KAAK4D,MACZwE,EAAc1G,KAAK2G,IAAI3F,EAAMe,GACnC,IAAI6E,EAAS,IAAIxE,aAAasE,GAC9B,IAAK,IAAI7G,EAAI,EAAGA,EAAI6G,IAAe7G,EAC/B+G,EAAO/G,GAAKvB,KAAK2E,MAAMpD,EAAEA,GAE7B,OAAO+G,EAOH,WAGJ,OAFYtI,KAAKqB,KACPrB,KAAK2D,MAAQ3D,KAAK4D,OAQzB,UAEH,OAAO1B,EADMlC,KAAK6D,OAQV,eACR,MAAMQ,EAAOrE,KAAK6D,MACZnB,EAAO1C,KAAK2D,MACZF,EAAOzD,KAAK4D,MAClB,IAAI0E,EAAS,GACb,IAAK,IAAIvF,EAAM,EAAGA,EAAML,IAAQK,EAAK,CACjCuF,EAAOvF,GAAO,EACd,IAAK,IAAII,EAAM,EAAGA,EAAMM,IAAQN,EAC5BmF,EAAOvF,IAAQsB,EAAKtB,EAAMU,EAAON,GAErCmF,EAAOvF,IAAQU,EAEnB,OAAO6E,EAMC,eACR,MAAMjE,EAAOrE,KAAK6D,MACZnB,EAAO1C,KAAK2D,MACZF,EAAOzD,KAAK4D,MAClB,IAAI0E,EAAS,GACb,IAAK,IAAInF,EAAM,EAAGA,EAAMM,IAAQN,EAAK,CACjCmF,EAAOnF,GAAO,EACd,IAAK,IAAIJ,EAAM,EAAGA,EAAML,IAAQK,EAC5BuF,EAAOnF,IAAQkB,EAAKtB,EAAMU,EAAON,GAErCmF,EAAOnF,IAAQT,EAEnB,OAAO4F,EAGI,gBAACjG,EAAGR,EAAG0G,EAAYC,EAAI,MAClC,MAAM9F,EAAOL,EAAEM,MAAM,GACfc,EAAO5B,EAAEc,MAAM,GACrB,IAAI2F,EAAS,IAAI/E,EAAOb,EAAM,GAC9B,IAAK,IAAInB,EAAI,EAAGA,EAAIkC,IAAQlC,EAAG,CAC3B,MAAMkH,EAAMlF,EAAOP,KAAKnB,EAAEsB,IAAI5B,IAAImH,EAClC,IAAI1G,EAAI,IAAIuB,EAAOb,EAAM,GAAG,IAAM6F,EAAWI,SACzCC,EAAIH,EAAIN,IAAI9F,EAAEoD,IAAIzD,IAClB6G,EAAID,EAAE3E,QACV,EAAG,CACC,MAAM6E,EAAIzG,EAAEoD,IAAIoD,GACVE,EAAQH,EAAEF,EAAEjD,IAAImD,GAAGjE,MAAM,EAAG,GAAKkE,EAAEH,EAAEjD,IAAIqD,GAAGnE,MAAM,EAAG,GAC3D3C,EAAIA,EAAEkG,IAAIW,EAAEb,KAAKe,IACjB,MAAMC,EAASJ,EAAET,IAAIW,EAAEd,KAAKe,IACtBE,EAAOD,EAAON,EAAEjD,IAAIuD,GAAQrE,MAAM,EAAG,GAAKiE,EAAEF,EAAEjD,IAAImD,GAAGjE,MAAM,EAAG,GACpEkE,EAAIG,EAAOd,IAAIW,EAAEb,KAAKiB,IACtBL,EAAII,QACCtH,KAAKC,IAAIiH,EAAEM,MAAQV,GAC5BF,EAASA,EAAOpC,OAAOlE,EAAG,cAE9B,OAAOsG,EASC,aAACjG,EAAGR,GACZ,IAAMsH,EAAGA,EAAGC,EAAGA,GAAO,MAAO/G,GAAK,MAAOA,EAAKA,EAAIkB,EAAO8F,GAAGhH,GACxDK,EAAOyG,EAAExG,MAAM,GACfX,EAAIH,EAAEoC,QAGV,IAAK,IAAIlB,EAAM,EAAGA,EAAML,IAAQK,EAAK,CACjC,IAAK,IAAII,EAAM,EAAGA,EAAMJ,EAAM,IAAKI,EAC/BnB,EAAE4C,UAAU,EAAG7B,EAAKf,EAAE2C,MAAM,EAAG5B,GAAOoG,EAAExE,MAAM5B,EAAKI,GAAOnB,EAAE2C,MAAM,EAAGxB,IAEzEnB,EAAE4C,UAAU,EAAG7B,EAAKf,EAAE2C,MAAM,EAAG5B,GAAOoG,EAAExE,MAAM5B,EAAKA,IAIvD,IAAK,IAAIA,EAAML,EAAO,EAAGK,GAAO,IAAKA,EAAK,CACtC,IAAK,IAAII,EAAMT,EAAO,EAAGS,EAAMJ,IAAOI,EAClCnB,EAAE4C,UAAU,EAAG7B,EAAKf,EAAE2C,MAAM,EAAG5B,GAAOqG,EAAEzE,MAAM5B,EAAKI,GAAOnB,EAAE2C,MAAM,EAAGxB,IAEzEnB,EAAE4C,UAAU,EAAG7B,EAAKf,EAAE2C,MAAM,EAAG5B,GAAOqG,EAAEzE,MAAM5B,EAAKA,IAGvD,OAAOf,EAQF,UAACK,GACN,MAAMK,EAAOL,EAAEM,MAAM,GACfwG,EAAI,IAAI5F,EAAOb,EAAMA,EAAM,SAC3B0G,EAAI,IAAI7F,EAAOb,EAAMA,EAAM,YAEjC,IAAK,IAAIqB,EAAI,EAAGA,EAAIrB,IAAQqB,EAAG,CAC3B,IAAK,IAAIxC,EAAIwC,EAAGxC,EAAImB,IAAQnB,EAAG,CAC3B,IAAIF,EAAM,EACV,IAAK,IAAIiB,EAAI,EAAGA,EAAIyB,IAAKzB,EACrBjB,GAAO8H,EAAExE,MAAMpD,EAAGe,GAAK8G,EAAEzE,MAAMrC,EAAGyB,GAEtCoF,EAAEvE,UAAUrD,EAAGwC,EAAG1B,EAAEsC,MAAMpD,EAAGwC,GAAK1C,GAEtC,IAAK,IAAIE,EAAIwC,EAAGxC,EAAImB,IAAQnB,EAAG,CAC3B,GAAsB,IAAlB4H,EAAExE,MAAMZ,EAAGA,GACX,OAEJ,IAAI1C,EAAM,EACV,IAAK,IAAIiB,EAAI,EAAGA,EAAIyB,IAAKzB,EACrBjB,GAAO8H,EAAExE,MAAMZ,EAAGzB,GAAK8G,EAAEzE,MAAMrC,EAAGf,GAEtC6H,EAAExE,UAAUb,EAAGxC,GAAIc,EAAEsC,MAAMZ,EAAGxC,GAAKF,GAAO8H,EAAExE,MAAMZ,EAAGA,KAI7D,MAAO,CAAEoF,EAAGA,EAAGC,EAAGA,GASZ,WAACE,EAAGhH,EAAE,GACZ,MAAMiH,EAAKD,EAAEZ,EACb,IAAIc,EAAMD,EAAG9D,IAAI6D,GACbG,EAAMH,EAAE7D,IAAI8D,IACVG,aAAcC,EAAGC,YAAaC,GAAUC,4BAA4BN,EAAKlH,IACzEoH,aAAcN,GAAMU,4BAA4BL,EAAKnH,GAC3D,MAAO,CAAE8G,EAAGA,EAAGS,MAAOA,EAAM5G,KAAI8G,GAASrI,KAAKS,KAAK4H,KAASJ,EAAGA,ICnzBxD,WAAStH,EAAGG,EAASC,GAChC,IAAItB,EAAIkB,EAAEM,MAAM,GAUhB,MAAMC,EAAI,IAAIW,EAAOpC,EAAGA,GACxB,IAAK,IAAII,EAAI,EAAGA,EAAIJ,IAAKI,EAAG,CACxB,MAAMqE,EAAMvD,EAAEU,IAAIxB,GAClB,IAAK,IAAIwC,EAAIxC,EAAI,EAAGwC,EAAI5C,IAAK4C,EAAG,CAC5B,MAAMiG,EAAOxH,EAAOoD,EAAKvD,EAAEU,IAAIgB,IAC/BnB,EAAEgC,UAAUrD,EAAGwC,EAAGiG,GAClBpH,EAAEgC,UAAUb,EAAGxC,EAAGyI,IAG1B,OAAOpH,ECvBI,WAASqH,EAAOC,EAAKC,EAAS,MAIzC,GAHKA,IACDA,EAASzI,KAAK0I,IAAI1I,KAAK2I,MAAMH,EAAMD,GAAS,EAAG,IAE/CE,EAAS,EACT,OAAkB,IAAXA,EAAe,CAACF,GAAS,GAEpC,IAAI3B,EAAS,IAAIvG,MAAMoI,GAEvB,IAAK,IAAI5I,EADT4I,GAAU,EACW5I,GAAK,IAAKA,EAC3B+G,EAAO/G,IAAMA,EAAI2I,GAAOC,EAAS5I,GAAK0I,GAASE,EAEnD,OAAO7B,ECRI,WAASZ,EAAGlF,EAASC,GAEhC,IAAI6H,EAAS,KACb,GAAI5C,aAAanE,EAAQ,CACrB,IAAKb,EAAMe,GAAQiE,EAAE/E,MACrB,GAAa,IAATD,EAAY4H,EAAS5C,EAAE3E,IAAI,OAC1B,IAAa,IAATU,EACJ,KAAM,qBADU6G,EAAS5C,EAAEvE,IAAI,SAGpCmH,EAAS5C,EAEb,IAAIvG,EAAImJ,EAAOlJ,OACX0H,EAAI,IAAI/G,MAAMZ,GAElB,OADA2H,EAAEyB,KAAK,GACA/H,EAAO8H,EAAQxB,GChBnB,MAAM0B,EAMThH,YAAYiH,GAUR,OATAzK,KAAK0K,GAAK,IACV1K,KAAK2K,GAAK,IACV3K,KAAK4K,UAAY,WACjB5K,KAAK6K,YAAc,WACnB7K,KAAK8K,YAAc,WACnB9K,KAAK+K,IAAM,IAAIhJ,MAAM/B,KAAK0K,IAC1B1K,KAAKgL,KAAOhL,KAAKqH,EAAI,EAErBrH,KAAKiL,KAAOR,IAAS,IAAIS,MAAOC,UACzBnL,KAGH,SAACyK,GACLzK,KAAKyK,MAAQA,EACb,IAAIW,EAAKpL,KAAK+K,IAGd,IADAK,EAAG,GAAKX,IAAU,EACbzK,KAAKgL,KAAO,EAAGhL,KAAKgL,KAAOhL,KAAK0K,GAAI1K,KAAKgL,MAAQ,EAAG,CACrD,IAAIK,EAAMrL,KAAKgL,KACXlJ,EAAIsJ,EAAGC,EAAM,GAAMD,EAAGC,EAAM,KAAO,GACvCD,EAAGC,IAAsC,aAAtB,WAAJvJ,KAAoB,KAAqB,IAAyB,YAAd,MAAJA,GAAgCuJ,EAC/FD,EAAGC,MAAU,GAIb,WACJ,OAAOrL,KAAKyK,MAGN,aACN,OAAOzK,KAAKsL,YAAc,EAAM,YAGtB,iBACV,IAAIrJ,EAAGsJ,EAAQ,IAAIxJ,MAAM,EAAK/B,KAAK4K,WACnC,GAAI5K,KAAKgL,MAAQhL,KAAK0K,GAAI,CACtB,IAAIc,EAEAxL,KAAKgL,MAAQhL,KAAK0K,GAAK,IACvB1K,KAAKiL,KAAO,MAGhB,IAAIQ,EAAMzL,KAAK0K,GAAK1K,KAAK2K,GACrBe,EAAM1L,KAAK2K,GAAK3K,KAAK0K,GAEzB,IAAKc,EAAK,EAAGA,EAAKC,IAAOD,EACrBvJ,EAAKjC,KAAK+K,IAAIS,GAAMxL,KAAK6K,YAAgB7K,KAAK+K,IAAIS,EAAK,GAAKxL,KAAK8K,YACjE9K,KAAK+K,IAAIS,GAAMxL,KAAK+K,IAAIS,EAAKxL,KAAK2K,IAAO1I,IAAM,EAAKsJ,EAAU,EAAJtJ,GAE9D,KAAOuJ,EAAKxL,KAAK0K,GAAK,IAAKc,EACvBvJ,EAAKjC,KAAK+K,IAAIS,GAAMxL,KAAK6K,YAAgB7K,KAAK+K,IAAIS,EAAK,GAAKxL,KAAK8K,YACjE9K,KAAK+K,IAAIS,GAAMxL,KAAK+K,IAAIS,EAAKE,GAAQzJ,IAAM,EAAKsJ,EAAU,EAAJtJ,GAG1DA,EAAKjC,KAAK+K,IAAI/K,KAAK0K,GAAK,GAAK1K,KAAK6K,YAAgB7K,KAAK+K,IAAI,GAAK/K,KAAK8K,YACrE9K,KAAK+K,IAAI/K,KAAK0K,GAAK,GAAK1K,KAAK+K,IAAI/K,KAAK2K,GAAK,GAAM1I,IAAM,EAAKsJ,EAAU,EAAJtJ,GAElEjC,KAAKgL,KAAO,EAShB,OANA/I,EAAIjC,KAAK+K,IAAI/K,KAAKgL,MAAQ,GAC1B/I,GAAMA,IAAM,GACZA,GAAMA,GAAK,EAAK,WAChBA,GAAMA,GAAK,GAAM,WACjBA,GAAMA,IAAM,GAELA,IAAM,EAGjB0J,OAAOtJ,EAAGlB,GACN,GAAIkB,aAAakB,EAAQ,CACrB,IAAKb,EAAMe,GAAQpB,EAAEM,MACrB,GAAIxB,EAAIuB,EAAM,KAAM,mBACpB,IAAIkJ,EAAS,IAAI7J,MAAMZ,GACnB0K,EAAaC,EAAS,EAAGpJ,EAAO,GACpC,IAAK,IAAInB,EAAI,EAAG0E,EAAI4F,EAAWzK,OAAQG,EAAIJ,IAAKI,IAAK0E,EAAG,CACpD,IAAI8F,EAAe/L,KAAKsL,WAAarF,EACrC2F,EAAOrK,GAAKsK,EAAWG,OAAOD,EAAc,GAAG,GAEnD,OAAOH,EAAO3I,KAAI4F,GAAKxG,EAAEU,IAAI8F,KAC1B,GAAI9G,MAAMmC,QAAQ7B,IAAMA,aAAayB,aAAc,CACtD,IAAIpB,EAAOL,EAAEjB,OACb,GAAID,EAAIuB,EACJ,KAAM,mBAEV,IAAIkJ,EAAS,IAAI7J,MAAMZ,GACnB0K,EAAaC,EAAS,EAAGpJ,EAAO,GACpC,IAAK,IAAInB,EAAI,EAAG0E,EAAI4F,EAAWzK,OAAQG,EAAIJ,IAAKI,IAAK0E,EAAG,CACpD,IAAI8F,EAAe/L,KAAKsL,WAAarF,EACrC2F,EAAOrK,GAAKsK,EAAWG,OAAOD,EAAc,GAAG,GAEnD,OAAOH,EAAO3I,KAAI4F,GAAKxG,EAAEwG,MAIpB,cAACxG,EAAGlB,EAAG8J,EAAK,UACrB,IAAKvI,EAAMe,GAAQpB,EAAEM,MACrB,GAAIxB,EAAIuB,EAAM,KAAM,mBACpB,IAAIuJ,EAAO,IAAIzB,EAAWS,GACtBW,EAAS,IAAI7J,MAAMZ,GACnB0K,EAAaC,EAAS,EAAGpJ,EAAO,GAMpC,IAAK,IAAInB,EAAI,EAAG0E,EAAI4F,EAAWzK,OAAQG,EAAIJ,IAAKI,IAAK0E,EAAG,CACpD,IAAI8F,EAAeE,EAAKX,WAAarF,EACrC2F,EAAOrK,GAAKsK,EAAWG,OAAOD,EAAc,GAAG,GAMnD,OAAOH,EAAO3I,KAAI4F,GAAKxG,EAAEU,IAAI8F,MC3H9B,SAASuB,EAAI5F,GAClB,IAAI4F,EACJ,IAAK,MAAMpJ,KAASwD,EACL,MAATxD,IACIoJ,EAAMpJ,QAAkBkL,IAAR9B,GAAqBpJ,GAASA,KACpDoJ,EAAMpJ,GAGV,OAAOoJ,ECAM,WAASlJ,GACpB,IAGIe,EAAGR,EAHHN,EAAID,EAASE,OACbC,EAAM,EACNC,EAAe,EAGnB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,IAAKI,EACrBU,EAAIf,EAASK,GAAKD,EAClBG,EAAIJ,EAAMY,EACVX,EAAgBG,EAAIJ,EAAOY,EAC3BZ,EAAMI,EAEV,OAAOJ,ECVI,WAASO,EAAGC,GACvB,GAAID,EAAER,SAAWS,EAAET,OAAQ,OAC3B,IAAID,EAAIS,EAAER,OACNC,EAAM,EACN8K,EAAQ,EACRC,EAAQ,EACZ,IAAK,IAAI7K,EAAI,EAAGA,EAAIJ,IAAKI,EACrBF,GAAQO,EAAEL,GAAKM,EAAEN,GACjB4K,GAAUvK,EAAEL,GAAKK,EAAEL,GACnB6K,GAAUvK,EAAEN,GAAKM,EAAEN,GAEvB,OAAOG,KAAK2K,KAAKhL,GAAQK,KAAKS,KAAKgK,GAASzK,KAAKS,KAAKiK,KCdxC,WAASxK,EAAGC,GAC1B,GAAID,EAAER,QAAUS,EAAET,OAAQ,OAC1B,IAAID,EAAIS,EAAER,OACNC,EAAM,EACV,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,IAAKI,EACrBF,GAAOK,KAAKC,IAAIC,EAAEL,GAAKM,EAAEN,IAE7B,OAAOF,ECNI,WAASO,EAAGC,GACvB,GAAID,EAAER,QAAUS,EAAET,OAAQ,OAC1B,IAAID,EAAIS,EAAER,OACNkL,EAAM,GACV,IAAK,IAAI/K,EAAI,EAAGA,EAAIJ,IAAKI,EACrB+K,EAAIC,KAAK7K,KAAKC,IAAIC,EAAEL,GAAKM,EAAEN,KAE/B,OAAOG,KAAK0I,OAAOkC,GCNR,WAAS1K,EAAGC,GACvB,GAAID,EAAER,SAAWS,EAAET,OAAQ,OAC3B,IAAID,EAAIS,EAAER,OACNC,EAAM,EACV,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,IAAKI,EACrBF,GAAQK,KAAKC,IAAIC,EAAEL,GAAKM,EAAEN,KAAOG,KAAKC,IAAIC,EAAEL,IAAMG,KAAKC,IAAIE,EAAEN,KAEjE,OAAOF,ECZJ,MAAMmL,EAYThJ,YAAYiJ,EAAW,KAAMC,EAAW7D,IAAKA,GAAG8D,EAAa,OACzD,OAAIF,EACOD,EAAKI,QAAQH,EAAUC,EAAUC,IAExC3M,KAAK6M,UAAYH,EACjB1M,KAAK8M,WAAa,GAEd9M,KAAK+M,YADS,OAAdJ,EACmB,CAAC/K,EAAGC,IAAMD,EAAIC,EACZ,OAAd8K,EACY,CAAC/K,EAAGC,IAAMD,EAAIC,EAEd8K,EAEhB3M,MAWD,eAACyM,EAAUC,EAAW7D,IAAKA,GAAG8D,EAAa,OACrD,MAAMK,EAAO,IAAIR,EAAK,KAAME,EAAUC,GAChCM,EAAYD,EAAKF,WACvB,IAAK,MAAM/G,KAAK0G,EACZQ,EAAUV,KAAK,CACX,QAAWxG,EACX,MAAS2G,EAAS3G,KAG1B,IAAK,IAAIxE,EAAIG,KAAKwL,MAAOT,EAASrL,OAAS,EAAK,GAAIG,GAAK,IAAKA,EAC1DyL,EAAKG,cAAc5L,GAEvB,OAAOyL,EASXI,MAAMC,EAASC,GACX,MAAML,EAAYjN,KAAK8M,YACtBG,EAAUK,GAAUL,EAAUI,IAAY,CAACJ,EAAUI,GAAUJ,EAAUK,IAO9EC,cACI,MAAMN,EAAYjN,KAAK8M,WACvB,IAAIU,EAAQP,EAAU7L,OAAS,EAC/B,KAAOoM,EAAQ,GAAG,CACd,IAAIC,EAAc/L,KAAKwL,OAAOM,EAAQ,GAAK,GAC3C,IAAKxN,KAAK+M,YAAYE,EAAUO,GAAOxM,MAAOiM,EAAUQ,GAAazM,OACjE,MAEJhB,KAAKoN,MAAMK,EAAaD,GACxBA,EAAQC,GAUhBlB,KAAKmB,GACD,MAEMC,EAAO,CAAC,QAAWD,EAAS,MAFpB1N,KAAK6M,UAAUa,IAK7B,OAFA1N,KAAK8M,WAAWP,KAAKoB,GACrB3N,KAAKuN,cACEvN,KAOXmN,cAAcS,EAAY,GACtB,MAAMX,EAAYjN,KAAK8M,WACjBH,EAAa3M,KAAK+M,YAClB3L,EAAS6L,EAAU7L,OACzB,IAAIyM,EAAO,EAAID,EAAc,EACzBE,EAAQ,EAAIF,EAAc,EAC1BJ,EAAQI,EACZ,GAAIJ,EAAQpM,EAAQ,KAAM,2BACtByM,EAAOzM,GAAUuL,EAAWM,EAAUY,GAAM7M,MAAOiM,EAAUO,GAAOxM,SACpEwM,EAAQK,GAERC,EAAQ1M,GAAUuL,EAAWM,EAAUa,GAAO9M,MAAOiM,EAAUO,GAAOxM,SACtEwM,EAAQM,GAERN,IAAUI,IACV5N,KAAKoN,MAAMQ,EAAaJ,GACxBxN,KAAKmN,cAAcK,IAQ3BO,MACI,MAAMd,EAAYjN,KAAK8M,WACvB,GAAyB,IAArBG,EAAU7L,OACV,OAAO,KACJ,GAAyB,IAArB6L,EAAU7L,OACjB,OAAO6L,EAAUc,MAErB/N,KAAKoN,MAAM,EAAGH,EAAU7L,OAAS,GACjC,MAAM4M,EAAOf,EAAUc,MAEvB,OADA/N,KAAKmN,gBACEa,EAOF,YACL,OAAOhO,KAAK8M,WAAW1L,OAAS,EAAIpB,KAAK8M,WAAW,GAAK,KAQpD,WACL,IAAK,IAAIvL,EAAI,EAAGJ,EAAInB,KAAK8M,WAAW1L,OAAQG,EAAIJ,IAAKI,QAC3CvB,KAAK8M,WAAWvL,GAAGmM,QAQjCO,UACI,OAAOjO,KAAKqE,OACPjB,MAAK,CAACxB,EAAEC,IAAM7B,KAAK+M,YAAYnL,EAAGC,IAAM,EAAI,IAOrDwC,OACI,OAAOrE,KAAK8M,WACP7J,KAAI4F,GAAKA,EAAE6E,UAOpBQ,WACI,OAAOlO,KAAK8M,WAON,aACN,OAAO9M,KAAK8M,WAAW1L,OAOlB,YACL,OAAuB,IAAhBpB,KAAKoB,QC/Lb,MAAM+M,EAYT3K,YAAYiJ,EAAW,KAAMjK,EAASC,GAkBlC,OAjBAzC,KAAKoO,MAAQ,MACT5K,YAAY6K,EAAOC,EAAO,KAAMC,EAAO,KAAMC,EAAO,MAChDxO,KAAKqO,MAAQA,EACbrO,KAAKsO,OAASA,EACdtO,KAAKuO,OAASA,EACdvO,KAAKwO,OAASA,IAGtBxO,KAAKyO,MAAQ,MACTjL,YAAYkL,GACR1O,KAAK0O,OAASA,IAGtB1O,KAAK2O,QAAUnM,EACXiK,GACAzM,KAAKkI,IAAIuE,GAENzM,KAQXkI,IAAIuE,GAKA,OAJAA,EAAWA,EAASxJ,KAAI,CAACyK,EAASF,KACvB,CAACA,MAAOA,EAAOE,QAASA,MAEnC1N,KAAK4O,MAAQ5O,KAAK6O,WAAWpC,GACtBzM,KAQX6O,WAAWpC,GACP,GAAwB,IAApBA,EAASrL,OACT,OAAO,IAAIpB,KAAKyO,MAAMhC,GACnB,CACH,IAQI1H,EARA+J,EAAI9O,KAAK+O,iBAAiBtC,GAC1BuC,EAAkBvC,EAASrJ,MAAK,CAACxB,EAAGC,IAAMD,EAAE8L,QAAQoB,GAAKjN,EAAE6L,QAAQoB,KACnE3N,EAAI6N,EAAgB5N,OACpB6N,EAAUvN,KAAKwL,MAAM/L,EAAI,GACzB+N,EAAIzC,EAASwC,GACb9F,EAAI6F,EAAgB3L,MAAM,EAAG4L,GAC7B3H,EAAI0H,EAAgB3L,MAAM4L,EAAS9N,GACnCqN,EAAS9M,KAAK0I,OAAOqC,EAASxJ,KAAI4F,GAAK7I,KAAK2O,QAAQO,EAAExB,QAAS7E,EAAE6E,YAOrE,OAJI3I,EADAoE,EAAE/H,OAAS,GAAKkG,EAAElG,OAAS,EACvB,IAAIpB,KAAKoO,MAAMc,EAAGlP,KAAK6O,WAAW1F,GAAInJ,KAAK6O,WAAWvH,GAAIkH,GAE1D,IAAIxO,KAAKyO,MAAMhC,GAEhB1H,GASfgK,iBAAiBhK,GACb,IAAI8D,EAAI9D,EAAE,GAAG2I,QAAQtM,OACjB6I,EAAQ,IAAIlI,MAAM8G,GAEtB,IAAK,IAAItH,EAAI,EAAGA,EAAIsH,IAAKtH,EACrB0I,EAAM1I,GAAK,CAAC4N,KAAU,KAG1B,IAAIC,EAASrK,EAAEsK,QAAO,CAACC,EAAKC,KACxB,IAAK,IAAIhO,EAAI,EAAGA,EAAIsH,IAAKtH,EACrB+N,EAAI/N,GAAG,GAAKG,KAAK2G,IAAIiH,EAAI/N,GAAG,GAAIgO,EAAQ7B,QAAQnM,IAChD+N,EAAI/N,GAAG,GAAKG,KAAK0I,IAAIkF,EAAI/N,GAAG,GAAIgO,EAAQ7B,QAAQnM,IAEpD,OAAO+N,IACRrF,GACHmF,EAASA,EAAOnM,KAAI4F,GAAKA,EAAE,GAAKA,EAAE,KAElC,IAAIiG,EAAI,EACR,IAAK,IAAIvN,EAAI,EAAGA,EAAIsH,IAAKtH,EACrBuN,EAAIM,EAAO7N,GAAK6N,EAAON,GAAKvN,EAAIuN,EAEpC,OAAOA,EASXU,OAAO/N,EAAGa,EAAI,GACV,OAAOtC,KAAKyP,QAAQhO,EAAGa,EAAG,IAAIkK,EAAK,MAAM3D,GAAK7I,KAAK2O,QAAQ9F,EAAE6E,QAASjM,IAAI,OAAQzB,KAAK4O,OAU3Fa,QAAQhO,EAAGa,EAAGoN,EAAG3K,GAEb,GAAI2K,EAAEtO,QAAUkB,GAAKyC,EAAEsJ,OAAStJ,EAAEyJ,QAAUxO,KAAK2O,QAAQlN,EAAGsD,EAAEsJ,MAAMX,SAAW3I,EAAEyJ,QAAUkB,EAAEC,MAAM3O,MAC/F,OAAO0O,EAMX,GAJI3K,EAAEuJ,QAAQtO,KAAKyP,QAAQhO,EAAGa,EAAGoN,EAAG3K,EAAEuJ,QAClCvJ,EAAEwJ,QAAQvO,KAAKyP,QAAQhO,EAAGa,EAAGoN,EAAG3K,EAAEwJ,QAGlCxJ,EAAE2J,OACF,IAAK,IAAInN,EAAI,EAAGJ,EAAI4D,EAAE2J,OAAOtN,OAAQG,EAAIJ,IAAKI,EAAG,CAC7C,IAAI2N,EAAInK,EAAE2J,OAAOnN,GACbe,EAAIoN,EAAEtO,OACNsO,EAAEnD,KAAK2C,IAEPQ,EAAEnD,KAAK2C,GACPQ,EAAE3B,OAId,OAAO2B,GCrIA,WAASrN,GACpB,MAAOK,EAAMe,GAAQpB,EAAEM,MACjB+M,EAAI,IAAInM,EAAOb,EAAMe,EAAM,YAC3B6D,EAAI,IAAI/D,EAAOE,EAAMA,EAAM,GAEjC,IAAK,IAAIM,EAAI,EAAGA,EAAIN,IAAQM,EAAG,CAC3B,IAAI2D,EAAIrF,EAAEc,IAAIY,GACd,IAAK,IAAIxC,EAAI,EAAGA,EAAIwC,IAAKxC,EAAG,CACxB,MAAMqO,EAAIF,EAAEvM,IAAI5B,GACVsO,EAAU3N,EAAY0N,EAAE3M,KAAI,CAAC6M,EAAIxN,IAAMwN,EAAKpI,EAAEpF,MACpDgF,EAAE1C,UAAUrD,EAAEwC,EAAG8L,GACjBnI,EAAIA,EAAEzE,KAAI,CAAC8M,EAAIzN,IAAMyN,EAAKF,EAAUD,EAAEtN,KAE1C,MAAM0N,EAASC,EAAKvI,EAAGjF,GACvB,IAAK,IAAIH,EAAI,EAAGA,EAAII,IAAQJ,EACxBoN,EAAE9K,UAAUtC,EAAGyB,EAAG2D,EAAEpF,GAAK0N,GAE7B1I,EAAE1C,UAAUb,EAAEA,EAAGiM,GAErB,MAAO,CAAC,EAAK1I,EAAG,EAAKoI,GClBV,WAASrN,EAAGC,EAAI,EAAG4N,EAAe,IAAKjF,EAAK,MACvD,MAAM1C,EAAa0C,aAAgBT,EAAaS,EAAO,IAAIT,EAAWS,GAChE5I,aAAakB,IAASlB,EAAIkB,EAAOP,KAAKX,IAC5C,MAAMlB,EAAIkB,EAAEM,MAAM,GAClB,IAAM+M,EAAGA,EAAGpI,EAAGA,GAAM6I,EAAG,IAAI5M,EAAOpC,EAAGmB,GAAG,IAAMiG,EAAWI,UAC1D,KAAOuH,KAAkB,CACrB,MAAME,EAAO9I,EAAErD,QAEToM,EAAKF,EADD9N,EAAEoD,IAAIiK,IAEhBA,EAAIW,EAAGX,EACPpI,EAAI+I,EAAG/I,EACHpF,EAAYoF,EAAEa,IAAIiI,GAAME,MAAQnP,EAAI,QACpC+O,EAAiB,GAMzB,MAAO,CACH,YAHgB5I,EAAEgJ,KAIlB,aAHiBZ,EAAE7K,YAAY0L,WCtBhC,MAAMC,EAES,qBACd,OAAOxQ,KAAKyQ,gBAGE,mBAACC,GAEf,OADA1Q,KAAKyQ,gBAAkBC,EAChB1Q,KAaXwD,YAAY+C,EAAGsC,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MACvC,GAAIlJ,MAAMmC,QAAQqC,GACdvG,KAAK2Q,MAAQ,QACb3Q,KAAKuG,EAAIhD,EAAOP,KAAKuD,OAClB,MAAIA,aAAahD,GAIpB,KAAM,sBAHNvD,KAAK2Q,MAAQ,SACb3Q,KAAKuG,EAAIA,EAUb,OANCvG,KAAK0K,GAAI1K,KAAK4Q,IAAM5Q,KAAKuG,EAAE5D,MAC5B3C,KAAK6Q,GAAKhI,EACV7I,KAAK2O,QAAUnM,EACfxC,KAAKyK,MAAQQ,EACbjL,KAAK8Q,YAAc,IAAItG,EAAWS,GAClCjL,KAAK+Q,iBAAkB,EAChB/Q,KAQXgR,UAAUC,EAAMjQ,EAAM,MAClB,IAAwE,IAApEhB,KAAKkR,eAAeC,WAAUH,GAAaA,IAAcC,IACzD,KAAO,GAAEA,8BAEb,OAAIjQ,GACAhB,KAAM,IAAGiR,KAAUjQ,EACZhB,MAEAA,KAAM,IAAGiR,KASxBG,KAAKH,EAAMjQ,EAAM,MACb,OAAOhB,KAAKgR,UAAUC,EAAMjQ,GAQhCkO,EAAE+B,EAAMjQ,EAAM,MACV,OAAOhB,KAAKgR,UAAUC,EAAMjQ,GAOhCqQ,YAEI,OADArR,KAAKsR,aACEtR,KAAKuR,EAGhBC,YACI,OAAOxR,KAAKqR,YAGhBC,aACStR,KAAK+Q,iBAAwC,mBAAd/Q,KAAKyR,OACrCzR,KAAKyR,OACLzR,KAAK+Q,iBAAkB,GAOjB,iBACV,MAAsB,WAAf/Q,KAAK2Q,MAAqB3Q,KAAKuR,EAAIvR,KAAKuR,EAAEhB,UAGhC,wBACjB,OAAOvQ,KAAKqR,YAGA,oBAAIK,GAEhB,OADS,IAAI1R,QAAQ0R,GACXL,YAGc,gCAAIK,GAC5B,OAAO1R,KAAKqR,aAAaK,GAGZ,oBAAIA,GACjB,MACMC,EADK,IAAI3R,QAAQ0R,GACRF,YACf,IAAK,MAAMlF,KAAOqF,QACRrF,GCtHX,MAAMsF,UAAYpB,EASrBhN,YAAY+C,EAAGsC,EAAE,GAEb,OADAgJ,MAAMtL,EAAGsC,GACF7I,KAMXqR,YACI,IAAI9K,EAAIvG,KAAKuG,EACT3D,EAAI2D,EAAE5D,MAAM,GACZmP,EAAI,IAAIvO,EAAOX,EAAGA,EAAG,UACrBmP,EAASxL,EAAEd,IAAIqM,GAEfhM,EAAIiM,EAAOlN,YAAYY,IAAIsM,IACzBrI,aAAcC,GAAMG,EAA4BhE,EAAG9F,KAAK6Q,IAG9D,OAFAlH,EAAIpG,EAAOP,KAAK2G,GAAG9E,YACnB7E,KAAKuR,EAAIhL,EAAEd,IAAIkE,GACR3J,KAAKgS,YC3Bb,MAAMC,UAAYzB,EAarBhN,YAAY+C,EAAGsC,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAEvC,OADA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACbjL,KAMXqR,YACI,MAAM9K,EAAIvG,KAAKuG,EACT7D,EAAO6D,EAAE5D,MAAM,GACfH,EAASxC,KAAK2O,QACpB,IAAIuD,EAAM,IAAIpO,aAAapB,GACvByP,EAAM,IAAIrO,aAAapB,GACvB0P,EAAM,EAEV,MAAM/P,EAAI,IAAIkB,EACdlB,EAAEM,MAAQ,CAACD,EAAMA,EAAM,CAACnB,EAAEwC,KACtB,GAAIxC,IAAMwC,EAAG,OAAO,EACpB,MAAMoB,EAAO5D,EAAIwC,EAAKvB,EAAO+D,EAAExD,IAAIxB,GAAIgF,EAAExD,IAAIgB,IAAM1B,EAAEsC,MAAMZ,EAAExC,GAI7D,OAHA2Q,EAAI3Q,IAAM4D,EACVgN,EAAIpO,IAAMoB,EACViN,GAAOjN,EACAA,IAEXnF,KAAKqS,KAAOhQ,EACZ6P,EAAMA,EAAIjP,KAAIyE,GAAKA,EAAIhF,IACvByP,EAAMA,EAAIlP,KAAIyE,GAAKA,EAAIhF,IACvB0P,GAAQ1P,GAAQ,EAChB,MAAMqC,EAAI,IAAIxB,EAAOb,EAAMA,GAAM,CAACnB,EAAGwC,IAAO1B,EAAEsC,MAAMpD,EAAGwC,GAAKmO,EAAI3Q,GAAK4Q,EAAIpO,GAAKqO,KAGtE1I,aAAcC,GAAMG,EAA4B/E,EAAG/E,KAAK6Q,IAGhE,OAFA7Q,KAAKuR,EAAIhO,EAAOP,KAAK2G,GAAG9E,YAEjB7E,KAAKgS,WAGN,aACN,MAAM3K,EAAIrH,KAAKuG,EAAE5D,MAAM,GACjB4O,EAAIvR,KAAKuR,EACTe,EAAMtS,KAAKqS,KAIXE,EAAM,IAAIhP,EAChBgP,EAAI5P,MAAQ,CAAC0E,EAAGA,EAAG,CAAC9F,EAAGwC,IACZxC,EAAIwC,EAAItB,EAAU8O,EAAExO,IAAIxB,GAAIgQ,EAAExO,IAAIgB,IAAMwO,EAAI5N,MAAMZ,EAAGxC,IAEhE,IAAIiR,EAAU,EACVC,EAAa,EACjB,IAAK,IAAIlR,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIwC,EAAIxC,EAAI,EAAGwC,EAAIsD,IAAKtD,EACzByO,GAAW9Q,KAAKgR,IAAIJ,EAAI3N,MAAMpD,EAAGwC,GAAKwO,EAAI5N,MAAMpD,EAAGwC,GAAI,GACvD0O,GAAc/Q,KAAKgR,IAAIJ,EAAI3N,MAAMpD,EAAGwC,GAAI,GAGhD,OAAOrC,KAAKS,KAAKqQ,EAAUC,ICrE5B,MAAME,UAAenC,EAYxBhN,YAAY+C,EAAGqM,EAAW/J,EAAI,EAAGrG,EAASC,EAAWwI,EAAK,MAItD,OAHA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,KACxBlR,KAAKgR,UAAU,IAAKtP,KAAK2G,IAAIuK,GAAalR,KAAK0I,IAAI1I,KAAKwL,MAAMlN,KAAKuG,EAAE5D,MAAM,GAAK,IAAK,GAAI3C,KAAK0K,GAAI,IAC3F1K,KAOXqR,YACIrR,KAAKsR,aACL,MAAM/K,EAAIvG,KAAKuG,EACT7D,EAAO1C,KAAK0K,GACZlI,EAASxC,KAAK2O,QAEd/L,EAAI,IAAIW,EACdX,EAAED,MAAQ,CAACD,EAAMA,EAAM,CAACnB,EAAEwC,IAAMxC,GAAKwC,EAAIvB,EAAO+D,EAAExD,IAAIxB,GAAIgF,EAAExD,IAAIgB,IAAMnB,EAAE+B,MAAMZ,EAAExC,IAChF,MAAMsR,EAAoB,GAC1B,IAAK,IAAItR,EAAI,EAAGA,EAAImB,IAAQnB,EAAG,CAC3B,MAAMwB,EAAM,GACZ,IAAK,IAAIgB,EAAI,EAAGA,EAAIrB,IAAQqB,EACxBhB,EAAIwJ,KAAK,CACL,MAASxI,EACT,SAAYnB,EAAE+B,MAAMpD,EAAGwC,KAG/B,MAAM+O,EAAI,IAAItG,EAAKzJ,GAAK8F,GAAKA,EAAE3F,UAAU,OACzC2P,EAAkBtG,KAAKuG,EAAE7E,UAAU5K,MAAM,EAAGrD,KAAK+S,GAAK,IAO1D,MAAMC,EAAI,IAAIzP,EAAOb,EAAMA,GAAM,CAACnB,EAAEwC,KAChC,MAAMkP,EAAQJ,EAAkBtR,GAAG2R,MAAK/R,GAAKA,EAAEqM,QAAUzJ,IACzD,OAAOkP,EAAQA,EAAM/P,SAAWiM,OAGpC,IAAK,IAAI5N,EAAI,EAAGA,EAAImB,IAAQnB,EACxB,IAAK,IAAIwC,EAAI,EAAGA,EAAIrB,IAAQqB,EACxB,IAAK,IAAIzB,EAAI,EAAGA,EAAII,IAAQJ,EACxB0Q,EAAEpO,UAAUrD,EAAGwC,EAAGrC,KAAK2G,IAAI2K,EAAErO,MAAMpD,EAAGwC,GAAIiP,EAAErO,MAAMpD,EAAGe,GAAK0Q,EAAErO,MAAMrC,EAAGyB,KAKjF,IAAImO,EAAM,IAAIpO,aAAapB,GACvByP,EAAM,IAAIrO,aAAapB,GACvB0P,EAAM,EACN/P,EAAI,IAAIkB,EAAOb,EAAMA,GAAM,CAACnB,EAAEwC,KAC9B,IAAIoB,EAAM6N,EAAErO,MAAMpD,EAAGwC,GAKrB,OAJAoB,EAAMA,IAAQgK,IAAW,EAAIhK,EAC7B+M,EAAI3Q,IAAM4D,EACVgN,EAAIpO,IAAMoB,EACViN,GAAOjN,EACAA,KAGX+M,EAAMA,EAAIjP,KAAIyE,GAAKA,EAAIhF,IACvByP,EAAMA,EAAIlP,KAAIyE,GAAKA,EAAIhF,IACvB0P,GAAQ1P,GAAQ,EAChB,MAAMqC,EAAI,IAAIxB,EAAOb,EAAMA,GAAM,CAACnB,EAAEwC,IAAO1B,EAAEsC,MAAMpD,EAAEwC,GAAKmO,EAAI3Q,GAAK4Q,EAAIpO,GAAKqO,KAGpE1I,aAAcC,GAAMG,EAA4B/E,EAAG/E,KAAK6Q,IAGhE,OAFA7Q,KAAKuR,EAAIhO,EAAOP,KAAK2G,GAAG9E,YAEjB7E,KAAKgS,YCrFb,MAAMmB,UAAgB3C,EAazBhN,YAAY+C,EAAGsC,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAEvC,OADA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACbjL,KASXoT,wBAAwBpJ,GACpB,MACM3C,EADIrH,KAAKuG,EACH5D,MAAM,GAClB,IAAI0Q,EAAUrT,KAAK8Q,YAAYxF,WAAajE,EAAI,EAC5CiM,EAAU,KACVC,GAAW,IACf,IAAK,IAAIhS,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMiS,EAAOxJ,EAAKqJ,EAAS9R,GACvBiS,EAAOD,IACPA,EAAWC,EACXF,EAAU/R,GAGlBgS,GAAW,IACX,IAAK,IAAIhS,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMkS,EAAOzJ,EAAKsJ,EAAS/R,GACvBkS,EAAOF,IACPA,EAAWE,EACXJ,EAAU9R,GAGlB,MAAO,CAAC8R,EAASC,EAASC,GAO9BlC,YACI,MAAM9K,EAAIvG,KAAKuG,EACTc,EAAId,EAAE5D,MAAM,GACZkG,EAAI7I,KAAK6Q,GACTrO,EAASxC,KAAK2O,QACd4C,EAAI,IAAIhO,EAAO8D,EAAGwB,EAAG,GAC3B,IAAImB,EAAO,CAACpI,EAAGC,IAAMW,EAAO+D,EAAExD,IAAInB,GAAI2E,EAAExD,IAAIlB,IAE5C,IAAK,IAAI6R,EAAO,EAAGA,EAAO7K,IAAK6K,EAAM,CACjC,IAAIC,EAAW3J,EAEf,MAAOqJ,EAASC,EAASM,GAAQ5T,KAAKoT,wBAAwBpJ,GAU9D,GAAa,IAAT4J,EAAY,CAEZ,IAAK,IAAIrS,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAEMsS,GAFO7J,EAAKqJ,EAAS9R,IAEN,EAAIqS,GAAQ,EADpB5J,EAAKsJ,EAAS/R,IACkB,IAAM,EAAIqS,GACvDrC,EAAE3M,UAAUrD,EAAGmS,EAAMG,GAMzB7J,EAAO,CAACpI,EAAGC,IAAMH,KAAKS,KAAKwR,EAAS/R,EAAGC,IAAM,GAAK0P,EAAE5M,MAAM/C,EAAG8R,GAAQnC,EAAE5M,MAAM9C,EAAG6R,KAAU,IAKlG,OADA1T,KAAKuR,EAAIA,EACFvR,KAAKgS,YCxFb,MAAM8B,UAAYtD,EAYrBhN,YAAY+C,EAAGwN,EAAQlL,EAAI,EAAGrG,EAASC,EAAWwI,EAAK,MAInD,OAHA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,UACxBlR,KAAKgR,UAAU,SAAU+C,GAClB/T,KAMXqR,YACI,IAAI9K,EAAIvG,KAAKuG,GACP7D,EAAMe,GAAS8C,EAAE5D,MACnBoR,EAAS/T,KAAKgU,QACdC,EAAgB,GAChBC,EAAW,EACfH,EAAOI,SAAQ,CAAClO,EAAG1E,KACX0E,KAAKgO,GACLA,EAAchO,GAAGmO,QACjBH,EAAchO,GAAGvD,KAAK6J,KAAKhG,EAAExD,IAAIxB,KAEjC0S,EAAchO,GAAK,CACf,GAAMiO,IACN,MAAS,EACT,KAAQ,CAAC3N,EAAExD,IAAIxB,QAM3B,IAAI8S,EAAS9N,EAAE2C,KACXoL,EAAS,IAAI/Q,EAAO2Q,EAAUzQ,GAClC,IAAK,IAAI8Q,KAASN,EAAe,CAC7B,IACIO,EADIjR,EAAOP,KAAKiR,EAAcM,GAAO7R,MAC1B+R,SACf,IAAK,IAAI1Q,EAAI,EAAGA,EAAIN,IAAQM,EACxBuQ,EAAO1P,UAAUqP,EAAcM,GAAOG,GAAI3Q,EAAGyQ,EAAOzQ,IAI5D,IAAI4Q,EAAM,IAAIpR,EAAOE,EAAMA,GAC3B,IAAK,IAAI8Q,KAASN,EAAe,CAC7B,IAAIvM,EAAI4M,EAAOvR,IAAIkR,EAAcM,GAAOG,IACpCvQ,EAAI,IAAIZ,EAAOE,EAAM,GAAIM,GAAM2D,EAAE3D,GAAKsQ,IACtChN,EAAI4M,EAAcM,GAAOH,MAC7BO,EAAMA,EAAIzM,IAAI/D,EAAEsB,IAAItB,EAAEU,aAAamD,KAAKX,IAI5C,IAAIuN,EAAM,IAAIrR,EAAOE,EAAMA,GAC3B,IAAK,IAAI8Q,KAASN,EAAe,CAC7B,IAAIvM,EAAI4M,EAAOvR,IAAIkR,EAAcM,GAAOG,IACpCvQ,EAAI,IAAIZ,EAAOE,EAAM,GAAIM,GAAM2D,EAAE3D,KACjCuD,EAAI2M,EAAcM,GAAO7R,KAC7B,IAAK,IAAInB,EAAI,EAAGJ,EAAI8S,EAAcM,GAAOH,MAAO7S,EAAIJ,IAAKI,EAAG,CACxD,IAAIsT,EAAQ,IAAItR,EAAOE,EAAM,GAAG,CAACM,EAAEK,IAAMkD,EAAE/F,GAAGwC,GAAKI,EAAEQ,MAAMZ,EAAG,KAC9D6Q,EAAMA,EAAI1M,IAAI2M,EAAMpP,IAAIoP,EAAMhQ,eAItC,IAAM6E,aAAcC,GAAMG,EAA4B8K,EAAI9P,UAAUW,IAAIkP,GAAM3U,KAAK6Q,IAKnF,OAJAlH,EAAIpG,EAAOP,KAAK2G,GAAG9E,YACnB7E,KAAKuR,EAAIhL,EAAEd,IAAIkE,GAGR3J,KAAKgS,YC3Eb,MAAM8C,UAAYtE,EAYrBhN,YAAY+C,EAAGqM,EAAW/J,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAIlD,OAHA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,KACxBlR,KAAKgR,UAAU,IAAKtP,KAAK2G,IAAIuK,GAAalR,KAAK0I,IAAI1I,KAAKwL,MAAMlN,KAAK0K,GAAK,IAAK,GAAI1K,KAAK0K,GAAK,IACpF1K,KAMXqR,YACI,MAAM9K,EAAIvG,KAAKuG,EACTsC,EAAI7I,KAAK6Q,GACTnO,EAAO1C,KAAK0K,GACZjH,EAAOzD,KAAK4Q,GACZtO,EAAItC,KAAKgR,UAAU,KACnBlO,EAAKiS,EAAoBxO,EAAGjE,EAAG,KAAMtC,KAAK2O,SAC1CmD,EAAI,IAAIvO,EAAOjB,EAAG,EAAG,GACrB0S,EAAI,IAAIzR,EAAOb,EAAMA,GAE3B,IAAK,IAAIK,EAAM,EAAGA,EAAML,IAAQK,EAAK,CACjC,MAAMkS,EAASnS,EAAGC,GACZmS,EAAI,IAAI3R,EAAOjB,EAAGmB,GAAM,CAAClC,EAAGwC,IAAMwC,EAAE5B,MAAMsQ,EAAO1T,GAAGwC,EAAGA,GAAKwC,EAAE5B,MAAM5B,EAAKgB,KACzE+B,EAAIoP,EAAEzP,IAAIyP,EAAExM,GAClB,GAAKpG,EAAImB,EAAO,CACZ,MAAM0R,EAAUjT,EAAY4D,EAAEwK,MAAQ,IACtC,IAAK,IAAIvM,EAAI,EAAGA,EAAIzB,IAAKyB,EACrB+B,EAAElB,UAAUb,EAAGA,EAAG+B,EAAEnB,MAAMZ,EAAGA,GAAKoR,GAI1C,IAAIC,EAAI7R,EAAO8R,SAASvP,EAAGgM,EAAG9R,KAAK8Q,aACnCsE,EAAIA,EAAEnN,OAAOmN,EAAE/T,KACf,IAAK,IAAI0C,EAAI,EAAGA,EAAIzB,IAAKyB,EACrBiR,EAAEpQ,UAAU7B,EAAKkS,EAAOlR,GAAGA,EAAGqR,EAAEzQ,MAAMZ,EAAG,IAIjD,MACMuR,EADI,IAAI/R,EAAOb,EAAMA,EAAM,YACpByF,IAAI6M,GACX1L,EAAIgM,EAAG5M,EAAEjD,IAAI6P,IACX5L,aAAcC,GAAMG,EAA4BR,EAAEZ,EAAE5D,UAAW+D,EAAI,GAI3E,OAHA7I,KAAKuR,EAAIhO,EAAOP,KAAK2G,EAAEtG,MAAM,EAAG,EAAIwF,IAAIH,EAGjC1I,KAAKgS,YC3Db,MAAMuD,UAAa/E,EAatBhN,YAAY+C,EAAGqM,EAAW/J,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAIlD,GAHA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,KACxBlR,KAAKgR,UAAU,IAAKtP,KAAK2G,IAAIuK,GAAalR,KAAK0I,IAAI1I,KAAKwL,MAAMlN,KAAK0K,GAAK,IAAK,GAAI1K,KAAK0K,GAAK,IACvF1K,KAAK4Q,IAAM/H,EAAG,KAAO,4BAA2B7I,KAAK4Q,2EAA2E/H,MACpI,OAAO7I,KAMXqR,YACI,MAAM9K,EAAIvG,KAAKuG,EACTsC,EAAI7I,KAAK6Q,IACPnO,EAAME,GAAM2D,EAAE5D,MAChBL,EAAItC,KAAKgR,UAAU,KAEnBlO,EAAKiS,EAAoBxO,EAAGjE,EAAG,KAAMtC,KAAK2O,SAE1CmD,EAAI,IAAIvO,EAAOX,EAAGA,EAAG,UACrBmC,EAAI,IAAIxB,EAAOb,EAAMA,EAAM,GAEjC,IAAK,IAAIK,EAAM,EAAGA,EAAML,IAAQK,EAAK,CAEjC,MAAMyS,EAAM,CAACzS,KAAQD,EAAGC,GAAKE,KAAI9B,GAAKA,EAAE4C,KACxC,IAAI0R,EAAMlS,EAAOP,KAAKwS,EAAIvS,KAAI9B,GAAKoF,EAAExD,IAAI5B,MAEzCsU,EAAMA,EAAIhQ,IAAIqM,GAEd,MAAMhM,EAAI2P,EAAIhQ,IAAIgQ,EAAI5Q,cACd6E,aAAcgM,GAAM5L,EAA4BhE,EAAG+C,GAErD8M,EAAQpS,EAAOP,KAAK0S,GAEpBE,EAAMD,EAAM9Q,YAAYY,IAAIkQ,GAAOzN,IAAI,EAAIxG,KAAKS,KAAKG,EAAI,IAC/D,IAAK,IAAIf,EAAI,EAAGA,EAAIe,EAAI,IAAKf,EACzB,IAAK,IAAIwC,EAAI,EAAGA,EAAIzB,EAAI,IAAKyB,EACzBgB,EAAEH,UAAU4Q,EAAIjU,GAAIiU,EAAIzR,GAAIgB,EAAEJ,MAAM6Q,EAAIjU,GAAIiU,EAAIzR,KAAOxC,IAAMwC,EAAI,EAAI,GAAM6R,EAAIjR,MAAMpD,EAAGwC,IAMpG,MAAQ2F,aAAc6H,GAAMzH,EAA4B/E,EAAG8D,EAAI,GAI/D,OAHA7I,KAAKuR,EAAIhO,EAAOP,KAAKuO,EAAElO,MAAM,IAAIwB,YAG1B7E,KAAKgS,YC7Db,MAAM6D,UAAarF,EAetBhN,YAAY+C,EAAGuP,EAAW,GAAIC,EAAQ,GAAIlN,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAQlE,OAPA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,aAAc,YACpClR,KAAK0K,GAAI1K,KAAK4Q,IAAO5Q,KAAKuG,EAAE5D,MAC9B3C,KAAKgR,UAAU,aAActP,KAAK2G,IAAIyN,EAAY9V,KAAK0K,GAAK,IAC5D1K,KAAKgR,UAAU,UAAW+E,GAC1B/V,KAAKgW,MAAQ,EACbhW,KAAKuR,EAAI,IAAIhO,EAAOvD,KAAK0K,GAAI1K,KAAK6Q,IAAI,IAAM7Q,KAAK8Q,YAAYnI,SACtD3I,KAGXyR,KAAKlP,EAAgB,MAEjB,MAAM0T,EAAUvU,KAAKwU,IAAIlW,KAAKmW,aACxB9O,EAAIrH,KAAK0K,GACT9H,EAAI5C,KAAK4Q,GACTpO,EAASxC,KAAK2O,QACdpI,EAAIvG,KAAKuG,EACf,IAAI6P,EACJ,GAAI7T,EACA6T,EAAQ7T,MACL,CACH6T,EAAQ,IAAI7S,EAAO8D,EAAGA,GACtB,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMkU,EAAMlP,EAAExD,IAAIxB,GAClB,IAAK,IAAIwC,EAAIxC,EAAI,EAAGwC,EAAIsD,IAAKtD,EAAG,CAC5B,MAAMb,EAAWV,EAAOiT,EAAKlP,EAAExD,IAAIgB,IACnCqS,EAAMxR,UAAUrD,EAAGwC,EAAGb,GACtBkT,EAAMxR,UAAUb,EAAGxC,EAAG2B,KAMlC,MAAMmT,EAAI,IAAI9S,EAAO8D,EAAGA,EAAG,SAE3BrH,KAAKsW,OAAS,IAAI/S,EAAO8D,EAAGzE,EAAG,SAC/B5C,KAAKuW,OAAS,IAAIhT,EAAO8D,EAAGzE,EAAG,GAG/B,IAAI4T,EAAO,IAAIzU,MAAMsF,GAAGkD,KAAK,GAG7B,IAAK,IAAIhJ,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,IAAIkV,GAAU,IACVC,EAAUvH,IACVlG,EAAO,EACP0N,GAAO,EAEPC,EAAM,EACV,MAAOD,GAAM,CACT,IAAIE,EAAO,EACX,IAAK,IAAI9S,EAAI,EAAGA,EAAIsD,IAAKtD,EAAG,CACxB,IAAI+S,EAAKpV,KAAKqV,KAAKX,EAAMzR,MAAMpD,EAAGwC,GAAKkF,GACnC1H,IAAMwC,IAAG+S,EAAK,GAClBN,EAAKzS,GAAK+S,EACVD,GAAQC,EAEZ,IAAIE,EAAQ,EACZ,IAAK,IAAIjT,EAAI,EAAGA,EAAIsD,IAAKtD,EAAG,CACxB,IAAI+S,EAAe,IAATD,EAAc,EAAIL,EAAKzS,GAAK8S,EACtCL,EAAKzS,GAAK+S,EACNA,EAAK,OACLE,GAASF,EAAKpV,KAAKwU,IAAIY,IAG3BE,EAAQf,GACRQ,EAAUxN,EACVA,EAAQyN,IAAYvH,IAAoB,EAAPlG,GAAcA,EAAOyN,GAAW,IAEjEA,EAAUzN,EACVA,EAAQwN,KAAY,IAAcxN,EAAO,GAAOA,EAAOwN,GAAW,KAEpEG,EACElV,KAAKC,IAAIqV,EAAQf,GAjCjB,OAiCiCU,GAAO,GACxCC,GAjCK,KAiCYD,GAAO,GAGhC,IAAK,IAAI5S,EAAI,EAAGA,EAAIsD,IAAKtD,EACrBsS,EAAEzR,UAAUrD,EAAGwC,EAAGyS,EAAKzS,IAK/B,MAAMkT,EAAO,IAAI1T,EAAO8D,EAAGA,EAAG,SACxB6P,EAAS,EAAJ7P,EACX,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIwC,EAAIxC,EAAGwC,EAAIsD,IAAKtD,EAAG,CACxB,MAAMmL,EAAIxN,KAAK0I,KAAKiM,EAAE1R,MAAMpD,EAAGwC,GAAKsS,EAAE1R,MAAMZ,EAAGxC,IAAM2V,EAAI,QACzDD,EAAKrS,UAAUrD,EAAGwC,EAAGmL,GACrB+H,EAAKrS,UAAUb,EAAGxC,EAAG2N,GAI7B,OADAlP,KAAKmX,GAAKF,EACHjX,KAGXqR,UAAU+F,EAAW,KACjBpX,KAAKsR,aACL,IAAK,IAAI/P,EAAI,EAAGA,EAAI6V,IAAc7V,EAC9BvB,KAAKqX,OAET,OAAOrX,KAAKgS,WAGL,aAEP,IADAhS,KAAKsR,eAEDtR,KAAKqX,aACCrX,KAAKgS,WAKnBqF,OACI,MAAMC,IAAStX,KAAKgW,MACdK,EAAIrW,KAAKmX,GACTI,EAAQvX,KAAKsW,OACbkB,EAAQxX,KAAKuW,OACblP,EAAIrH,KAAK0K,GACTqL,EAAU/V,KAAKyX,SACfC,EAAM1X,KAAK6Q,GACjB,IAAIU,EAAIvR,KAAKuR,EAGb,MAAMoG,EAAOL,EAAO,IAAM,EAAI,EAGxBM,EAAK,IAAIrU,EAAO8D,EAAGA,EAAG,SAC5B,IAAIwQ,EAAO,EACX,IAAK,IAAItW,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIwC,EAAIxC,EAAI,EAAGwC,EAAIsD,IAAKtD,EAAG,CAC5B,IAAI+T,EAAO,EACX,IAAK,IAAIjP,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMkP,EAAQxG,EAAE5M,MAAMpD,EAAGsH,GAAK0I,EAAE5M,MAAMZ,EAAG8E,GACzCiP,GAAQC,EAAQA,EAEpB,MAAMC,EAAK,GAAK,EAAIF,GACpBF,EAAGhT,UAAUrD,EAAGwC,EAAGiU,GACnBJ,EAAGhT,UAAUb,EAAGxC,EAAGyW,GACnBH,GAAQ,EAAIG,EAKpB,MAAMtI,EAAI,IAAInM,EAAO8D,EAAGA,EAAG,GAC3B,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIwC,EAAIxC,EAAI,EAAGwC,EAAIsD,IAAKtD,EAAG,CAC5B,MAAMoB,EAAMzD,KAAK0I,IAAIwN,EAAGjT,MAAMpD,EAAGwC,GAAK8T,EAAM,QAC5CnI,EAAE9K,UAAUrD,EAAGwC,EAAGoB,GAClBuK,EAAE9K,UAAUb,EAAGxC,EAAG4D,GAI1B,MAAM8S,EAAO,IAAI1U,EAAO8D,EAAGqQ,EAAK,SAChC,IAAK,IAAInW,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIwC,EAAI,EAAGA,EAAIsD,IAAKtD,EAAG,CACxB,MAAMmU,EAAU,GAAKP,EAAOtB,EAAE1R,MAAMpD,EAAGwC,GAAK2L,EAAE/K,MAAMpD,EAAGwC,IAAM6T,EAAGjT,MAAMpD,EAAGwC,GACzE,IAAK,IAAI8E,EAAI,EAAGA,EAAI6O,IAAO7O,EACvBoP,EAAKrT,UAAUrD,EAAGsH,EAAGoP,EAAKtT,MAAMpD,EAAGsH,GAAKqP,GAAW3G,EAAE5M,MAAMpD,EAAGsH,GAAK0I,EAAE5M,MAAMZ,EAAG8E,KAM1F,IAAIsP,EAAQ,IAAIrU,aAAa4T,GAC7B,IAAK,IAAInW,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIsH,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMuP,EAAMH,EAAKtT,MAAMpD,EAAGsH,GACpBwP,EAAMd,EAAM5S,MAAMpD,EAAGsH,GACrByP,EAASd,EAAM7S,MAAMpD,EAAGsH,GAE9B,IAAI0P,EAAU7W,KAAK8W,KAAKJ,KAAS1W,KAAK8W,KAAKH,GAAgB,GAATC,EAAcA,EAAS,GACrEC,EAAU,MAAKA,EAAU,KAC7Bf,EAAM5S,UAAUrD,EAAGsH,EAAG0P,GAEtB,MACME,GADSnB,EAAO,IAAM,GAAK,IACTe,EAAMtC,EAAUwC,EAAUH,EAClDb,EAAM3S,UAAUrD,EAAGsH,EAAG4P,GAEtBlH,EAAE3M,UAAUrD,EAAGsH,EAAG0I,EAAE5M,MAAMpD,EAAGsH,GAAK4P,GAClCN,EAAMtP,IAAM0I,EAAE5M,MAAMpD,EAAGsH,GAI/B,IAAK,IAAItH,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIsH,EAAI,EAAGA,EAAI,IAAKA,EACrB0I,EAAE3M,UAAUrD,EAAGsH,EAAG0I,EAAE5M,MAAMpD,EAAGsH,GAAKsP,EAAMtP,GAAKxB,GAIrD,OAAOrH,KAAKuR,GCrNL,WAASjM,EAAGoT,EAAIC,EAAS,KACpC,MACMxX,EAAIuX,EAAGtX,OACb,IAAI2H,EAAQ,KACR6P,EAAM,IACN5W,EAAI0W,EAAGrV,QACPwV,EAAKvT,EAAEtD,GACP8W,GAAc,EAElB,KAAOH,MAAc,IAAMG,GAAa,CACpCA,GAAc,EACd,IAAK,IAAIvX,EAAI,EAAGA,EAAIJ,IAAKI,EAAG,CACxBS,EAAET,IAAM,KACR,IAAIwX,EAAMzT,EAAEtD,GACZA,EAAET,IAAM,KACR,IAAIyX,GAAMD,EAAMF,GAAM,KAClBnX,KAAKC,IAAIqX,GAfL,MAgBJF,GAAc,GAElB9W,EAAET,IAAMwH,EAAQiQ,EAChBH,EAAKvT,EAAEtD,GAEX+G,GAAU6P,GAAOC,EAAK,KAAO,GAC7BD,EAAMC,EAEV,OAAO7W,ECjBJ,MAAMiX,UAAazI,EACtBhN,YAAY+C,EAAG2S,EAAY,GAAIC,EAAmB,EAAGC,EAAS,EAAGvQ,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAgBzF,OAfA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,cAAe,qBAAsB,aAC3DlR,KAAK0K,GAAI1K,KAAK4Q,IAAO5Q,KAAKuG,EAAE5D,MAC9BuW,EAAcxX,KAAK2G,IAAIrI,KAAK0K,GAAK,EAAGwO,GACpClZ,KAAKgR,UAAU,cAAekI,GAC9BlZ,KAAKgR,UAAU,qBAAsBtP,KAAK2G,IAAI8Q,EAAoBD,EAAc,IAChFlZ,KAAKgR,UAAU,WAAYoI,GAC3BpZ,KAAKgW,MAAQ,EACbhW,KAAKqZ,QAAU,EACfrZ,KAAKsZ,kBAAoB,EACzBtZ,KAAKuZ,oBAAsB,EAC3BvZ,KAAKwZ,sBAAwB,EAC7BxZ,KAAKyZ,UAAY,IACjBzZ,KAAK0Z,eAAiB,EACtB1Z,KAAKuR,EAAI,IAAIhO,EAAOvD,KAAK0K,GAAI1K,KAAK6Q,IAAI,IAAM7Q,KAAK8Q,YAAYnI,SACtD3I,KAGX2Z,gBAAgBvK,EAAQgK,GACpB,MACMQ,EAAK9N,EAAS,EAAY,EAATsD,EAAY,KAC7ByK,EAAK/N,EAAS,EAAY,EAATsD,EAAY,KAEnC,IAAK,IAAI7N,EAAI,EAAGJ,EAAIyY,EAAGxY,OAAQG,EAAIJ,IAAKI,EAAG,CACvC,MAAMuY,EAAOF,EAAGrY,GAChBsY,EAAGtY,GAAMuY,EAAOV,EAAW,EAAI1X,KAAKqV,MAAM+C,EAAOV,GAAYhK,GAQjE,OAAO2K,GALM7K,IACT,MAAM8K,EAAQlO,EAAS,EAAG,KAAK7I,KAAI,CAACmB,EAAG7C,KAAMsY,SAAGtY,IAVrCS,EAUgD4X,EAAGrY,GAVhDK,EAUoDsN,EAAE,GAVnDrN,EAUuDqN,EAAE,GAVnD,GAAK,EAAItN,EAAIF,KAAKgR,IAAI1Q,EAAG,EAAIH,KAA1C,IAACG,EAAGJ,EAAGC,KAWjB,OAAOH,KAAKS,KAAKD,EAAY8X,EAAM/W,KAAI8C,GAAKA,EAAIA,QAGjC,CAAC,EAAG,IAG3BkU,8BAA8BC,EAAWC,EAAQC,GAC7C,IAAK,IAAI7Y,EAAI,EAAGJ,EAAI+Y,EAAU9Y,OAAQG,EAAIJ,IAAKI,EAC3C,IAAK,IAAIwC,EAAI,EAAGI,EAAI+V,EAAU3Y,GAAGH,OAAQ2C,EAAII,IAAKJ,EAAG,CACjD,MAAM2D,EAAIwS,EAAU3Y,GAAGwC,GAAG/C,MAAQoZ,EAAK7Y,GACvC2Y,EAAU3Y,GAAGwC,GAAG/C,MAAQ0G,EAAI,EAAIhG,KAAKqV,KAAKrP,EAAIyS,EAAO5Y,IAAM,EAGnE,OAAO2Y,EAGXG,iBAAiBC,EAAKhY,GAClB,MAAMiY,EAAqB,KACrBC,EAAmB,KAEnBrB,EAAqBnZ,KAAKya,oBAC1BC,EAAShZ,KAAKiZ,KAAKrY,GACnB8X,EAAO,GACPD,EAAS,GACT5T,EAAIvG,KAAKuG,EAET2T,EAAY,IAAI3T,GAAGtD,KAAI2X,GAAON,EAAI9K,OAAOoL,EAAKtY,GAAG4L,WAAW2M,YAElE,IAAK,IAAItZ,EAAI,EAAGJ,EAAIoF,EAAE5D,MAAM,GAAIpB,EAAIJ,IAAKI,EAAG,CACxC,IAAIuZ,EAAK,EACLC,EAAK5L,IACL6L,EAAM,EAEV,MAAMC,EAAgBf,EAAU3Y,GAC1B2Z,EAAgBD,EAAcE,QAAOtS,GAAKA,EAAE7H,MAAQ,IACpDoa,EAAuBF,EAAc9Z,OAC3C,GAAIga,GAAwBjC,EAAoB,CAC5C,MAAM3L,EAAQ9L,KAAKwL,MAAMiM,GACnBkC,EAAgBlC,EAAqB3L,EACvCA,EAAQ,GACR4M,EAAK7N,KAAK2O,EAAc1N,EAAQ,IAC5B6N,EAAgBd,IAChBH,EAAK7Y,GAAGP,OAASqa,GAAiBH,EAAc1N,GAAOxM,MAAQka,EAAc1N,EAAQ,MAGzF4M,EAAK7Y,GAAGP,MAAQqa,EAAgBH,EAAc,GAAGla,WAE9Coa,EAAuB,IAC9BhB,EAAK7Y,GAAK2Z,EAAcE,EAAuB,GAAGpa,OAEtD,IAAK,IAAIgB,EAAI,EAAGA,EA/BL,KA+BmBA,EAAG,CAC7B,IAAI6U,EAAO,EACX,IAAK,IAAI9S,EAAI,EAAGA,EAAIzB,IAAKyB,EAAG,CACxB,MAAM8E,EAAIoS,EAAclX,GAAG/C,MAAQoZ,EAAK7Y,GACxCsV,GAAShO,EAAI,EAAInH,KAAKqV,KAAMlO,EAAImS,GAAQ,EAE5C,GAAItZ,KAAKC,IAAIkV,EAAO6D,GAAUH,EAC1B,MAEA1D,EAAO6D,GACNK,EAAIC,GAAO,CAACA,GAAMF,EAAKC,GAAM,IAGzBD,EAAIE,GADLD,IAAO5L,IACK,CAAC6L,EAAW,EAANA,GAEN,CAACA,GAAMF,EAAKC,GAAM,GAI1CZ,EAAO5Y,GAAKyZ,EAEZ,MAAMM,EAAYL,EAAc5L,QAAO,CAACzN,EAAGC,IAAMD,EAAIC,EAAEb,OAAO,GAAKia,EAAc7Z,OAEjF,GAAIgZ,EAAK7Y,GAAK,EACN4Y,EAAO5Y,GAAKiZ,EAAmBc,IAC/BnB,EAAO5Y,GAAKiZ,EAAmBc,OAEhC,CACH,MAAMC,EAASrB,EAAU7K,QAAO,CAACC,EAAKhD,IAAQgD,EAAMhD,EAAI+C,QAAO,CAACzN,EAAGC,IAAMD,EAAIC,EAAEb,OAAO,GAAKsL,EAAIlL,SAC3F+Y,EAAO5Y,GAAKiZ,EAAmBe,IAC/BpB,EAAO5Y,GAAKiZ,EAAmBe,IAK3C,MAAO,CACH,UAAarB,EACb,OAAUC,EACV,KAAQC,GAIhBoB,sBAAsBjV,EAAG2S,GACrB,MAAM7R,EAAId,EAAE5D,MAAM,GACZ2X,EAAM,IAAInM,EAAS5H,EAAEgK,UAAW9N,GACtC,IAAI,UAAEyX,EAAF,OAAaC,EAAb,KAAqBC,GAASpa,KAAKqa,iBAAiBC,EAAKpB,GAC7DgB,EAAYla,KAAKia,8BAA8BC,EAAWC,EAAQC,GAClE,MAAM9R,EAAS,IAAI/E,EAAO8D,EAAGA,EAAG,SAChC,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMka,EAAcvB,EAAU3Y,GAC9B,IAAK,IAAIwC,EAAI,EAAGA,EAAI0X,EAAYra,SAAU2C,EACtCuE,EAAO1D,UAAUrD,EAAGka,EAAY1X,GAAG2J,QAAQF,MAAOiO,EAAY1X,GAAG/C,OAGzE,MAAM0a,EAAoBpT,EAAOI,EAC3BiT,EAAcrT,EAAON,KAAK0T,GAChC,OAAOpT,EACFJ,IAAIwT,GACJvT,IAAIwT,GACJ3T,KAAKhI,KAAKsZ,mBACVpR,IAAIyT,EAAY3T,KAAK,EAAIhI,KAAKsZ,oBAGvCsC,wBAAwBC,GACpB,MAAMC,EAAU9b,KAAK+b,SACfzT,EAAS,IAAI0T,aAAaF,EAAQ1a,QAAQmJ,MAAM,GAChD0R,EAAc7R,EAAI0R,GAClBI,EAAYJ,EAAQ7Y,KAAImS,GAAKyG,GAAYzG,EAAI6G,KACnD,IAAK,IAAI1a,EAAI,EAAGA,EAAI+G,EAAOlH,SAAUG,EAC/B2a,EAAU3a,GAAK,IAAG+G,EAAO/G,GAAKG,KAAK2I,MAAMwR,EAAWK,EAAU3a,KACpE,OAAO+G,EAGX6T,OAAOC,GACH,MAAM1Z,EAAO,GACPe,EAAO,GACPY,EAAO,IACLgY,EAAQC,GAAWF,EAAMzZ,MACjC,IAAK,IAAII,EAAM,EAAGA,EAAMsZ,IAAUtZ,EAC9B,IAAK,IAAII,EAAM,EAAGA,EAAMmZ,IAAUnZ,EAAK,CACnC,MAAMwB,EAAQyX,EAAMzX,MAAM5B,EAAKI,GACjB,IAAVwB,IACAjC,EAAK6J,KAAKxJ,GACVU,EAAK8I,KAAKpJ,GACVkB,EAAKkI,KAAK5H,IAItB,MAAO,CACH,KAAQjC,EACR,KAAQe,EACR,KAAQY,GAIhBoN,OACI,MAAQ7P,EAAGC,GAAM7B,KAAK2Z,gBAAgB3Z,KAAKqZ,QAASrZ,KAAKuc,WACzDvc,KAAKwc,GAAK5a,EACV5B,KAAKyc,GAAK5a,EACV7B,KAAK0c,OAAS1c,KAAKwb,sBAAsBxb,KAAKuG,EAAGvG,KAAK2c,cACtD,MAAM,KAAEja,EAAF,KAAQe,EAAMY,KAAMyX,GAAY9b,KAAKmc,OAAOnc,KAAK0c,QAQvD,OAPA1c,KAAK4c,MAAQla,EACb1C,KAAK6c,MAAQpZ,EACbzD,KAAK+b,SAAWD,EAChB9b,KAAK8c,mBAAqB9c,KAAK4b,wBAAwB5b,KAAKyZ,WAC5DzZ,KAAK+c,4BAA8B/c,KAAK8c,mBAAmB7Z,KAAI4F,GAAKA,EAAI7I,KAAKwZ,wBAC7ExZ,KAAKgd,sBAAwBhd,KAAK8c,mBAAmBzZ,QACrDrD,KAAKid,+BAAiCjd,KAAK+c,4BAA4B1Z,QAChErD,KAGW,uBAACgB,GACnBhB,KAAKya,oBAAsBzZ,EAGT,yBAClB,OAAOhB,KAAKya,oBAGJ,aAACzZ,GACThB,KAAKuc,UAAYvb,EAGT,eACR,OAAOhB,KAAKuc,UAGhBH,QAEI,OADApc,KAAKsR,aACE,CAAE7N,KAAMzD,KAAK4c,MAAOla,KAAM1C,KAAK6c,MAAOf,QAAS9b,KAAK+b,UAG/D1K,UAAU+F,GACNpX,KAAKsR,aACL8F,EAAaA,GAAcpX,KAAKyZ,UAChC,IAAK,IAAIlY,EAAI,EAAGA,EAAI6V,IAAc7V,EAC9BvB,KAAKqX,OAET,OAAOrX,KAAKgS,WAGL,aAGP,IAFAhS,KAAKsR,aACLtR,KAAKgW,MAAQ,EACNhW,KAAKgW,MAAQhW,KAAKyZ,WACrBzZ,KAAKqX,aACCrX,KAAKgS,WAEf,OAAOhS,KAAKgS,WAGhBkL,MAAMlb,GACF,OAAIA,EAAI,EAAU,EACdA,GAAK,GAAW,EACbA,EAGXmb,iBAAiBC,EAAgBC,EAAgBC,EAAMC,GACnD,MACI1M,GAAI6G,EACJ8F,OAAQzU,EACRwQ,oBAAqBkE,EACrBjB,GAAI5a,EACJ6a,GAAI5a,EACJib,mBAAoBY,EACpBX,4BAA6BY,EAC7BV,+BAAgCW,EAChCZ,sBAAuBa,EACvBX,MAAOY,GACP9d,KACE+d,EAAcR,EAAKnc,OAEzB,IAAK,IAAIG,EAAI,EAAGJ,EAAIuc,EAAkBtc,OAAQG,EAAIJ,IAAKI,EACnD,GAAIsc,EAAqBtc,IAAMvB,KAAKgW,MAAO,CACvC,MAAMjS,EAAIuZ,EAAK/b,GACTe,EAAIib,EAAKhc,GACTgO,EAAU6N,EAAera,IAAIgB,GAC7BkP,EAAQoK,EAAeta,IAAIT,GAC3B0H,EAAO5H,EAAkBmN,EAAS0D,GACxC,IAAI+K,EAAa,EACbhU,EAAO,IACPgU,GAAe,EAAIpc,EAAIC,EAAIH,KAAKgR,IAAI1I,EAAMnI,EAAI,IAAOD,EAAIF,KAAKgR,IAAI1I,EAAMnI,GAAK,IAEjF,IAAK,IAAIgH,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMoV,EAASH,EAAKE,GAAczO,EAAQ1G,GAAKoK,EAAMpK,KAAOE,EACtD+F,EAAIS,EAAQ1G,GAAKoV,EACjB7d,EAAI6S,EAAMpK,GAAKoV,EACrB1O,EAAQ1G,GAAKiG,EACbmE,EAAMpK,GAAKzI,EACXgd,EAAexY,UAAUb,EAAG8E,EAAGiG,GAC/BuO,EAAezY,UAAUtC,EAAGuG,EAAGzI,GAEnCyd,EAAqBtc,IAAMmc,EAAkBnc,GAC7C,MAAM2c,GAAiBle,KAAKgW,MAAQ4H,EAA8Brc,IAAMoc,EAA2Bpc,GACnG,IAAK,IAAI2N,EAAI,EAAGA,EAAIgP,IAAiBhP,EAAG,CACpC,MAAM5M,EAAIZ,KAAKwL,MAAMlN,KAAK8Q,YAAYnI,OAASoV,GACzC9K,EAAQoK,EAAeta,IAAIwa,EAAKjb,IAChC0H,EAAO5H,EAAkBmN,EAAS0D,GACxC,IAAI+K,EAAa,EACjB,GAAIhU,EAAO,EACPgU,EAAc,EAAIP,EAAqB5b,IAAO,IAAMmI,IAASpI,EAAIF,KAAKgR,IAAI1I,EAAMnI,GAAK,SAClF,GAAIkC,IAAMzB,EACb,SAEJ,IAAK,IAAIuG,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMoV,EAASH,EAAKE,GAAczO,EAAQ1G,GAAKoK,EAAMpK,KAAOE,EACtD+F,EAAIS,EAAQ1G,GAAKoV,EACjB7d,EAAI6S,EAAMpK,GAAKoV,EACrB1O,EAAQ1G,GAAKiG,EACbmE,EAAMpK,GAAKzI,EACXgd,EAAexY,UAAUb,EAAG8E,EAAGiG,GAC/BuO,EAAezY,UAAU2Y,EAAKjb,GAAIuG,EAAGzI,IAG7Cwd,EAA8Brc,IAAO2c,EAAgBP,EAA2Bpc,GAGxF,OAAO6b,EAGX/F,OACI,IAAIC,IAAStX,KAAKgW,MACdzE,EAAIvR,KAAKuR,EAKb,OAHAvR,KAAKwd,OAAUxd,KAAK0Z,gBAAkB,EAAIpC,EAAOtX,KAAKyZ,WACtDzZ,KAAKuR,EAAIvR,KAAKmd,iBAAiB5L,EAAGA,EAAGvR,KAAK4c,MAAO5c,KAAK6c,OAE/C7c,KAAKuR,GCpTb,MAAM4M,UAAe3N,EAgBxBhN,YAAY+C,EAAG6X,EAAa,IAAKtP,EAAI,EAAGjG,EAAI,EAAGrG,EAASC,EAAWwI,EAAK,MAKpE,OAJA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,aAAc,KACtClR,KAAKgR,UAAU,aAAcoN,GAC7Bpe,KAAKgR,UAAU,IAAKlC,GACb9O,KAQXyR,KAAK4M,EAAM,KAAM/D,EAAM,MACnB,MAAM/T,EAAIvG,KAAKuG,EACTc,EAAId,EAAE5D,MAAM,GACZkG,EAAI7I,KAAK6Q,GACTrO,EAASxC,KAAK2O,QACdG,EAAI9O,KAAKse,GACfte,KAAKue,UAAY,EAAIzP,EACrB9O,KAAKwe,WAAa,EAAI1P,EACtB9O,KAAKye,SAAW,EAAI3P,EACpB9O,KAAKuR,EAAI8M,GAAO,IAAIzM,EAAIrL,EAAGsC,GAAGwI,YAC9BrR,KAAKsa,IAAMA,GAAO,IAAInM,EAAS5H,EAAEgK,UAAW/N,GAC5C,MAAM,SAACkc,EAAD,QAAW5C,GAAW9b,KAAK2e,mBAAmB3e,KAAKue,UAAWve,KAAKwe,WAAYxe,KAAKye,UAQ1F,OAPAze,KAAK0e,SAAWA,EAChB1e,KAAK8b,QAAUA,EACf9b,KAAK4e,GAAK,IAAOvX,EAAIqX,EAAS/b,MAAM,GACpC3C,KAAK8F,EAAIqJ,IACTnP,KAAKwI,IAAM,KACXxI,KAAK6e,IAAM,IAAItb,EAAO8D,EAAGwB,EAAG,GAC5B7I,KAAK8e,KAAO,IAAIvb,EAAO8D,EAAGwB,EAAG,GACtB7I,KASX2e,mBAAmBJ,EAAWC,EAAYC,GACtC,MAAMjc,EAASxC,KAAK2O,QACdyP,EAAape,KAAK+e,YAClBxY,EAAIvG,KAAKuG,EACTc,EAAId,EAAE5D,MAAM,GACZ2X,EAAMta,KAAKsa,IACX0E,EAAUtd,KAAK2G,IAAIkW,EAAY,GAAIlX,GACnC4X,EAAO,IAAI1b,EAAO8D,EAAG2X,GACrBE,EAAgB,IAAI3b,EAAO8D,EAAG2X,GACpC,IAAK,IAAIzd,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB+Y,EAAI9K,OAAOjJ,EAAExD,IAAIxB,GAAIyd,EAAU,GAC1B9Q,WACAiN,QAAOtS,GAAgB,GAAXA,EAAE7H,QACdoC,MAAK,CAACxB,EAAGC,IAAMD,EAAEZ,MAAQa,EAAEb,QAC3BmT,SAAQ,CAACtL,EAAG9E,KACTkb,EAAKra,UAAUrD,EAAGwC,EAAG8E,EAAE6E,QAAQF,OAC/B0R,EAActa,UAAUrD,EAAGwC,EAAG8E,EAAE7H,UAI5C,MAAMme,EAAM,IAAIrb,aAAauD,GAC7B,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB4d,EAAI5d,GAAKG,KAAK0I,KACN8U,EAAcva,MAAMpD,EAAG,GACvB2d,EAAcva,MAAMpD,EAAG,GACvB2d,EAAcva,MAAMpD,EAAG,GACvB2d,EAAcva,MAAMpD,EAAG,IAAM,EAC7B,OAGZ,MAAM8U,EAAIrW,KAAKof,QAAQF,EAAeC,EAAKF,GAE3C,IAAIP,EAAW1e,KAAKqf,qBAAqBhJ,EAAG4I,EAAMV,EAAWC,GACzDc,EAAaZ,EAAS/b,MAAM,GAChC,MAAM4c,EAAoB,IAAIzb,aAAawb,GAC3C,IAAK,IAAI/d,EAAI,EAAGA,EAAI+d,IAAc/d,EAAG,CACjC,MAAMwC,EAAI2a,EAAS/Z,MAAMpD,EAAG,GACtBe,EAAIoc,EAAS/Z,MAAMpD,EAAG,GAC5Bge,EAAkBhe,GAAKiB,EAAO+D,EAAExD,IAAIgB,GAAIwC,EAAExD,IAAIT,IAElD,IAAIwZ,EAAU9b,KAAKwf,cAAcd,EAAUrI,EAAG4I,EAAMM,EAAmBJ,GAEvE,GAAIV,EAAW,EAAG,CACd,MAAM,gBAACgB,EAAD,eAAkBC,GAAkB1f,KAAK2f,wBAAwBpZ,EAAGkY,EAAUU,GACpFT,EAAWA,EAASxY,OAAOuZ,EAAiB,YAC5C3D,EAAUhY,aAAad,KAAK,IAAI8Y,KAAY4D,IAEhDJ,EAAaZ,EAAS/b,MAAM,GAC5B,IAAIid,GAAa,IACjB,IAAK,IAAIre,EAAI,EAAGA,EAAI+d,IAAc/d,EAC1Bse,MAAM/D,EAAQva,MAAMua,EAAQva,GAAK,GACjCqe,EAAa9D,EAAQva,KAAIqe,EAAa9D,EAAQva,IAEtD,IAAIue,GAAe,IACnB,IAAK,IAAIve,EAAI,EAAGA,EAAI+d,IAAc/d,EAC9Bua,EAAQva,IAAMqe,EACd9D,EAAQva,IAAM,KACdua,EAAQva,GAAKG,KAAKwU,IAAI,EAAIkI,EAAatC,EAAQva,IAC3Cue,EAAehE,EAAQva,KAAIue,EAAehE,EAAQva,IAE1D,IAAK,IAAIA,EAAI,EAAGA,EAAI+d,IAAc/d,EAC9Bua,EAAQva,IAAMue,EAElB,MAAO,CACH,SAAYpB,EACZ,QAAW5C,GAYnBsD,QAAQF,EAAeC,EAAKF,GACxB,MAAO5X,EAAG6R,GAAegG,EAAcvc,MACvC,OAAO,IAAIY,EAAO8D,EAAG6R,GAAa,CAAC3X,EAAGwC,IAC3BrC,KAAKqV,MAAOmI,EAAcva,MAAMpD,EAAGwC,IAAM,GAAKob,EAAI5d,GAAK4d,EAAIF,EAAKta,MAAMpD,EAAGwC,OAaxFsb,qBAAqBhJ,EAAG4I,EAAMV,EAAWC,GACrC,MAAMnX,EAAI4X,EAAKtc,MAAM,GACf+b,EAAW,IAAInb,EAAO8D,EAAIkX,EAAYC,EAAY,GACxD,IAAK,IAAIjd,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,IAAIwe,EAAMxe,EAAIgd,EAAYC,EAC1B,MAAMwB,EAAehgB,KAAKigB,UAAU5J,EAAEtT,IAAIxB,GAAG0B,KAAI4F,IAAMA,KACvD,IAAK,IAAI9E,EAAI,EAAGA,EAAIwa,IAAaxa,EAAG,CAChC,IAAImc,EAAMnc,EAAIya,EACd,MAAM2B,EAAMlB,EAAKta,MAAMpD,EAAGye,EAAajc,IACjCqc,EAAUpgB,KAAKqgB,kBAAkB7B,EAAYnX,EAAG2Y,EAAa3c,MAAM,EAAGU,EAAI,IAChF,IAAK,IAAIzB,EAAI,EAAGA,EAAIkc,IAAclc,EAAG,CACjC,MAAMkL,EAAQuS,EAAMG,EAAM5d,EACpBge,EAAMF,EAAQ9d,GACpBoc,EAAS9Z,UAAU4I,EAAO,EAAGjM,GAC7Bmd,EAAS9Z,UAAU4I,EAAO,EAAG2S,GAC7BzB,EAAS9Z,UAAU4I,EAAO,EAAG8S,KAIzC,OAAO5B,EAQXuB,UAAU5d,GACN,OAAOA,EACFY,KAAI,CAAC4F,EAAGtH,KAAc,CAACsH,EAAGA,EAAGtH,EAAGA,MAChC6B,MAAK,CAACxB,EAAGC,IAAMD,EAAEiH,EAAIhH,EAAEgH,IACvB5F,KAAK4F,GAAMA,EAAEtH,IAUtB8e,kBAAkBnE,EAAWqE,EAASC,GAClC,MAAMjY,EAAavI,KAAK8Q,YAClB2P,EAAW3U,EAAS,EAAGyU,EAAU,GAAGpF,QAAOtS,GAAK2X,EAAQE,QAAQ7X,GAAK,IAC3E,OAAON,EAAWoD,OAAO8U,EAAU/e,KAAK2G,IAAI6T,EAAWuE,EAASrf,OAAS,IAY7Eoe,cAAcd,EAAUrI,EAAG4I,EAAMM,EAAmBJ,GAChD,MAAMG,EAAaZ,EAAS/b,MAAM,GAC5BmZ,EAAU,IAAIhY,aAAawb,GACjC,IAAK,IAAI7d,EAAI,EAAGA,EAAI6d,IAAc7d,EAAG,CACjC,MAAMF,EAAImd,EAAS/Z,MAAMlD,EAAG,GACtB0e,EAAMlB,EAAKlc,IAAIxB,GAAGmf,QAAQhC,EAAS/Z,MAAMlD,EAAG,IAC5Ckf,EAAQtK,EAAE1R,MAAMpD,EAAG4e,GACzB,IAAIS,EAAQlf,KAAKqV,MAAMwI,EAAkB9d,IAAM,IAAK0d,EAAI5d,GAAK4d,EAAIT,EAAS/Z,MAAMlD,EAAG,MAC/Emf,EAAQ,QAAOA,EAAQ,OAC3B9E,EAAQra,GAAKkf,EAAQC,EAEzB,OAAO9E,EAUX6D,wBAAwBpZ,EAAGkY,EAAUU,GACjC,MAAM3c,EAASxC,KAAK2O,QACdpG,EAAavI,KAAK8Q,YAClBzJ,EAAId,EAAE5D,MAAM,GACZ8c,EAAkB,IAAIlc,EAAO8D,EAAIoX,EAAU,GAC3CiB,EAAiB,IAAI5b,aAAauD,EAAIoX,GAC5C,IAAK,IAAIld,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMwe,EAAMxe,EAAIkd,EACVoC,EAAU,IAAI/U,EAAS,EAAGvK,EAAI,MAAOuK,EAASvK,EAAI,EAAG8F,EAAI,IAC/D,IAAK,IAAItD,EAAI,EAAGA,EAAI0a,IAAY1a,EAAG,CAC/B,IAAKoc,EAAKG,GAAO/X,EAAWoD,OAAOkV,EAAS,GACxCF,EAAQjf,KAAKqV,MAAOvU,EAAO+D,EAAExD,IAAIxB,GAAIgF,EAAExD,IAAIod,KAAS,IAAMhB,EAAI5d,GAAK4d,EAAIgB,KACvEQ,EAAQ,QAAOA,EAAQ,OAC3B,IAAIC,EAAQlf,KAAKqV,MAAOvU,EAAO+D,EAAExD,IAAIxB,GAAIgF,EAAExD,IAAIud,KAAS,IAAMnB,EAAI5d,GAAK4d,EAAImB,KACvEM,EAAQ,QAAOA,EAAQ,OAEvBD,EAAQC,KACPT,EAAKG,GAAO,CAACA,EAAKH,IAClBQ,EAAOC,GAAS,CAACA,EAAOD,IAE7B,MAAMnT,EAAQuS,EAAMhc,EACpB0b,EAAgB7a,UAAU4I,EAAO,EAAGjM,GACpCke,EAAgB7a,UAAU4I,EAAO,EAAG2S,GACpCV,EAAgB7a,UAAU4I,EAAO,EAAG8S,GACpCZ,EAAelS,GAASmT,EAAQC,GAGxC,MAAO,CACH,gBAAmBnB,EACnB,eAAkBC,GAQ1BoB,MAAMvP,GACF,MAAMgN,EAAYve,KAAKue,UACjBC,EAAaxe,KAAKwe,WAClBE,EAAW1e,KAAK0e,SAChB5C,EAAU9b,KAAK8b,SACdzU,EAAGqQ,GAAOnG,EAAE5O,MACb2c,EAAaZ,EAAS/b,MAAM,GAC5BsV,EAAO,IAAI1U,EAAO8D,EAAGqQ,EAAK,GAChC,IAAIqJ,EAAO,IAAIhf,MAAM2V,GAAKnN,KAAK,GAC3ByW,EAAO,IAAIjf,MAAM2V,GAAKnN,KAAK,GAC3B0W,EAAO,EACPC,EAAO,EACPC,EAAS,EACTC,EAAO,EACX,MAAMC,EAAiBha,EAAIkX,EAAYC,EAEvC,IAAK,IAAI/c,EAAI,EAAGA,EAAI6d,IAAc7d,EAAG,CACjC,MAAOF,EAAGwC,EAAGzB,GAAKoc,EAAS3b,IAAItB,GAE/B,GAAIA,EAAI+c,GAAc,GAAK/c,GAAK4f,EAAgB,CAC5CJ,EAAO,EACPC,EAAO,EACP,IAAK,IAAIrY,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMyY,EAAO/P,EAAE5M,MAAMpD,EAAGsH,GAClB0Y,EAAOhQ,EAAE5M,MAAMZ,EAAG8E,GAClB2Y,EAAOjQ,EAAE5M,MAAMrC,EAAGuG,GACxBkY,EAAKlY,GAAKyY,EAAOC,EACjBP,EAAKnY,GAAKyY,EAAOE,EACjBP,GAASF,EAAKlY,IAAM,EACpBqY,GAASF,EAAKnY,IAAM,OAGrB,CACHqY,EAAO,EACP,IAAK,IAAIrY,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMyY,EAAO/P,EAAE5M,MAAMpD,EAAGsH,GAClB2Y,EAAOjQ,EAAE5M,MAAMrC,EAAGuG,GACxBmY,EAAKnY,GAAKyY,EAAOE,EACjBN,GAASF,EAAKnY,IAAM,GAIxBoY,EAAOC,KAAQC,EACnBC,GAAQtF,EAAQra,IAAM,EAAIyf,EAAOD,GACjC,MAAM7L,GAAK0G,EAAQra,IAAMwf,EAAOC,KAAU,EAC1C,IAAK,IAAIrY,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAM4Y,EAAKV,EAAKlY,GAAKqY,EAAO9L,EACtBsM,EAAKV,EAAKnY,GAAKoY,EAAO7L,EAC5B6C,EAAKrT,UAAUrD,EAAGsH,EAAGoP,EAAKtT,MAAMpD,EAAGsH,GAAK4Y,EAAKC,GAC7CzJ,EAAKrT,UAAUb,EAAG8E,EAAGoP,EAAKtT,MAAMZ,EAAG8E,GAAK4Y,GACxCxJ,EAAKrT,UAAUtC,EAAGuG,EAAGoP,EAAKtT,MAAMrC,EAAGuG,GAAK6Y,IAGhD,MAAO,CACH,KAAQzJ,EACR,KAAQmJ,EACR,OAAUD,GAQlB9P,UAAUsQ,EAAgB,KACtB3hB,KAAKsR,aACL,IAAK,IAAIgG,EAAO,EAAGA,EAAOqK,IAAiBrK,EACvCtX,KAAK4hB,MAAMtK,GAEf,OAAOtX,KAAKgS,WAOL,aACPhS,KAAKsR,aACL,IAAK,IAAIgG,EAAO,EAAGA,EAAO,MAAOA,EAC7BtX,KAAK4hB,MAAMtK,SACLtX,KAAKgS,WAEf,OAAOhS,KAAKgS,WAQhB4P,MAAMtK,GACF,MAAMuK,EAAQvK,EAAO,IAAM,GAAK,GAC1BwK,EAAQ9hB,KAAK8F,EACb+Y,EAAM7e,KAAK6e,IACXtN,EAAIvR,KAAKuR,EAAErJ,IAAI2W,EAAI7W,KAAK6Z,KACxB,KAAC5J,EAAD,KAAOmJ,EAAP,OAAaD,GAAUnhB,KAAK8gB,MAAMvP,GAIxC,OAHAvR,KAAK8F,EAAIsb,EACTphB,KAAKuR,EAAIvR,KAAK+hB,kBAAkBxQ,EAAG+F,EAAMW,GACzCjY,KAAK4e,IAAOkD,EAAQV,EAAOphB,KAAKwI,IAAQ,KAAO,GACxCxI,KAAKuR,EAUhBwQ,kBAAkBxQ,EAAG+F,EAAMW,GACvB,MAAO5Q,EAAGqQ,GAAOnG,EAAE5O,MACbkf,EAAQvK,EAAO,IAAM,GAAK,GAE1BwH,EAAO9e,KAAK8e,KACZD,EAAM7e,KAAK6e,IACXD,EAAK5e,KAAK4e,GAChB,IAAK,IAAIrd,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIsH,EAAI,EAAGA,EAAI6O,IAAO7O,EAAG,CAC1B,MAAMmZ,EAAYtgB,KAAK8W,KAAKqG,EAAIla,MAAMpD,EAAGsH,KAAOnH,KAAK8W,KAAKP,EAAKtT,MAAMpD,EAAGsH,IAAOiW,EAAKna,MAAMpD,EAAGsH,GAAK,GAAKnH,KAAK0I,IAAuB,GAAnB0U,EAAKna,MAAMpD,EAAGsH,GANrH,KAOTiW,EAAKla,UAAUrD,EAAGsH,EAAGmZ,GACrBnD,EAAIja,UAAUrD,EAAGsH,EAAGgZ,EAAQhD,EAAIla,MAAMpD,EAAGsH,GAAK+V,EAAKE,EAAKna,MAAMpD,EAAGsH,GAAKoP,EAAKtT,MAAMpD,EAAGsH,IACpF0I,EAAE3M,UAAUrD,EAAGsH,EAAG0I,EAAE5M,MAAMpD,EAAGsH,GAAKgW,EAAIla,MAAMpD,EAAGsH,IAGvD,OAAO0I,GCxYR,MAAM0Q,EAWTze,YAAY0e,EAAQC,EAAQ,SAAU3f,EAAOC,GAOzC,OANAzC,KAAKoiB,IAAM,EACXpiB,KAAKqiB,QAAUH,EACfliB,KAAK2O,QAAUnM,EACfxC,KAAKsiB,SAAWH,EAChBniB,KAAKyR,OACLzR,KAAKN,KAAOM,KAAKuiB,KACVviB,KASXwiB,aAAaxhB,EAAOgD,EAAK,YACrB,IACI0I,EADA+V,EAAW,GAEf,OAAQze,GACJ,IAAK,WACD0I,EAAW7D,GAAKA,EAAEmB,KAClB,MACJ,IAAK,QACD0C,EAAW7D,GAAKA,EAAE6Z,MAClB,MACJ,QACI,KAAM,eAGd,OADA1iB,KAAK2iB,UAAU3iB,KAAKN,KAAMgN,EAAU1L,EAAOyhB,GACpCA,EAUXE,UAAUhV,EAAMrI,EAAGtE,EAAOsH,GAClBhD,EAAEqI,IAAS3M,EACXsH,EAAOiE,KAAKoB,EAAKiV,WAEjB5iB,KAAK2iB,UAAUhV,EAAKE,KAAMvI,EAAGtE,EAAOsH,GACpCtI,KAAK2iB,UAAUhV,EAAKG,MAAOxI,EAAGtE,EAAOsH,IAO7CmJ,OACI,MAAMjP,EAASxC,KAAK2O,QACdtM,EAAIrC,KAAKqiB,QACTlhB,EAAInB,KAAK6iB,GAAKxgB,EAAEM,MAAM,GACtBmgB,EAAQ9iB,KAAK+iB,OAAS,IAAIjf,aAAa3C,GACvCoB,EAAkBvC,KAAKgjB,iBAAmB,IAAIjhB,MAAMZ,GAC1D,IAAK,IAAII,EAAI,EAAGA,EAAIJ,IAAKI,EAAG,CACxBuhB,EAAMvhB,GAAK,EACXgB,EAAgBhB,GAAK,IAAIuC,aAAa3C,GACtC,IAAK,IAAI4C,EAAI,EAAGA,EAAI5C,IAAK4C,EACrBxB,EAAgBhB,GAAGwC,GAAKxC,IAAMwC,EAAIoL,IAAW3M,EAAOH,EAAEU,IAAIxB,GAAIc,EAAEU,IAAIgB,IAChExB,EAAgBhB,GAAGuhB,EAAMvhB,IAAMgB,EAAgBhB,GAAGwC,KAClD+e,EAAMvhB,GAAKwC,GAIvB,MAAM0e,EAAWziB,KAAKijB,UAAY,IAAIlhB,MAAMZ,GACtC+hB,EAASljB,KAAKmjB,QAAU,IAAIC,YAAYjiB,GAC9C,IAAK,IAAII,EAAI,EAAGA,EAAIJ,IAAKI,EACrBkhB,EAASlhB,GAAK,GACdkhB,EAASlhB,GAAG,GAAK,IAAI8hB,EAAQrjB,KAAKoiB,MAAO,KAAM,KAAM,EAAG/f,EAAEU,IAAIxB,GAAIA,EAAG,EAAG,GACxE2hB,EAAO3hB,GAAK,EAEhB,OAAOvB,KAMXuiB,KACI,MAAMphB,EAAInB,KAAK6iB,GACTC,EAAQ9iB,KAAK+iB,OACbngB,EAAI5C,KAAKgjB,iBACTP,EAAWziB,KAAKijB,UAChBC,EAASljB,KAAKmjB,QACdhB,EAAUniB,KAAKsiB,SACrB,IAAI5iB,EAAO,KACX,IAAK,IAAIwP,EAAI,EAAGoU,EAAQniB,EAAI,EAAG+N,EAAIoU,IAASpU,EAAG,CAC3C,IAAIqU,EAAK,EACT,IAAK,IAAIhiB,EAAI,EAAGA,EAAIJ,IAAKI,EACjBqB,EAAErB,GAAGuhB,EAAMvhB,IAAMqB,EAAE2gB,GAAIT,EAAMS,MAC7BA,EAAKhiB,GAGb,IAAIiiB,EAAKV,EAAMS,GACXE,EAAahB,EAASc,GAAI,GAC1BG,EAAajB,EAASe,GAAI,GAC1BG,EAAc,IAAIN,EAAQrjB,KAAKoiB,MAAOqB,EAAYC,EAAY9gB,EAAE2gB,GAAIC,IACxEf,EAASc,GAAIK,QAAQD,GACrBT,EAAOK,IAAOL,EAAOM,GACrB,IAAK,IAAIzf,EAAI,EAAGA,EAAI5C,IAAK4C,EACrB,OAAOoe,GACH,IAAK,SACGvf,EAAE2gB,GAAIxf,GAAKnB,EAAE4gB,GAAIzf,KACjBnB,EAAEmB,GAAGwf,GAAM3gB,EAAE2gB,GAAIxf,GAAKnB,EAAE4gB,GAAIzf,IAEhC,MACJ,IAAK,WACGnB,EAAE2gB,GAAIxf,GAAKnB,EAAE4gB,GAAIzf,KACjBnB,EAAEmB,GAAGwf,GAAM3gB,EAAE2gB,GAAIxf,GAAKnB,EAAE4gB,GAAIzf,IAEhC,MACJ,IAAK,UACDnB,EAAEmB,GAAGwf,GAAM3gB,EAAE2gB,GAAIxf,IAAMmf,EAAOK,GAAM3gB,EAAE2gB,GAAIxf,GAAKmf,EAAOM,GAAM5gB,EAAE4gB,GAAIzf,KAAOmf,EAAOK,GAAML,EAAOnf,IAIzGnB,EAAE2gB,GAAIA,GAAMpU,IACZ,IAAK,IAAI5N,EAAI,EAAGA,EAAIJ,IAAKI,EACrBqB,EAAErB,GAAGiiB,GAAM5gB,EAAE4gB,GAAIjiB,GAAK4N,IAE1B,IAAK,IAAIpL,EAAI,EAAGA,EAAI5C,IAAK4C,EACjB+e,EAAM/e,KAAOyf,IACbV,EAAM/e,GAAKwf,GAEX3gB,EAAE2gB,GAAIxf,GAAKnB,EAAE2gB,GAAIT,EAAMS,MACvBT,EAAMS,GAAMxf,GAGpBrE,EAAOikB,EAEX,OAAOjkB,GAKf,MAAM2jB,EACF7f,YAAYkR,EAAI7G,EAAMC,EAAO9D,EAAM6Z,EAAUrW,EAAOsW,EAAMpB,GAStD,OARA1iB,KAAK0U,GAAKA,EACV1U,KAAK6N,KAAOA,EACZ7N,KAAK8N,MAAQA,EACb9N,KAAKgK,KAAOA,EACZhK,KAAKwN,MAAQA,EACbxN,KAAK8jB,KAAe,MAARA,EAAeA,EAAOjW,EAAKiW,KAAOhW,EAAMgW,KACpD9jB,KAAK0iB,MAAiB,MAATA,EAAgBA,EAAQ,EAAIhhB,KAAK0I,IAAIyD,EAAK6U,MAAO5U,EAAM4U,OACpE1iB,KAAK6jB,SAAuB,MAAZA,EAAmBA,EAAW7jB,KAAK+jB,oBAAoBlW,EAAMC,GACtE9N,KAGX+jB,oBAAoBlW,EAAMC,GACtB,MAAMkW,EAASnW,EAAKiW,KACdG,EAASnW,EAAMgW,KACfI,EAAarW,EAAKgW,SAClBM,EAAarW,EAAM+V,SACnBC,EAAO9jB,KAAK8jB,KACZ3iB,EAAI0M,EAAKgW,SAASziB,OAClBgjB,EAAe,IAAItgB,aAAa3C,GACtC,IAAK,IAAII,EAAI,EAAGA,EAAIJ,IAAKI,EACrB6iB,EAAa7iB,IAAMyiB,EAASE,EAAW3iB,GAAK0iB,EAASE,EAAW5iB,IAAMuiB,EAE1E,OAAOM,EAGD,aACN,OAAsB,IAAfpkB,KAAK0iB,MAGhBE,SACI,GAAI5iB,KAAKqkB,OAAQ,MAAO,CAACrkB,KAAKwN,OAC9B,MAAMK,EAAO7N,KAAK6N,KACZC,EAAQ9N,KAAK8N,MACnB,OAAQD,EAAKwW,OAAS,CAACxW,EAAKL,OAASK,EAAK+U,UACrC1c,OAAO4H,EAAMuW,OAAS,CAACvW,EAAMN,OAASM,EAAM8U,WCtLlD,MAAM0B,EAaT9gB,YAAY0e,EAAQqC,EAAG/hB,EAASC,EAAWwI,EAAK,KAAMwG,GAAO,GACzDzR,KAAK2O,QAAUnM,EACfxC,KAAKqiB,QAAUH,EACfliB,KAAKwkB,GAAKD,EACV,MAAOld,EAAGzE,GAAKsf,EAAOvf,MAQtB,OAPA3C,KAAK0K,GAAKrD,EACVrH,KAAK4Q,GAAKhO,EACN2hB,EAAIld,IAAGkd,EAAIld,GACfrH,KAAK8Q,YAAc,IAAItG,EAAWS,GAClCjL,KAAKijB,UAAY,IAAIlhB,MAAMsF,GAAGkD,UAAK2B,GACnClM,KAAKykB,mBAAqBzkB,KAAK0kB,sBAAsBH,GACjD9S,GAAMzR,KAAKyR,KAAK8S,EAAGvkB,KAAKykB,oBACrBzkB,KAMXwiB,eACI,MAAM+B,EAAIvkB,KAAKwkB,GACT/B,EAAWziB,KAAKijB,UAChB3a,EAAS,IAAIvG,MAAMwiB,GAAGha,OAAOtH,KAAI,IAAM,IAAIlB,QAEjD,OADA0gB,EAAStO,SAAQ,CAACrF,EAAGvN,IAAM+G,EAAOwG,GAAGvC,KAAKhL,KACnC+G,EAQXqc,gBAAgBjW,EAAQkW,GACpB,MAAMviB,EAAIrC,KAAKqiB,QACT7f,EAASxC,KAAK2O,QACpB,IAAIpN,EAAImN,EAAOtN,OAaf,OAZQoL,EAAKI,QACTgY,GACC/b,IACG,MAAMgc,EAAKxiB,EAAEU,IAAI8F,GACjB,IAAIxH,EAAM,EACV,IAAK,IAAI0C,EAAI,EAAGA,EAAIxC,IAAKwC,EACrB1C,GAAOmB,EAAOqiB,EAAInW,EAAO3K,IAE7B,OAAO1C,IAEX,OAEK0M,MAAML,QAGnBgX,sBAAsBH,GAClB,MAAMld,EAAIrH,KAAK0K,GACTnC,EAAavI,KAAK8Q,YAClBzO,EAAIrC,KAAKqiB,QACTyC,EAAoB,IAAI/iB,MAAMwiB,GAAGha,OACjCsW,EAAU/U,EAAS,EAAGzE,EAAI,GAC1B0d,EAAexc,EAAW+C,YAAcjE,EAAI,GAClDyd,EAAkB,GAAKziB,EAAEU,IAAIgiB,GAC7B,MAAMC,EAAc,CAACD,GACfE,EAAcvjB,KAAKwL,OAAO7F,EAAIkd,GAAKA,GACzC,IAAK,IAAIhjB,EAAI,EAAGA,EAAIgjB,IAAKhjB,EAAG,CAExB,MAAMqK,EAASrD,EAAWoD,OAAOkV,EAAQ1F,QAAOtS,IAAgC,GAA3Bmc,EAAYtE,QAAQ7X,KAAWoc,GAC9EC,EAAiBllB,KAAK2kB,gBAAgBG,EAAkBzhB,MAAM,EAAG9B,GAAIqK,GAC3EoZ,EAAYzY,KAAK2Y,GACjBJ,EAAkBvjB,GAAKc,EAAEU,IAAImiB,GAEjC,OAAOJ,EAGXK,WAAWL,GACP,MAAMP,EAAIO,EAAkB1jB,OACtBiG,EAAIrH,KAAK0K,GACT9H,EAAI5C,KAAK4Q,GACTvO,EAAIrC,KAAKqiB,QACT7f,EAASxC,KAAK2O,QACd8T,EAAWziB,KAAKijB,UACtB,IAAImC,GAAmB,EAEvB,IAAK,IAAI7jB,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAM8jB,EAAKhjB,EAAEU,IAAIxB,GACjB,IAAI6X,EAAWjK,IACXmW,EAAc,KAClB,IAAK,IAAIvhB,EAAI,EAAGA,EAAIwgB,IAAKxgB,EAAG,CACxB,IAAI8E,EAAIrG,EAAOsiB,EAAkB/gB,GAAIshB,GACjCxc,EAAIuQ,IACJA,EAAWvQ,EACXyc,EAAcvhB,GAGlB0e,EAASlhB,KAAO+jB,IAChBF,GAAmB,GAEvB3C,EAASlhB,GAAK+jB,EAIlB,IAAK,IAAI/jB,EAAI,EAAGA,EAAIgjB,IAAKhjB,EAAG,CACxB,MAAMsiB,EAAWiB,EAAkBvjB,GACnC,IAAK,IAAIwC,EAAI,EAAGA,EAAInB,IAAKmB,EACrB8f,EAAS9f,GAAK,EAMtB,OAFA/D,KAAKulB,kBAAkBT,GAEhB,CACH,iBAAoBM,EACpB,kBAAqBN,GAI7BS,kBAAkBT,GACd,MAAMP,EAAIO,EAAkB1jB,OACtBiG,EAAIrH,KAAK0K,GACT9H,EAAI5C,KAAK4Q,GACTvO,EAAIrC,KAAKqiB,QACTI,EAAWziB,KAAKijB,UAChBuC,EAAkB,IAAIzjB,MAAMwiB,GAAGha,KAAK,GAE1C,IAAK,IAAIhJ,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAM8jB,EAAKhjB,EAAEU,IAAIxB,GACXkkB,EAAKhD,EAASlhB,GACpBikB,EAAgBC,KAChB,MAAM5B,EAAWiB,EAAkBW,GACnC,IAAK,IAAI1hB,EAAI,EAAGA,EAAInB,IAAKmB,EACrB8f,EAAS9f,IAAMshB,EAAGthB,GAG1B,IAAK,IAAIxC,EAAI,EAAGA,EAAIgjB,IAAKhjB,EAAG,CACxB,MAAMJ,EAAIqkB,EAAgBjkB,GAC1BujB,EAAkBvjB,GAAKujB,EAAkBvjB,GAAG0B,KAAI6L,GAAKA,EAAI3N,KASjEsQ,KAAK8S,EAAGO,GACCP,IAAGA,EAAIvkB,KAAKwkB,IACZM,IAAmBA,EAAoB9kB,KAAK0kB,sBAAsBH,IACvE,IAAIa,GAAmB,EACvB,EAAG,CACC,MAAMM,EAAmB1lB,KAAKmlB,WAAWL,GACzCA,EAAoBY,EAAiBZ,kBACrCM,EAAmBM,EAAiBN,uBAC/BA,IClKV,MAAMO,EAcTniB,YAAY0e,EAAQqC,EAAG5L,EAAS,KAAMnW,EAASC,EAAWwI,EAAK,MAC3DjL,KAAK2O,QAAUnM,EACfxC,KAAKqiB,QAAUH,EACfliB,KAAK4lB,GAAK5lB,KAAKqiB,QAAQ9R,UACvBvQ,KAAKwkB,GAAKD,EACV,MAAOld,EAAGzE,GAAKsf,EAAOvf,MAkBtB,OAjBA3C,KAAK0K,GAAKrD,EACVrH,KAAK4Q,GAAKhO,EACV5C,KAAK6lB,UAAYlN,GAAY,GAAKjX,KAAKokB,MAAMze,GAC7CrH,KAAKgjB,iBAAmB,IAAIzf,EAAO8D,EAAGA,EAAG,SAQrCkd,EAAIld,IAAGkd,EAAIld,GACfrH,KAAK8Q,YAAc,IAAItG,EAAWS,GAClCjL,KAAKijB,UAAY,IAAIlhB,MAAMsF,GAAGkD,UAAK2B,GACnClM,KAAK+lB,iBAAmB/lB,KAAKgmB,oBAAoBzB,GAEjDvkB,KAAK+Q,iBAAkB,EAChB/Q,KAMXwiB,eACI,MAAM+B,EAAIvkB,KAAKwkB,GACTniB,EAAIrC,KAAK4lB,GACV5lB,KAAK+Q,iBACN/Q,KAAKyR,KAAK8S,EAAGvkB,KAAK+lB,kBAEtB,MAAMzd,EAAS,IAAIvG,MAAMwiB,GAAGha,OAAOtH,KAAI,IAAM,IAAIlB,QAKjD,OAJAM,EAAE8R,SAAQ,CAAC8R,EAAKliB,KACZuE,EAAOtI,KAAKkmB,gBAAgBD,EAAKliB,GAAGoiB,eAAe5Z,KAAKxI,MAE5DuE,EAAO8d,QAAUpmB,KAAK+lB,iBACfzd,EAGK,kBACZ,MAAMqQ,EAAW3Y,KAAK6lB,gBAChB7lB,KAAKwiB,eACX,IAAI6D,GAAS,EACT9kB,EAAI,EACR,GACI8kB,EAASrmB,KAAKmlB,mBACRnlB,KAAKwiB,sBACL6D,KAAY9kB,EAAIoX,GA+D9BwM,aACI,MAAM9iB,EAAIrC,KAAK4lB,GACTrB,EAAIvkB,KAAKwkB,GACT4B,EAAUpmB,KAAK+lB,iBACfO,EAAQjkB,EAAEY,KAAI,CAACsjB,EAAKnmB,IAAMJ,KAAKkmB,gBAAgBK,EAAKnmB,KAEpDomB,EAAU,IAAIzkB,MAAMwiB,GAAGha,KAAK,GAC5Bkc,EAAK,IAAI1kB,MAAMwiB,GAAGha,KAAK,MA+B7B,GA9BAlI,EAAE8R,SAAQ,CAAC8R,EAAKliB,KACZ,GAAIqiB,EAAQjV,WAAUhN,GAAKA,IAAMJ,IAAK,EAAG,CACrC,MAAM2iB,EAAMJ,EAAMviB,GAAG4iB,iBACfC,EAAU,IAAI7kB,MAAMwiB,GAAGha,MAAMmc,GACnCrkB,EAAE8R,SAAQ,CAACoS,EAAKnmB,KACZ,GAAI2D,IAAM3D,EAAG,OACb,MAAMymB,EAAO7mB,KAAK8mB,cAAc1mB,EAAG2D,EAAGwiB,EAAKN,IACpC,cAAiB9kB,EAAG,iBAAoB4lB,EAAK,gBAAmBC,GAAOV,EAAMlmB,GAGpF,GAFAwmB,EAAQzlB,IAAMO,KAAK2G,IAAIwe,EAAMG,GAAOD,EAEhCF,EAAOE,EAEP,IAAK,IAAIxlB,EAAI,EAAGA,EAAIgjB,IAAKhjB,EACjBA,IAAMJ,IAAGylB,EAAQrlB,IAAMslB,EAAOE,MAK9CH,EACK3jB,KAAI,CAAC4F,EAAGtH,IAAM,CAACsH,EAAGtH,KAClB4Z,QAAO,EAAEtS,EAAGtH,KAAOsH,EAAI2d,EAAQjlB,KAC/B4S,SAAQ,EAAEtL,EAAGtH,MACNsH,EAAI2d,EAAQjlB,KACZilB,EAAQjlB,GAAKsH,EACb4d,EAAGllB,GAAKwC,UAMxBrC,KAAK2G,OAAOme,IAAY,EAAG,OAAO,EAGtC,KAAO9kB,KAAK2G,OAAOme,GAAW,GAAG,CAE7B,MAAMjlB,EAAIilB,EACLvjB,KAAI,CAAC4F,EAAGtH,IAAM,CAACsH,EAAGtH,KAClB6B,MAAK,EAAExB,IAAKC,KAAOD,EAAIC,IAAG,GAAG,GACY,GAA1CukB,EAAQjL,QAAOhX,GAAKA,GAAKsiB,EAAGllB,KAAIH,SAChCglB,EAAQ7kB,GAAKklB,EAAGllB,IAGpBilB,EAAQjlB,GAAK,EAEbilB,EACKvjB,KAAI,CAACyjB,EAAK3iB,IAAM,CAAC2iB,EAAK3iB,KACtBoX,QAAO,EAAEuL,KAASA,EAAM,IACxBvS,SAAQ,EAAE/P,EAAGL,MACV,MAAMkiB,EAAM5jB,EAAE0B,GACd,IAAI1C,EAAM,EACVgB,EAAE8R,SAAQ,CAACoS,EAAKnmB,KACRgmB,EAAQjV,WAAUhN,GAAKA,GAAKJ,GAAKI,GAAK/D,KAAM,GAC5CmB,GAAKwC,IACLuiB,EAAMlmB,GAAG+lB,gBAAkBC,EAAQriB,GACnC1C,GAAQK,KAAK2G,IAAIrI,KAAK8mB,cAAc1mB,EAAG2D,EAAGwiB,EAAKN,GAAMK,EAAMlmB,GAAG6mB,iBAAmBX,EAAMlmB,GAAGumB,iBAE1FtlB,GAAQK,KAAK2G,IAAIrI,KAAK8mB,cAAc1mB,EAAG2D,EAAGwiB,EAAKN,GAAOK,EAAMlmB,GAAGumB,iBAAkB,OAGzFH,EAAQziB,GAAK1C,KAIzB,OADArB,KAAK+lB,iBAAmBK,GACjB,EAGXU,cAAcvlB,EAAGwC,EAAG6W,EAAI,KAAMqL,EAAI,MAC9B,GAAI1kB,IAAMwC,EAAG,OAAO,EACpB,MAAMnB,EAAI5C,KAAKgjB,iBACT3gB,EAAIrC,KAAK4lB,GACTpjB,EAASxC,KAAK2O,QACpB,IAAIsS,EAAOre,EAAE+B,MAAMpD,EAAGwC,GAMtB,OALa,IAATkd,IACAA,EAAOze,EAAOoY,GAAOvY,EAAEd,GAAI0kB,GAAO5jB,EAAE0B,IACpCnB,EAAEgC,UAAUrD,EAAGwC,EAAGkd,GAClBre,EAAEgC,UAAUb,EAAGxC,EAAG0f,IAEfA,EAGXiF,gBAAgBD,EAAKliB,GACjB,MAAMqiB,EAAUpmB,KAAK+lB,iBACf1jB,EAAIrC,KAAK4lB,IACRsB,EAASC,GAAUf,EACrBnjB,KAAI,CAACkB,EAAG5C,KACL,MAAM6lB,EAAM/kB,EAAE8B,GACd,MAAO,CAACnE,KAAK8mB,cAAc/iB,EAAGI,EAAG8hB,EAAKmB,GAAM7lB,MAE/C6B,MAAK,CAACikB,EAAIC,IAAOD,EAAG,GAAKC,EAAG,KAEjC,MAAO,CACH,iBAAoBJ,EAAQ,GAC5B,cAAiBA,EAAQ,GACzB,gBAAmBC,EAAO,GAC1B,aAAgBA,EAAO,IAQ/B1V,KAAK8S,EAAGgD,GACChD,IAAGA,EAAIvkB,KAAKwkB,IACZ+C,IAAiBA,EAAkBvnB,KAAKgmB,oBAAoBzB,IACjE,MAAM5L,EAAW3Y,KAAK6lB,UACtB,IAAIQ,GAAS,EACT9kB,EAAI,EACR,GACI8kB,EAASrmB,KAAKmlB,oBACRkB,KAAY9kB,EAAIoX,GAC1B,OAAO3Y,KAQXgmB,oBAAoBzB,GAChB,MAAMld,EAAIrH,KAAK0K,GACTrI,EAAIrC,KAAK4lB,GACT/E,EAAU/U,EAAS,EAAGzE,EAAI,GAC1BkB,EAAavI,KAAK8Q,YAClB3P,EAAIO,KAAK2G,IAAIhB,EAAG,GAAK3F,KAAK8lB,KAAK9lB,KAAKS,KAAKkF,KACzCogB,EAAK,IAAI1lB,MAAMZ,GAAGoJ,KAAK4E,KACvBiX,EAAU,GAEhB,IAAIsB,EAAMvY,IACNwY,EAAIpf,EAAWoD,OAAOkV,EAAS1f,GACnC,IAAK,IAAI4C,EAAI,EAAGA,EAAI5C,IAAK4C,EAAG,CACxB,MAAM6jB,EAAMD,EAAE5jB,GACRkiB,EAAM5jB,EAAEulB,GACd,IAAK,IAAIxnB,EAAI,EAAGA,EAAIe,IAAKf,EAAG,CACxB,GAAIA,IAAM2D,EAAG,SACb,MAAMwiB,EAAMlkB,EAAEslB,EAAEvnB,IAChBqnB,EAAG1jB,IAAM/D,KAAK8mB,cAAc/iB,EAAG3D,EAAG6lB,EAAKM,GAEvCkB,EAAG1jB,GAAK2jB,IACRA,EAAMD,EAAG1jB,GACTqiB,EAAQ7Z,KAAKqb,IAIrB,IAAK,IAAIrmB,EAAI,EAAGA,EAAIgjB,IAAKhjB,EAAG,CACxB,IAAIilB,EAAUrX,IACdwY,EAAIpf,EAAWoD,OAAOkV,EAAQ1F,QAAO3N,GAAS4Y,EAAQjV,WAAUtI,GAAKA,IAAM2E,IAAS,IAAIrM,GACxF,IAAK,IAAI4C,EAAI,EAAGA,EAAI5C,IAAK4C,EAAG,CACxB,IAAI6iB,EAAU,EACd,MAAMgB,EAAMD,EAAE5jB,GACRkiB,EAAM5jB,EAAEulB,GACd,IAAK,IAAIxnB,EAAI,EAAGA,EAAIe,IAAKf,EAAG,CACxB,GAAIA,IAAM2D,EAAG,SACb,MAAM8jB,EAAMF,EAAEvnB,GACRmmB,EAAMlkB,EAAEwlB,GACd,IAAIC,EAAQ9nB,KAAK8mB,cAAcc,EAAKC,EAAK5B,EAAKM,GAAO7kB,KAAK2G,OAAO+d,EAAQnjB,KAAIkB,GAAKnE,KAAK8mB,cAAce,EAAK1jB,EAAGoiB,MACzGuB,EAAQ,IACRlB,GAAoBkB,GAIxBlB,EAAUJ,IACVA,EAAUI,EACVR,EAAQ7Z,KAAKqb,IAGrBF,GAAOlB,EAEX,OAAOJ,EAAQ/iB,MAAM,EAAGkhB,ICjTzB,MAAMwD,EAeTvkB,YAAY0e,EAAQnM,EAASiS,EAAYxlB,EAASC,GAU9C,OATAzC,KAAKqiB,QAAUH,EACfliB,KAAKyX,SAAW1B,EAChB/V,KAAKioB,YAAcD,EACnBhoB,KAAK2O,QAAUnM,EAEfxC,KAAKkoB,cAAgB,GACrBloB,KAAKijB,UAAY,GACjBjjB,KAAKmoB,IAAM,IAAIpmB,MAAMmgB,EAAOvf,MAAM,IAAI4H,OACtCvK,KAAKyR,OACEzR,KAMXyR,OACI,MAAM2W,EAAepoB,KAAKkoB,cACpBhG,EAASliB,KAAKqiB,QACdhb,EAAI6a,EAAOvf,MAAM,GACjB0lB,EAAKroB,KAAKmoB,IACV1F,EAAWziB,KAAKijB,UACtB,IAAIqF,EAAgBtoB,KAAKuoB,eAAiB,EAE1C,IAAK,IAAIhnB,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB8mB,EAAG9mB,GAAK,CACJ,QAAW2gB,EAAOnf,IAAIxB,GACtB,MAASA,EACT,2BAAyB2K,EACzB,WAAa,GAGrB,IAAK,MAAMgD,KAAKmZ,EACZ,IAAInZ,EAAEsZ,YACNtZ,EAAE0D,UAAY5S,KAAKyoB,eAAevZ,GAClCA,EAAEsZ,WAAY,EACd/F,EAASlW,KAAK,CAAC2C,EAAE1B,QACjB8a,EAAgB7F,EAASrhB,OAAS,EAClCgnB,EAAa7b,KAAK2C,GACYhD,MAA1BlM,KAAK0oB,eAAexZ,IAAiB,CACrC,MAAMyZ,EAAQ,IAAInc,EAAK,MAAM3D,GAAKA,EAAE+f,uBAAuB,OAC3D5oB,KAAK6oB,QAAQ3Z,EAAGyZ,GAChB3oB,KAAK8oB,gBAAgBH,EAAOlG,EAAS6F,IAG7C,OAAOtoB,KASXyoB,eAAevZ,GACX,GAAI,cAAeA,EAAG,OAAOA,EAAE0D,UAC/B,MAAMyV,EAAKroB,KAAKmoB,IACV3lB,EAASxC,KAAK2O,QACdoH,EAAU/V,KAAKyX,SACf7E,EAAY,GAClB,IAAK,MAAMhD,KAAKyY,EACRzY,EAAEpC,OAAS0B,EAAE1B,OACbhL,EAAO0M,EAAExB,QAASkC,EAAElC,SAAWqI,GAC/BnD,EAAUrG,KAAKqD,GAGvB,OAAOgD,EASX8V,eAAexZ,GACX,MAAM8Y,EAAahoB,KAAKioB,YAClBzlB,EAASxC,KAAK2O,QACpB,KAAIO,EAAE0D,WAAa1D,EAAE0D,UAAUxR,QAAU4mB,GAGzC,OAAOxlB,EAAO0M,EAAExB,QAASwB,EAAE0D,UAAUoV,GAAYta,SASrDmb,QAAQ3Z,EAAGyZ,GACP,MAAMnmB,EAASxC,KAAK2O,QACdoa,EAAgB/oB,KAAK0oB,eAAexZ,GACpC0D,EAAY5S,KAAKyoB,eAAevZ,GACtC,IAAK,MAAMU,KAAKgD,EAAW,CACvB,GAAIhD,EAAE4Y,UAAW,SACjB,MAAMQ,EAA4BtnB,KAAK0I,IAAI2e,EAAevmB,EAAO0M,EAAExB,QAASkC,EAAElC,UAE1Eib,EAAMza,WAAWiD,WAAUtI,GAAKA,EAAE6E,SAAWkC,IAAK,GAClDA,EAAEgZ,sBAAwBI,EAC1BL,EAAMpc,KAAKqD,IAEPoZ,EAA4BpZ,EAAEgZ,wBAC9BhZ,EAAEgZ,sBAAwBI,EAC1BL,EAAQnc,EAAKI,QAAQ+b,EAAMtkB,QAAQwE,GAAKA,EAAE+f,uBAAuB,SAYjFE,gBAAgBH,EAAOM,GACnB,MAAMb,EAAepoB,KAAKkoB,cAC1B,MAAQS,EAAMO,OAAO,CACjB,MAAMtZ,EAAI+Y,EAAM5a,MAAML,QACtBkC,EAAEgD,UAAY5S,KAAKyoB,eAAe7Y,GAClCA,EAAE4Y,WAAY,EACdS,EAAQ1c,KAAKqD,EAAEpC,OACf4a,EAAa7b,KAAKqD,GACY1D,MAA1BlM,KAAK0oB,eAAe9Y,KACpB5P,KAAK6oB,QAAQjZ,EAAG+Y,GAChB3oB,KAAK8oB,gBAAgBH,EAAOM,KASxCzG,eACI,MAAMC,EAAW,GACX0G,EAAW,GACXnB,EAAahoB,KAAKioB,YACxB,IAAK,MAAMgB,KAAWjpB,KAAKijB,UACnBgG,EAAQ7nB,OAAS4mB,EACjBmB,EAAS5c,QAAQ0c,GAEjBxG,EAASlW,KAAK0c,GAItB,OADAxG,EAASlW,KAAK4c,GACP1G,EAMX2G,0BACI,MAAM/hB,EAAIrH,KAAKqiB,QAAQ1f,MAAM,GACvB2F,EAAS,IAAIvG,MAAMsF,GAAGkD,OACtBkY,EAAWziB,KAAKwiB,eACtB,IAAK,IAAIjhB,EAAI,EAAGJ,EAAIshB,EAASrhB,OAAQG,EAAIJ,IAAKI,EAAG,CAC7C,MAAM0nB,EAAUxG,EAASlhB,GACzB,IAAK,MAAMiM,KAASyb,EAChB3gB,EAAOkF,GAAUjM,EAAIJ,EAAI,EAAKI,GAAK,EAG3C,OAAO+G,GC/KR,MAAM+gB,UAAY7Y,EAcrBhN,YAAY+C,EAAGjE,EAAGgnB,EAAgBzgB,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAM1D,OALA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,IAAK,kBAC7BlR,KAAKgR,UAAU,IAAKtP,KAAK2G,IAAI/F,GAAKZ,KAAK0I,IAAI1I,KAAKwL,MAAMlN,KAAK0K,GAAK,IAAK,GAAI1K,KAAK0K,GAAK,IACnF1K,KAAKgR,UAAU,iBAAkBtP,KAAK2G,IAAIihB,GAAkB5nB,KAAK8lB,KAAK9lB,KAAKS,KAAKnC,KAAK0K,KAAM1K,KAAK0K,GAAK,IACrG1K,KAAK+Q,iBAAkB,EAChB/Q,KASXyR,KAAKjB,EAAGyB,EAAKsX,EAAc,GAAIC,EAAIrb,GAC/B,GAAInO,KAAK+Q,gBAAiB,OAAO/Q,KACjC,MAAMuG,EAAIvG,KAAKuG,EACTc,EAAIrH,KAAK0K,GACT6Z,EAAIvkB,KAAKgR,UAAU,KACnBnI,EAAI7I,KAAK6Q,GACTrO,EAASxC,KAAK2O,QACd8a,EAAKzpB,KAAKgR,UAAU,kBACpBsY,EAAiB,IAAI3D,EAASpf,EAAGkjB,EAAI,KAAMjnB,GAAQggB,eAAe4D,QAClEtgB,EAAI,IAAIvC,EAAOkmB,EAAIpiB,EAAG,SAC5BiiB,EAAenV,SAAQ,CAACuV,EAAKnoB,KACzBuE,EAAElB,UAAUrD,EAAGmoB,EAAK,MAExB,MAAMC,EAAM,IAAInZ,EAAGjN,EAAOP,KAAKsmB,EAAermB,KAAIymB,GAAOnjB,EAAExD,IAAI2mB,SAAWH,EAAe1gB,GAAGwI,YAEtFuY,EAAKrjB,EAAEgK,UACP+J,EAAM,IAAIkP,EAAII,EAAIpnB,GAClB2G,EAAI,IAAI5F,EAAO8D,EAAGA,EAAG,KACrB0B,GAAS,EAAEwb,EACjBqF,EAAGzV,SAAQ,CAACyG,EAAKrZ,KACb,IAAK,MAAO,MAASwC,KAAMuW,EAAI9K,OAAOoL,EAAK2J,GAAGsF,UACtCtoB,IAAMwC,GACVoF,EAAEvE,UAAUrD,EAAGwC,EAAGgF,MAG1B,MAAM1G,EAAI8G,EAAEjD,OAAOJ,EAAG,YAGhBjE,EADI,IAAI0B,EAAO8D,EAAGwB,EAAG,SACf3C,OAAOyjB,EAAK,YAKxB,OAHA3pB,KAAK4lB,GAAKvjB,EACVrC,KAAKyc,GAAK5a,EACV7B,KAAK+Q,iBAAkB,EAChB/Q,KAQXqR,YACIrR,KAAKsR,aACL,MAAMjP,EAAIrC,KAAK4lB,GACTkE,EAAKznB,EAAEqG,EACP7G,EAAI7B,KAAKyc,GACTsN,EAAMD,EAAGrkB,IAAIpD,GACb2nB,EAAMF,EAAGrkB,IAAI5D,GAEnB,OADA7B,KAAKuR,EAAIhO,EAAO8R,SAAS0U,EAAKC,EAAKhqB,KAAK8Q,aACjC9Q,KAAKgS,YCpFb,MAAMiY,UAAgBzZ,EAazBhN,YAAY+C,EAAGsC,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,M,QAKvC,OAJA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,G,EAyNH,CAACif,EAAGxiB,EAAG0N,KACxB,MAAM+U,EAAW,IAAID,EAAEE,eAAeC,UAChCC,EAAW,IAAI5iB,EAAE0iB,eAAeC,UAEhCE,EAASvqB,KAAKwqB,OAAOL,GACrBM,EAASzqB,KAAKwqB,OAAOF,GAErBI,EAAM1qB,KAAK2qB,aAAaJ,EAAQL,GAAG,GACnCU,EAAM5qB,KAAK2qB,aAAaF,EAAQ/iB,GAAG,GAEzC1H,KAAK6qB,sBAAsBV,EAAUO,EAAK,GAC1C1qB,KAAK6qB,sBAAsBP,EAAUM,EAAKxV,K,EArOG,6B,sBAAA,K,uDAAA,K,KAE7CvD,MAAMX,eAAiB,IACrBlR,KAAK0K,GAAI1K,KAAK4Q,IAAO5Q,KAAKuG,EAAE5D,MAC9B3C,KAAKgjB,iBAAmB,IAAIzf,EAAOvD,KAAK0K,GAAI1K,KAAK0K,GAAI,GAC9C1K,KAMX8qB,uBAAuBvpB,EAAGwC,EAAGvB,GACzB,MAAMI,EAAI5C,KAAKgjB,iBACTzc,EAAIvG,KAAKuG,EACTwkB,EAAOnoB,EAAE+B,MAAMpD,EAAGwC,GACxB,GAAa,IAATgnB,EAAY,CACZ,IAAI/gB,EAAOxH,EAAO+D,EAAExD,IAAIxB,GAAIgF,EAAExD,IAAIgB,IAGlC,OAFAnB,EAAEgC,UAAUrD,EAAGwC,EAAGiG,GAClBpH,EAAEgC,UAAUb,EAAGxC,EAAGyI,GACXA,EAEX,OAAO+gB,EASXC,4BAA4BxoB,EAASC,GACjC,MAAM4E,EAAIrH,KAAK0K,GACTnE,EAAI,IAAIvG,KAAKuG,GAEnB,IAAI0kB,EAAe,IAAIC,EAAY3kB,GACnC,MAAM4kB,EAAI,GACV,IAAIC,EAAI,GACR,IAAK,IAAI7pB,EAAI,EAAGA,EAAI8F,IAAK9F,EACrB,IAAK,IAAIwC,EAAIxC,EAAI,EAAGwC,EAAIsD,IAAKtD,EACzBqnB,EAAE7e,KAAK,CAAChL,EAAGwC,EAAG/D,KAAK8qB,uBAAuBvpB,EAAGwC,EAAGvB,KAGxD4oB,EAAIA,EAAEhoB,MAAK,CAACxB,EAAGC,IAAMD,EAAE,GAAKC,EAAE,KAE9B,IAAK,MAAOqoB,EAAGxiB,EAAG0N,KAAMgW,EAAG,CACvB,MAAMC,EAAQJ,EAAa/X,KAAK3M,EAAE2jB,IAC5BoB,EAAQL,EAAa/X,KAAK3M,EAAEmB,IAC9B2jB,IAAUC,IACVH,EAAE5e,KAAK,CAAC2d,EAAGxiB,EAAG0N,IACd6V,EAAaM,MAAMF,EAAOC,IAIlC,OAAOH,EAAE/nB,MAAK,CAACxB,EAAGC,IAAMD,EAAE,GAAKC,EAAE,KAMrC4P,OAII,OAHAzR,KAAKuR,EAAI,IAAIhO,EAAOvD,KAAK0K,GAAI1K,KAAK6Q,GAAI,GACtC7Q,KAAKwrB,MAAQxrB,KAAKgrB,4BAA4BhrB,KAAK2O,SACnD3O,KAAK+Q,iBAAkB,EAChB/Q,KAWXyrB,cAAcC,EAAIC,IAAMC,EAAIC,IAAMC,EAAIC,IAClC,OAASH,EAAKF,IAAOK,EAAKJ,IAAOE,EAAKF,IAAOG,EAAKJ,IAAO,EAU7DlB,OAAO7C,GACH,MAAMjZ,EAASiZ,EAAEvkB,MAAK,EAAE4oB,EAAIC,IAAMC,EAAIC,KAAQF,EAAKE,GAAMH,EAAKE,IACxD7kB,EAAIqH,EAAOtN,OACjB,GAAIiG,GAAK,EAAG,OAAOqH,EAEnB,MAAM0d,EAAQ,GACd,IAAK,IAAI7qB,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,KAAO6qB,EAAMhrB,QAAU,GAAKpB,KAAKyrB,aAAaW,EAAMA,EAAMhrB,OAAS,GAAIgrB,EAAMA,EAAMhrB,OAAQ,GAAIsN,EAAOnN,KAClG6qB,EAAMre,MAEVqe,EAAM7f,KAAKmC,EAAOnN,IAEtB,MAAM8qB,EAAQ,GACd,IAAK,IAAI9qB,EAAI8F,EAAI,EAAG9F,GAAK,IAAKA,EAAG,CAC7B,KAAO8qB,EAAMjrB,QAAU,GAAKpB,KAAKyrB,aAAaY,EAAMA,EAAMjrB,OAAS,GAAIirB,EAAMA,EAAMjrB,OAAQ,GAAIsN,EAAOnN,KAClG8qB,EAAMte,MAEVse,EAAM9f,KAAKmC,EAAOnN,IAItB,OAFA8qB,EAAMte,MACNqe,EAAMre,MACCqe,EAAMlmB,OAAOmmB,GAUxBC,aAAaC,EAAKC,IAAOC,EAAKC,IAC1B,MAAMvrB,EAAIsB,EAAU,CAAC8pB,EAAKC,GAAM,CAACC,EAAKC,IACtC,GAAU,IAANvrB,EAAS,MAAO,CAChB,IAAO,EACP,IAAO,GAEX,MAAMwrB,EAAM,EAAEF,EAAMF,GAAOprB,GAAIurB,EAAMF,GAAOrrB,GACtCyrB,EAAMD,EAAI,GAChB,IAAIE,EAAMnrB,KAAKS,KAAK,EAAKyqB,EAAMA,GAE/B,OADAC,EAAMF,EAAI,IAAM,GAAKE,EAAMA,EACpB,CACH,IAAOA,EACP,IAAOD,GAUfjC,aAAamC,EAAM5d,EAAG6d,GAClB,IACIC,EAcAC,EACAC,EAhBAxlB,GAAK,EAET,IAAK,IAAInG,EAAI,EAAGA,EAAIurB,EAAK1rB,SAAUG,EAAG,CAClC,MAAMsH,EAAIpG,EAAUqqB,EAAKvrB,GAAI2N,KAClB,IAAPxH,GAIIslB,EAAKnkB,KAHTmkB,EAAKnkB,EACLnB,EAAInG,GAWRwrB,GACAE,EAAKH,EAAKplB,GACVwlB,EAAKJ,GAAMplB,EAAI,GAAKolB,EAAK1rB,UAEhB,GAALsG,IAAQA,EAAIolB,EAAK1rB,OAAS,GAC9B6rB,EAAKH,EAAKplB,GACVwlB,EAAKJ,GAAMplB,EAAI,GAAKolB,EAAK1rB,SAG7B,MAAM+rB,EAAiB,CACnB,IAAOL,EAAKplB,GAAG,GACf,IAAOolB,EAAKplB,GAAG,IAGnB,GAAIolB,EAAK1rB,QAAU,EAAG,CAClB,MAAM,IAACyrB,EAAD,IAAMD,GAAO5sB,KAAKssB,YAAYW,EAAIC,GACxCC,EAAeN,IAAMA,EACrBM,EAAeP,IAAMA,OAErBO,EAAeN,IAAM,EACrBM,EAAeP,IAAM,EAGzB,OAAOO,EAQXC,aAAaC,EAAIC,IAAK,GAACC,EAAD,GAAKC,EAAL,IAASX,EAAT,IAAcD,IAChC,IAAI5qB,EAAIqrB,EAAKE,EACTtrB,EAAIqrB,EAAKE,EAGb,MAAO,CAFExrB,EAAI4qB,EAAM3qB,EAAI4qB,EACd7qB,EAAI6qB,EAAM5qB,EAAI2qB,GAW3B/B,sBAAsB/kB,EAAGrE,EAAGgsB,GACxB,MAAMpmB,EAAIvB,EAAE1E,OACZ,IAAK,IAAIG,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMuN,EAAIhJ,EAAEvE,IACLmsB,EAAIC,GAAM3tB,KAAKotB,YAAYte,EAAGrN,GACrCqN,EAAE,GAAK4e,EACP5e,EAAE,GAAK6e,EAAKF,GA2BpBpc,YACSrR,KAAK+Q,iBAAiB/Q,KAAKyR,OAChC,MAAMmc,EAAO5tB,KAAKwrB,MACZja,EAAI,IAAIvR,KAAKuR,GACbsc,EAAa,IAAI3C,EAAY3Z,EAAEtO,KAAI,CAAChB,EAAGV,KACzCU,EAAEV,EAAIA,EACCU,MAGX,IAAK,MAAOioB,EAAGxiB,EAAG0N,KAAMwY,EAAM,CAC1B,MAAME,EAAcD,EAAW3a,KAAK3B,EAAE2Y,IAChC6D,EAAcF,EAAW3a,KAAK3B,EAAE7J,IAClComB,IAAgBC,IACpB/tB,KAAKguB,mBAAmBF,EAAaC,EAAa3Y,GAClDyY,EAAWtC,MAAMuC,EAAaC,IAElC,OAAO/tB,KAAKgS,WAGL,aACFhS,KAAK+Q,iBAAiB/Q,KAAKyR,OAChC,MAAMmc,EAAO5tB,KAAKwrB,MACZja,EAAI,IAAIvR,KAAKuR,GACbsc,EAAa,IAAI3C,EAAY3Z,EAAEtO,KAAI,CAAChB,EAAGV,KACzCU,EAAEV,EAAIA,EACCU,MAGX,IAAK,MAAOioB,EAAGxiB,EAAG0N,KAAMwY,EAAM,CAC1B,MAAME,EAAcD,EAAW3a,KAAK3B,EAAE2Y,IAChC6D,EAAcF,EAAW3a,KAAK3B,EAAE7J,IAClComB,IAAgBC,IACpB/tB,KAAKguB,mBAAmBF,EAAaC,EAAa3Y,GAClDyY,EAAWtC,MAAMuC,EAAaC,SAOxB/tB,KAAKgS,YAEf,OAAOhS,KAAKgS,YAOpB,MAAMkZ,EACF1nB,YAAYiJ,EAAW,MAEnB,GADAzM,KAAKiuB,MAAQ,IAAIC,IACbzhB,EACA,IAAK,MAAM1G,KAAK0G,EACZzM,KAAKmuB,SAASpoB,GAGtB,OAAO/F,KAGXmuB,SAASnsB,GACL,MAAM0O,EAAO1Q,KAAKiuB,MAQlB,OAPKvd,EAAK0d,IAAIpsB,KACV0O,EAAKxI,IAAIlG,GACTA,EAAEooB,eAAiB,GACnBpoB,EAAEooB,eAAeiE,OAASrsB,EAC1BA,EAAEooB,eAAeC,SAAW,IAAI6D,IAAI,CAAClsB,IACrCA,EAAEooB,eAAetG,KAAO,GAErB9jB,KAGXkT,KAAKlR,GAED,OADahC,KAAKiuB,MACTG,IAAIpsB,GACLA,EAAEooB,eAAeiE,SAAWrsB,GAC5BA,EAAEooB,eAAeC,SAASniB,OAAOlG,GACjCA,EAAEooB,eAAeiE,OAASruB,KAAKkT,KAAKlR,EAAEooB,eAAeiE,QAC9CrsB,EAAEooB,eAAeiE,QAEjBrsB,EAGJ,KAIfupB,MAAMvpB,EAAGC,GACL,IAAIqsB,EAAStuB,KAAKkT,KAAKlR,GACnBusB,EAASvuB,KAAKkT,KAAKjR,GAEvB,OAAIqsB,IAAWC,IACXD,EAAOlE,eAAetG,KAAOyK,EAAOnE,eAAetG,QAAOwK,EAAQC,GAAU,CAACA,EAAQD,IAEzFC,EAAOnE,eAAeiE,OAASC,EAE/BC,EAAOnE,eAAeC,SAASlW,QAAQma,EAAOlE,eAAeC,SAASniB,IAAKomB,EAAOlE,eAAeC,UACjGiE,EAAOlE,eAAetG,MAAQyK,EAAOnE,eAAetG,MANtB9jB,MClV/B,MAAMwuB,UAAehe,EAaxBhN,YAAY+C,EAAGkoB,EAAW,EAAG5lB,EAAE,EAAGrG,EAAOC,EAAWwI,EAAK,MAKrD,OAJA4G,MAAMtL,EAAGsC,EAAGrG,EAAQyI,GACpB4G,MAAMX,eAAiB,CAAC,cACxBlR,KAAKgR,UAAU,aAAcyd,IAC3BzuB,KAAK0K,GAAI1K,KAAK4Q,IAAO5Q,KAAKuG,EAAE5D,MACvB3C,KAMXyR,KAAKjB,EAAG,SAAUke,EAAgB,MAC9B,MAAMrnB,EAAIrH,KAAK0K,GACT7B,EAAI7I,KAAK6Q,GAEf,GAAW,WAAPL,EAAiB,CACjB,MAAMjI,EAAavI,KAAK8Q,YACxB6d,QAAQzY,IAAI3N,GACZvI,KAAKuR,EAAI,IAAIhO,EAAO8D,EAAGwB,GAAG,IAAMN,EAAWI,cAE3C3I,KAAKuR,EAAIf,EAAGa,UAAUrR,KAAKuG,GAE/B,MAAMgL,EAAIvR,KAAKuR,EAEVmd,IACDA,EAAkB,IAAInrB,EAAO8D,EAAGA,IAGpC,MAAM7E,EAASxC,KAAK2O,QACpB,IAAIpM,EAAkB,IAAIgB,EAAO8D,EAAGA,GAChCunB,EAA0B,IAAIrrB,EAAO8D,EAAGA,GAC5C,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMstB,EAAMtd,EAAExO,IAAIxB,GAClB,IAAK,IAAIwC,EAAIxC,EAAGwC,EAAIsD,IAAKtD,EAAG,CACxB,IAAIb,EAAW3B,IAAMwC,EAAI,EAAIvB,EAAOqsB,EAAKtd,EAAExO,IAAIgB,IAC3C+qB,EAAmB,EAAI5rB,EAK3B,GAJAX,EAAgBqC,UAAUrD,EAAGwC,EAAGb,GAChCX,EAAgBqC,UAAUb,EAAGxC,EAAG2B,GAChC0rB,EAAwBhqB,UAAUrD,EAAGwC,EAAG+qB,GACxCF,EAAwBhqB,UAAUb,EAAGxC,EAAGutB,IACnCJ,EAAiB,CAClB,IAAIK,EAAWxtB,IAAMwC,EAAI,EAAIvB,EAAO+D,EAAExD,IAAIxB,GAAIgF,EAAExD,IAAIgB,IACpD2qB,EAAgB9pB,UAAUrD,EAAGwC,EAAGgrB,GAChCL,EAAgB9pB,UAAUb,EAAGxC,EAAGwtB,KAI5C,IAAIC,EAA0BN,EAAgB7mB,OAAO,GAAG,CAACgB,EAAGnB,IAAMA,EAAImB,IAClEif,EAAQ4G,EAAgBvmB,IAAI5F,GAC5B6oB,EAAItD,EAAMjgB,OAAO,GAAG,CAACgB,EAAGnB,IAAMhG,KAAKgR,IAAI7J,EAAGnB,KAAIM,KAAKgnB,GAUvD,OATAL,QAAQzY,IAAIkV,GACZprB,KAAKgjB,iBAAmBzgB,EACxBvC,KAAKivB,yBAA2BL,EAChC5uB,KAAKkvB,iBAAmBR,EACxB1uB,KAAKmvB,yBAA2BP,EAChC5uB,KAAKovB,OAAStH,EACd9nB,KAAKqvB,MAAQ,IAAI9rB,EAAO8D,EAAGwB,EAAG,GAC9B7I,KAAKsvB,GAAKlE,EAAE/pB,IAELrB,KAQXuvB,kBAAkBltB,GACd,MAAMG,EAASxC,KAAK2O,QACdtH,EAAIhF,EAAEM,MAAM,GACZC,EAAI,IAAIW,EAAO8D,EAAGA,GACxB,IAAK,IAAI9F,EAAI,EAAGA,EAAI8F,IAAK9F,EAAG,CACxB,MAAMqE,EAAMvD,EAAEU,IAAIxB,GAClB,IAAK,IAAIwC,EAAIxC,EAAGwC,EAAIsD,IAAKtD,EAAG,CACxB,IAAIb,EAAY3B,IAAMwC,EAAI,EAAIvB,EAAOoD,EAAKvD,EAAEU,IAAIgB,IAChDnB,EAAEgC,UAAUrD,EAAGwC,EAAGb,GAClBN,EAAEgC,UAAUb,EAAGxC,EAAG2B,IAG1B,OAAON,EAMXyO,UAAUsH,EAAS,IACV3Y,KAAK+Q,iBAAiB/Q,KAAKyR,OAEhC,IAAK,IAAI1N,EAAI,EAAGA,EAAI4U,IAAY5U,EAC5B4qB,QAAQzY,IAAI,IAAIlW,KAAKuR,IACrBvR,KAAKwvB,QAGT,OAAOxvB,KAAKgS,WAGL,aACFhS,KAAK+Q,iBAAiB/Q,KAAKyR,OAEhC,IAAK,IAAI1N,EAAI,EAAGA,EAAI4U,WAAY5U,EAC5B/D,KAAKwvB,cACCxvB,KAAKgS,WAGf,OAAOhS,KAAKgS,WAGhBwd,QACI,MAAMf,EAAazuB,KAAKgR,UAAU,cAElC,IAAIzO,EAAkBvC,KAAKgjB,iBACvB4L,EAA0B5uB,KAAKivB,yBAC/BP,EAAkB1uB,KAAKkvB,iBACvBF,EAA0BhvB,KAAKmvB,yBAC/BM,EAAOzvB,KAAKqvB,MACZjE,EAAIprB,KAAKsvB,GACT/d,EAAIvR,KAAKuR,EAETuW,EAAQ8G,EAAwBzmB,IAAI6mB,GACpCU,EAAY5H,EAAMriB,IAAIgqB,GACtB/Z,EAAIoS,EAAMriB,IAAI8L,GAAGpJ,IAAIoJ,EAAEvJ,KAAK0nB,IAC5BC,EAAQf,EAAwB/mB,OAAO,GAAG,CAACgB,EAAGnB,IAAMhG,KAAKgR,IAAI7J,EAAGnB,KAChEkoB,EAAKre,EAAE1J,OAAO,GAAG,CAACgB,EAAGnB,IAAMhG,KAAKgR,IAAI7J,EAAGnB,KACvCoL,EAAI6c,EAAMlqB,IAAImqB,GAAIznB,IAAIunB,GAAWvnB,IAAIoJ,EAAEvJ,KAAK,GAAGA,KAAK2nB,EAAMlqB,IAAI8L,KAAKrJ,IAAI0nB,EAAG5nB,KAAK2nB,EAAMlqB,IAAIgqB,KAC7F3c,EAAIA,EAAEjL,OAAO,MAAOgB,GAAMnH,KAAKC,IAAIkH,KACnC,IAAI/G,EAAI4T,EAAEzN,OAAO6K,GACb+c,EAAQte,EAAEtN,QAEd,IAAK,IAAIF,EAAI,EAAGA,EAAI0qB,IAChBld,EAAIse,EAAM3nB,IAAIpG,GACdS,EAAkBvC,KAAKuvB,kBAAkBhe,GACzCqd,EAA0BrsB,EAAgBsF,OAAO,GAAG,CAACgB,EAAGnB,IAAMA,EAAImB,IAClEif,EAAQ4G,EAAgBvmB,IAAI5F,KAChBulB,EAAMjgB,OAAO,GAAG,CAACgB,EAAGnB,IAAMhG,KAAKgR,IAAI7J,EAAGnB,KAAIM,KAAKgnB,GAAyB3tB,IACxE+pB,MANkBrnB,EAS1BjC,EAAIA,EAAEkG,KAAK,IAInBhI,KAAKuR,EAAIA,G,sBtC3JjBue,CAAyB,EAAG7uB,EAAqBhB,G","file":"druid.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"druid\"] = factory();\n\telse\n\t\troot[\"druid\"] = factory();\n})(this, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module doesn't tell about it's top-level declarations so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[934](0, __webpack_exports__, __webpack_require__);\n","/**\r\n * Numerical stable summation with the Neumair summation algorithm.\r\n * @memberof module:numerical\r\n * @alias neumair_sum\r\n * @param {Array} summands - Array of values to sum up.\r\n * @returns {number} The sum.\r\n * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements}\r\n */\r\nexport default function(summands) {\r\n    let n = summands.length\r\n    let sum = 0;\r\n    let compensation = 0;\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n        let summand = summands[i]\r\n        let t = sum + summand;\r\n        if (Math.abs(sum) >= Math.abs(summand)) {\r\n            compensation += (sum - t) + summand;\r\n        } else {\r\n            compensation += (summand - t) + sum;\r\n        }\r\n        sum = t;\r\n    }\r\n    return sum + compensation;\r\n}","import { neumair_sum } from \"../numerical/index\";\r\n/**\r\n * Computes the squared euclidean distance (l_2^2) between {@link a} and {@link b}.\r\n * @memberof module:metrics\r\n * @alias euclidean_squared\r\n * @param {Array<Number>} a \r\n * @param {Array<Number>} b \r\n * @returns {Number} the squared euclidean distance between {@link a} and {@link b}.  \r\n */\r\nexport default function(a, b) {\r\n    if (a.length != b.length) return undefined\r\n    let n = a.length\r\n    let s = new Array(n);\r\n    for (let i = 0; i < n; ++i) {\r\n        let x = a[i];\r\n        let y = b[i]\r\n        s[i] = ((x - y) * (x - y))\r\n    }\r\n    return neumair_sum(s);\r\n}","import { euclidean_squared } from \"../metrics/index.js\";\r\n/**\r\n * Computes the euclidean distance (l_2) between {@link a} and {@link b}.\r\n * @memberof module:metrics\r\n * @alias euclidean\r\n * @param {Array<Number>} a \r\n * @param {Array<Number>} b \r\n * @returns {Number} the euclidean distance between {@link a} and {@link b}.  \r\n */\r\nexport default function(a, b) {\r\n    return Math.sqrt(euclidean_squared(a, b));\r\n}","import { distance_matrix as dmatrix} from \"../matrix/index\";\r\nimport { euclidean } from '../metrics/index';\r\n\r\n/**\r\n * \r\n * @param {*} A \r\n * @param {*} k \r\n * @param {*} distance_matrix \r\n * @param {*} metric \r\n */\r\nexport default function(A, k, distance_matrix = null, metric = euclidean) {\r\n    const rows = A.shape[0];\r\n    let D = distance_matrix ?? dmatrix(A, metric)\r\n    /* for (let i = 0; i < n; ++i) {\r\n        D[i] = Array.from(D[i]).map((_,j) => {\r\n                return {\r\n                    i: i, j: j, distance: D[i][j]\r\n                }\r\n            })\r\n            .sort((a, b) => a.distance - b.distance)\r\n            .slice(1, k + 1)\r\n    } */\r\n    let nN = new Array(rows);\r\n    for (let row = 0; row < rows; ++row) {\r\n        nN[row] = Array.from(D.row(row)).map((distance, col) => {\r\n                return {\r\n                    \"i\": row,\r\n                    \"j\": col,\r\n                    \"distance\": distance,\r\n                }\r\n            })\r\n            .sort((a, b) => a.distance - b.distance)\r\n            .slice(1, k + 1);\r\n    }\r\n    return nN;\r\n} \r\n","import { neumair_sum } from \"../numerical/index\";\r\n\r\n/**\r\n * @class\r\n * @alias Matrix\r\n * @requires module:numerical/neumair_sum\r\n */\r\nexport class Matrix{\r\n    /**\r\n     * creates a new Matrix. Entries are stored in a Float64Array. \r\n     * @constructor\r\n     * @memberof module:matrix\r\n     * @alias Matrix\r\n     * @param {number} rows - The amount of rows of the matrix.\r\n     * @param {number} cols - The amount of columns of the matrix.\r\n     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or \"zeros\", \"identity\" or \"I\", or \"center\".\r\n     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.\r\n     *  - **string**: allowed are\r\n     *      - \"zero\", creates a zero matrix.\r\n     *      - \"identity\" or \"I\", creates an identity matrix.\r\n     *      - \"center\", creates an center matrix.\r\n     *  - **number**: create a matrix filled with the given value.\r\n     * @example\r\n     * \r\n     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.\r\n     * let B = new Matrix(3, 3, \"I\"); // creates a 3 times 3 identity matrix.\r\n     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.\r\n     */\r\n    constructor(rows=null, cols=null, value=null) {\r\n        this._rows = rows;\r\n        this._cols = cols;\r\n        this._data = null;\r\n        if (rows && cols) {\r\n            if (!value) {\r\n                this._data = new Float64Array(rows * cols);\r\n                return this;\r\n            }\r\n            if (typeof(value) === \"function\") {\r\n                this._data = new Float64Array(rows * cols);\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        this._data[row * cols + col] = value(row, col);\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n            if (typeof(value) === \"string\") {\r\n                if (value === \"zeros\") {\r\n                    return new Matrix(rows, cols, 0); \r\n                }\r\n                if (value === \"identity\" || value === \"I\") {\r\n                    this._data = new Float64Array(rows * cols);\r\n                    for (let row = 0; row < rows; ++row) {\r\n                        this._data[row * cols + row] = 1;\r\n                    }\r\n                    return this;\r\n                }\r\n                if (value === \"center\" && rows == cols) {\r\n                    this._data = new Float64Array(rows * cols);\r\n                    value = (i, j) => (i === j ? 1 : 0) - (1 / rows);\r\n                    for (let row = 0; row < rows; ++row) {\r\n                        for (let col = 0; col < cols; ++col) {\r\n                            this._data[row * cols + col] = value(row, col);\r\n                        }\r\n                    }\r\n                    return this;\r\n                }\r\n            }\r\n            if (typeof(value) === \"number\") {\r\n                this._data = new Float64Array(rows * cols);\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        this._data[row * cols + col] = value;\r\n                    }\r\n                }\r\n                return this;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a Matrix out of {@link A}.\r\n     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.\r\n     * @param {\"row\"|\"col\"|\"diag\"} [type = \"row\"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector. \r\n     * @returns {Matrix}\r\n     * \r\n     * @example\r\n     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.\r\n     * let S = Matrix.from([1, 2, 3], \"diag\"); // creates a three by three matrix with 1, 2, 3 on its diagonal.\r\n     */\r\n    static from(A, type=\"row\") {\r\n        if (A instanceof Matrix) {\r\n            return A.clone();\r\n        } else if (Array.isArray(A) || A instanceof Float64Array) {\r\n            let m = A.length\r\n            if (m === 0) throw \"Array is empty\";\r\n            // 1d\r\n            if (!Array.isArray(A[0]) && !(A[0] instanceof Float64Array)) {\r\n                if (type === \"row\") {  \r\n                    return new Matrix(1, m, (_, j) => A[j]);\r\n                } else if (type === \"col\") {\r\n                    return new Matrix(m, 1, (i) => A[i]);\r\n                } else if (type === \"diag\") {\r\n                    return new Matrix(m, m, (i, j) => (i == j) ? A[i] : 0);\r\n                } else {\r\n                    throw \"1d array has NaN entries\"\r\n                }\r\n            // 2d\r\n            } else if (Array.isArray(A[0]) || A[0] instanceof Float64Array) {\r\n                let n = A[0].length;\r\n                for (let row = 0; row < m; ++row) {\r\n                    if (A[row].length !== n) {\r\n                        throw \"various array lengths\";\r\n                    }\r\n                }\r\n                return new Matrix(m, n, (i, j) => A[i][j])\r\n            }\r\n        } else if (typeof(A) === \"number\") {\r\n            return new Matrix(1, 1, A);\r\n        } else {\r\n            throw \"error\"\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link row}th row from the Matrix.\r\n     * @param {int} row \r\n     * @returns {Array}\r\n     */\r\n    row(row) {\r\n        /* let result_row = new Array(this._cols);\r\n        for (let col = 0; col < this._cols; ++col) {\r\n            result_row[col] = this._data[row * this._cols + col];\r\n        }\r\n        return result_row; */\r\n        const data = this._data;\r\n        const cols = this._cols;\r\n        return data.subarray(row * cols, (row + 1) * cols)\r\n    }\r\n    \r\n    /**\r\n     * Returns an generator yielding each row of the Matrix.\r\n     */\r\n    *iterate_rows() {\r\n        const cols = this._cols;\r\n        const rows = this._rows;\r\n        const data = this._data;\r\n\r\n        for (let row = 0; row < rows; ++row) {\r\n            yield data.subarray(row * cols, (row + 1) * cols)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes a {@link Matrix} object an iterable object.\r\n     */\r\n    [Symbol.iterator] = this.iterate_rows;\r\n\r\n    /**\r\n     * Sets the entries of {@link row}th row from the Matrix to the entries from {@link values}.\r\n     * @param {int} row \r\n     * @param {Array} values \r\n     * @returns {Matrix}\r\n     */\r\n    set_row(row, values) {\r\n        let cols = this._cols;\r\n        if (Array.isArray(values) && values.length === cols) {\r\n            let offset = row * cols;\r\n            for (let col = 0; col < cols; ++col) {\r\n                this._data[offset + col] = values[col];\r\n            }\r\n        } else if (values instanceof Matrix && values.shape[1] === cols && values.shape[0] === 1) {\r\n            let offset = row * cols;\r\n            for (let col = 0; col < cols; ++col) {\r\n                this._data[offset + col] = values._data[col];\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link col}th column from the Matrix.\r\n     * @param {int} col \r\n     * @returns {Array}\r\n     */\r\n    col(col) {\r\n        let result_col = new Float64Array(this._rows);\r\n        for (let row = 0; row < this._rows; ++row) {\r\n            result_col[row] = this._data[row * this._cols + col];\r\n        }\r\n        return result_col;\r\n    }\r\n\r\n    /**\r\n     * Returns the {@link col}th entry from the {@link row}th row of the Matrix.\r\n     * @param {int} row \r\n     * @param {int} col \r\n     * @returns {float64}\r\n     */\r\n    entry(row, col) {\r\n        return this._data[row * this._cols + col];\r\n    }\r\n\r\n    /**\r\n     * Sets the {@link col}th entry from the {@link row}th row of the Matrix to the given {@link value}.\r\n     * @param {int} row \r\n     * @param {int} col \r\n     * @param {float64} value\r\n     * @returns {Matrix}\r\n     */\r\n    set_entry(row, col, value) {\r\n        this._data[row * this._cols + col] = value;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns a new transposed Matrix.\r\n     * @returns {Matrix}\r\n     */\r\n    transpose() {\r\n        let B = new Matrix(this._cols, this._rows, (row, col) => this.entry(col, row))\r\n        return B;\r\n    }\r\n\r\n    /**\r\n     * Returns a new transposed Matrix. Short-form of {@function transpose}.\r\n     * @returns {Matrix}\r\n     */\r\n    get T() {\r\n        return this.transpose();\r\n    }\r\n\r\n    /**\r\n     * Returns the inverse of the Matrix.\r\n     * @returns {Matrix}\r\n     */\r\n    inverse() {\r\n        const rows = this._rows;\r\n        const cols = this._cols;\r\n        let B = new Matrix(rows, 2 * cols, (i,j) => {\r\n            if (j >= cols) {\r\n                return (i === (j - cols)) ? 1 : 0;\r\n            } else {\r\n                return this.entry(i, j);\r\n            }\r\n        });\r\n        let h = 0; \r\n        let k = 0;\r\n        while (h < rows && k < cols) {\r\n            var i_max = 0;\r\n            let max_val = -Infinity;\r\n            for (let i = h; i < rows; ++i) {\r\n                let val = Math.abs(B.entry(i,k));\r\n                if (max_val < val) {\r\n                    i_max = i;\r\n                    max_val = val;\r\n                }\r\n            }\r\n            if (B.entry(i_max, k) == 0) {\r\n                k++;\r\n            } else {\r\n                // swap rows\r\n                for (let j = 0; j < 2 * cols; ++j) {\r\n                    let h_val = B.entry(h, j);\r\n                    let i_val = B.entry(i_max, j);\r\n                    B.set_entry(h, j, h_val);\r\n                    B.set_entry(i_max, j, i_val);\r\n                }\r\n                for (let i = h + 1; i < rows; ++i) {\r\n                    let f = B.entry(i, k) / B.entry(h, k);\r\n                    B.set_entry(i, k, 0)\r\n                    for (let j = k + 1; j < 2 * cols; ++j) {\r\n                        B.set_entry(i, j, B.entry(i, j) - B.entry(h, j) * f);\r\n                    }\r\n                }\r\n                h++;\r\n                k++;\r\n            }\r\n        }\r\n\r\n        for (let row = 0; row < rows; ++row) {\r\n            let f = B.entry(row, row);\r\n            for (let col = row; col < 2 * cols; ++col) {\r\n                B.set_entry(row, col, B.entry(row, col) / f)\r\n            }\r\n        }\r\n        \r\n        for (let row = rows - 1; row >= 0; --row) {\r\n            let B_row_row = B.entry(row, row);\r\n            for (let i = 0; i < row; i++) {\r\n                let B_i_row = B.entry(i, row);\r\n                let f = B_i_row / B_row_row;\r\n                for (let j = i; j < 2 * cols; ++j) {\r\n                    let B_i_j = B.entry(i,j);\r\n                    let B_row_j = B.entry(row, j);\r\n                    B_i_j = B_i_j - B_row_j * f;\r\n                    B.set_entry(i, j, B_i_j)\r\n                }\r\n            }\r\n        }\r\n\r\n        return new Matrix(rows, cols, (i,j) => B.entry(i, j + cols));\r\n    }\r\n\r\n    /**\r\n     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.\r\n     * @param {(Matrix|Array|Float64Array)} B the right side\r\n     * @returns {(Matrix|Array)}\r\n     */\r\n    dot(B) {\r\n        if (B instanceof Matrix) {\r\n            let A = this;\r\n            if (A.shape[1] !== B.shape[0]) {\r\n                throw `A.dot(B): A is a ${A.shape.join(\" x \")}-Matrix, B is a ${B.shape.join(\" x \")}-Matrix: \r\n                A has ${A.shape[1]} cols and B ${B.shape[0]} rows. \r\n                Must be equal!`;\r\n            }\r\n            let I = A.shape[1];\r\n            let C = new Matrix(A.shape[0], B.shape[1], (row, col) => {\r\n                const A_i = A.row(row);\r\n                const B_i = B.col(col);\r\n                let sum = 0;\r\n                for (let i = 0; i < I; ++i) {\r\n                    sum += A_i[i] * B_i[i];\r\n                }\r\n                return sum;\r\n            });\r\n            return C;\r\n        } else if (Array.isArray(B) || (B instanceof Float64Array)) {\r\n            let rows = this._rows;\r\n            if (B.length !== rows)  {\r\n                throw `A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`\r\n            }\r\n            let C = new Array(rows)\r\n            for (let row = 0; row < rows; ++row) {\r\n                C[row] = neumair_sum(this.row(row).map(e => e * B[row]));\r\n            }\r\n            return C;\r\n        } else {\r\n            throw `B must be Matrix or Array`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes the outer product from {@link this} and {@link B}.\r\n     * @param {Matrix} B \r\n     * @returns {Matrix}\r\n     */\r\n    outer(B) {\r\n        let A = this;\r\n        let l = A._data.length;\r\n        let r = B._data.length;\r\n        if (l != r) return undefined;\r\n        let C = new Matrix()\r\n        C.shape = [l, l, (i, j) => {\r\n            if (i <= j) {\r\n                return A._data[i] * B._data[j];\r\n            } else {\r\n                return C.entry(j, i);\r\n            }\r\n        }]\r\n        return C;\r\n    }\r\n\r\n    /**\r\n     * Appends matrix {@link B} to the matrix.\r\n     * @param {Matrix} B - matrix to append.\r\n     * @param {\"horizontal\"|\"vertical\"|\"diag\"} [type = \"horizontal\"] - type of concatenation.\r\n     * @returns {Matrix}\r\n     * @example\r\n     * \r\n     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.\r\n     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.\r\n     * \r\n     * A.concat(B, \"horizontal\"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]\r\n     * A.concat(B, \"vertical\"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]\r\n     * A.concat(B, \"diag\"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]\r\n     */\r\n    concat(B, type=\"horizontal\") {\r\n        const A = this;\r\n        const [rows_A, cols_A] = A.shape;\r\n        const [rows_B, cols_B] = B.shape;\r\n        if (type == \"horizontal\") {\r\n            if (rows_A != rows_B) throw `A.concat(B, \"horizontal\"): A and B need same number of rows, A has ${rows_A} rows, B has ${rows_B} rows.`;\r\n            const X = new Matrix(rows_A, cols_A + cols_B, \"zeros\");\r\n            X.set_block(0, 0, A);\r\n            X.set_block(0, cols_A, B);\r\n            return X;\r\n        } else if (type == \"vertical\") {\r\n            if (cols_A != cols_B) throw `A.concat(B, \"vertical\"): A and B need same number of columns, A has ${cols_A} columns, B has ${cols_B} columns.`;\r\n            const X = new Matrix(rows_A + rows_B, cols_A, \"zeros\");\r\n            X.set_block(0, 0, A);\r\n            X.set_block(rows_A, 0, B);\r\n            return X;\r\n        } else if (type == \"diag\") {\r\n            const X = new Matrix(rows_A + rows_B, cols_A + cols_B, \"zeros\");\r\n            X.set_block(0, 0, A);\r\n            X.set_block(rows_A, cols_A, B);\r\n            return X;\r\n        } else {\r\n            throw `type must be \"horizontal\" or \"vertical\", but type is ${type}!`;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.\r\n     * @param {int} offset_row \r\n     * @param {int} offset_col \r\n     * @param {Matrix} B \r\n     * @returns {Matrix}\r\n     */\r\n    set_block(offset_row, offset_col, B) {\r\n        let [ rows, cols ] = B.shape;\r\n        for (let row = 0; row < rows; ++row) {\r\n            if (row > this._rows) continue;\r\n            for (let col = 0; col < cols; ++col) {\r\n                if (col > this._cols) continue;\r\n                this.set_entry(row + offset_row, col + offset_col, B.entry(row, col));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Extracts the entries from the {@link start_row}th row to the {@link end_row}th row, the {@link start_col}th column to the {@link end_col}th column of the matrix.\r\n     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.\r\n     * @param {Number} start_row \r\n     * @param {Number} start_col\r\n     * @param {Number} [end_row = null]\r\n     * @param {Number} [end_col = null] \r\n     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.\r\n     * @example\r\n     * \r\n     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.\r\n     * \r\n     * A.get_block(1, 1).to2dArray; // [[5, 6], [8, 9]]\r\n     * A.get_block(0, 0, 1, 1).to2dArray; // [[1]]\r\n     * A.get_block(1, 1, 2, 2).to2dArray; // [[5]]\r\n     * A.get_block(0, 0, 2, 2).to2dArray; // [[1, 2], [4, 5]]\r\n     */\r\n    get_block(start_row, start_col, end_row = null, end_col = null) {\r\n        const [ rows, cols ] = this.shape;\r\n        /*if (!end_row)) {\r\n            end_row = rows;\r\n        }\r\n            end_col = cols;\r\n        }*/\r\n        end_row = end_row ?? rows;\r\n        end_col = end_col ?? cols;\r\n        if (end_row <= start_row || end_col <= start_col) {\r\n            throw `\r\n                end_row must be greater than start_row, and \r\n                end_col must be greater than start_col, but\r\n                end_row = ${end_row}, start_row = ${start_row}, end_col = ${end_col}, and start_col = ${start_col}!`;\r\n        }\r\n        const X = new Matrix(end_row - start_row, end_col - start_col, \"zeros\");\r\n        for (let row = start_row, new_row = 0; row < end_row; ++row, ++new_row) {\r\n            for (let col = start_col, new_col = 0; col < end_col; ++col, ++new_col) {\r\n                X.set_entry(new_row, new_col, this.entry(row, col));\r\n            }\r\n        }\r\n        return X;\r\n        //return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));\r\n    }\r\n\r\n    /**\r\n     * Returns a new array gathering entries defined by the indices given by argument.\r\n     * @param {Array<Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix \r\n     * @param {Array<Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix \r\n     * @returns {Matrix}\r\n     */\r\n    gather(row_indices, col_indices) {\r\n        const N = row_indices.length;\r\n        const D = col_indices.length;\r\n        \r\n        const R = new Matrix(N, D);\r\n        for (let i = 0; i < N; ++i) {\r\n            const row_index = row_indices[i];\r\n            for (let j = 0; j < N; ++j) {\r\n                const col_index = col_indices[j];\r\n                R.set_entry(i, j, this.entry(row_index, col_index))\r\n            }\r\n        }\r\n\r\n        return R;\r\n    }\r\n\r\n    /**\r\n     * Applies a function to each entry of the matrix.\r\n     * @param {function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.\r\n     * @param {function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.\r\n     */\r\n    _apply_array(f, v) {\r\n        const data = this._data;\r\n        const [ rows, cols ] = this.shape;\r\n        for (let row = 0; row < rows; ++row) {\r\n            const offset = row * cols;\r\n            for (let col = 0; col < cols; ++col) {\r\n                const i = offset + col;\r\n                data[i] = f(data[i], v(row, col));\r\n            }\r\n        }\r\n        return this; \r\n    }\r\n\r\n    _apply_rowwise_array(values, f) {\r\n        return this._apply_array(f, (_, j) => values[j]);\r\n    }\r\n\r\n    _apply_colwise_array(values, f) {\r\n        const data = this._data;\r\n        const [ rows, cols ] = this.shape;\r\n        for (let row = 0; row < rows; ++row) {\r\n            const offset = row * cols;\r\n            for (let col = 0; col < cols; ++col) {\r\n                const i = offset + col;\r\n                data[i] = f(data[i], values[row]);\r\n            }\r\n        }\r\n        return this; \r\n    }\r\n\r\n    _apply(value, f) {\r\n        let data = this._data;\r\n        if (value instanceof Matrix) {\r\n            let [ value_rows, value_cols ] = value.shape;\r\n            let [ rows, cols ] = this.shape;\r\n            if (value_rows === 1) {\r\n                if (cols !== value_cols) {\r\n                    throw `cols !== value_cols`;\r\n                }\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        data[row * cols + col] = f(data[row * cols + col], value.entry(0, col))\r\n                    }\r\n                }\r\n            } else if (value_cols === 1) {\r\n                if (rows !== value_rows) {\r\n                    throw `rows !== value_rows`;\r\n                }\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        data[row * cols + col] = f(data[row * cols + col], value.entry(row, 0))\r\n                    }\r\n                }\r\n            } else if (rows == value_rows && cols == value_cols) {\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        data[row * cols + col] = f(data[row * cols + col], value.entry(row, col))\r\n                    }\r\n                }\r\n            } else {\r\n                throw `error`;\r\n            }\r\n        } else if (Array.isArray(value)) {\r\n            let rows = this._rows;\r\n            let cols = this._cols;\r\n            if (value.length === rows) {\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        data[row * cols + col] = f(data[row * cols + col], value[row]);\r\n                    }\r\n                }\r\n            } else if (value.length === cols) {\r\n                for (let row = 0; row < rows; ++row) {\r\n                    for (let col = 0; col < cols; ++col) {\r\n                        data[row * cols + col] = f(data[row * cols + col], value[col]);\r\n                    }\r\n                }\r\n            } else {\r\n                throw `error`;\r\n            }\r\n        } else {\r\n            for (let i = 0, n = this._rows * this._cols; i < n; ++i) {\r\n                data[i] = f(data[i], value);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Clones the Matrix.\r\n     * @returns {Matrix}\r\n     */\r\n    clone() {\r\n        let B = new Matrix()\r\n        B._rows = this._rows;\r\n        B._cols = this._cols;\r\n        B._data = this._data.slice(0);\r\n        return B;\r\n    }\r\n\r\n    mult(value) {\r\n        return this.clone()._apply(value, (a,b) => a * b);\r\n    }\r\n\r\n    divide(value) {\r\n        return this.clone()._apply(value, (a,b) => a / b);\r\n    }\r\n\r\n    add(value) {\r\n        return this.clone()._apply(value, (a,b) => a + b);\r\n    }\r\n\r\n    sub(value) {\r\n        return this.clone()._apply(value, (a,b) => a - b);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of rows and columns of the Matrix.\r\n     * @returns {Array} An Array in the form [rows, columns].\r\n     */\r\n    get shape() {\r\n        return [this._rows, this._cols];\r\n    }\r\n\r\n    /**\r\n     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.\r\n     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.\r\n     * @returns {Matrix}\r\n     */\r\n    set shape([rows, cols, value = () => 0]) {\r\n        this._rows = rows;\r\n        this._cols = cols;\r\n        this._data = new Float64Array(rows * cols);\r\n        for (let row = 0; row < rows; ++row) {\r\n            for (let col = 0; col < cols; ++col) {\r\n                this._data[row * cols + col] = value(row, col);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns the Matrix as a two-dimensional Array.\r\n     * @returns {Array}\r\n     */\r\n    get to2dArray() {\r\n        /* const rows = this._rows;\r\n        const cols = this._cols;\r\n        let result = new Array(rows)\r\n        for (let row = 0; row < rows; ++row) {\r\n            let result_col = new Array(cols)\r\n            for (let col = 0; col < cols; ++col) {\r\n                result_col[col] = this.entry(row, col);\r\n            }\r\n            result[row] = result_col;\r\n        }\r\n        return result; */\r\n        return [...this.iterate_rows()]\r\n    }\r\n\r\n    /**\r\n     * Returns the diagonal of the Matrix.\r\n     * @returns {Array}\r\n     */\r\n    get diag() {\r\n        const rows = this._rows;\r\n        const cols = this._cols;\r\n        const min_row_col = Math.min(rows, cols);\r\n        let result = new Float64Array(min_row_col)\r\n        for (let i = 0; i < min_row_col; ++i) {\r\n            result[i] = this.entry(i,i);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns the mean of all entries of the Matrix.\r\n     * @returns {float64}\r\n     */\r\n    get mean() {\r\n        const sum = this.sum;\r\n        const n = this._rows * this._cols;\r\n        return sum / n;\r\n    }\r\n\r\n    /**\r\n     * Returns the sum oof all entries of the Matrix.\r\n     * @returns {number}\r\n     */\r\n    get sum() {\r\n        const data = this._data;\r\n        return neumair_sum(data);\r\n    }\r\n\r\n    /**\r\n     * Returns the mean of each row of the matrix.\r\n     * @returns {Array}\r\n     */\r\n    get meanRows() {\r\n        const data = this._data;\r\n        const rows = this._rows;\r\n        const cols = this._cols;\r\n        let result = [];\r\n        for (let row = 0; row < rows; ++row) {\r\n            result[row] = 0;\r\n            for (let col = 0; col < cols; ++col) {\r\n                result[row] += data[row * cols + col];\r\n            }\r\n            result[row] /= cols;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /** Returns the mean of each column of the matrix.\r\n     * @returns {Array}\r\n     */\r\n    get meanCols() {\r\n        const data = this._data;\r\n        const rows = this._rows;\r\n        const cols = this._cols;\r\n        let result = [];\r\n        for (let col = 0; col < cols; ++col) {\r\n            result[col] = 0;\r\n            for (let row = 0; row < rows; ++row) {\r\n                result[col] += data[row * cols + col];\r\n            }\r\n            result[col] /= rows;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    static solve_CG(A, b, randomizer, tol=1e-3) {\r\n        const rows = A.shape[0];\r\n        const cols = b.shape[1];\r\n        let result = new Matrix(rows, 0);\r\n        for (let i = 0; i < cols; ++i) {\r\n            const b_i = Matrix.from(b.col(i)).T;\r\n            let x = new Matrix(rows, 1, () => randomizer.random);\r\n            let r = b_i.sub(A.dot(x));\r\n            let d = r.clone();\r\n            do {\r\n                const z = A.dot(d);\r\n                const alpha = r.T.dot(r).entry(0, 0) / d.T.dot(z).entry(0, 0);\r\n                x = x.add(d.mult(alpha));\r\n                const r_next = r.sub(z.mult(alpha));\r\n                const beta = r_next.T.dot(r_next).entry(0, 0) / r.T.dot(r).entry(0, 0);\r\n                d = r_next.add(d.mult(beta));\r\n                r = r_next;\r\n            } while (Math.abs(r.mean) > tol);\r\n            result = result.concat(x, \"horizontal\");\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Solves the equation {@link A}x = {@link b}. Returns the result x.\r\n     * @param {Matrix} A - Matrix or LU Decomposition\r\n     * @param {Matrix} b - Matrix\r\n     * @returns {Matrix}\r\n     */\r\n    static solve(A, b) {\r\n        let { L: L, U: U } = (\"L\" in A && \"U\" in A) ? A : Matrix.LU(A);\r\n        let rows = L.shape[0];\r\n        let x = b.clone();\r\n        \r\n        // forward\r\n        for (let row = 0; row < rows; ++row) {\r\n            for (let col = 0; col < row - 1; ++col) {\r\n                x.set_entry(0, row, x.entry(0, row) - L.entry(row, col) * x.entry(1, col));\r\n            }\r\n            x.set_entry(0, row, x.entry(0, row) / L.entry(row, row));\r\n        }\r\n        \r\n        // backward\r\n        for (let row = rows - 1; row >= 0; --row) {\r\n            for (let col = rows - 1; col > row; --col) {\r\n                x.set_entry(0, row, x.entry(0, row) - U.entry(row, col) * x.entry(0, col));\r\n            }\r\n            x.set_entry(0, row, x.entry(0, row) / U.entry(row, row));\r\n        }\r\n\r\n        return x;\r\n    }\r\n\r\n    /**\r\n     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.\r\n     * @param {Matrix} A \r\n     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.\r\n     */\r\n    static LU(A) {\r\n        const rows = A.shape[0];\r\n        const L = new Matrix(rows, rows, \"zeros\");\r\n        const U = new Matrix(rows, rows, \"identity\");\r\n        \r\n        for (let j = 0; j < rows; ++j) {\r\n            for (let i = j; i < rows; ++i) {\r\n                let sum = 0;\r\n                for (let k = 0; k < j; ++k) {\r\n                    sum += L.entry(i, k) * U.entry(k, j);\r\n                }\r\n                L.set_entry(i, j, A.entry(i, j) - sum);\r\n            }\r\n            for (let i = j; i < rows; ++i) {\r\n                if (L.entry(j, j) === 0) {\r\n                    return undefined;\r\n                }\r\n                let sum = 0;\r\n                for (let k = 0; k < j; ++k) {\r\n                    sum += L.entry(j, k) * U.entry(k, i);\r\n                }\r\n                U.set_entry(j, i, (A.entry(j, i) - sum) / L.entry(j, j));\r\n            }\r\n        }\r\n\r\n        return { L: L, U: U };\r\n    }\r\n\r\n    /**\r\n     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}\r\n     * @param {Matrix} M \r\n     * @param {int} [k=2] \r\n     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}\r\n     */\r\n    static SVD(M, k=2) {\r\n        const MT = M.T;\r\n        let MtM = MT.dot(M);\r\n        let MMt = M.dot(MT);\r\n        let { eigenvectors: V, eigenvalues: Sigma } = simultaneous_poweriteration(MtM, k);\r\n        let { eigenvectors: U } = simultaneous_poweriteration(MMt, k);\r\n        return { U: U, Sigma: Sigma.map(sigma => Math.sqrt(sigma)), V: V };\r\n        \r\n        //Algorithm 1a: Householder reduction to bidiagonal form:\r\n        /* const [m, n] = A.shape;\r\n        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);\r\n        console.log(U.to2dArray)\r\n        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);\r\n        console.log(V.to2dArray)\r\n        let B = Matrix.bidiagonal(A.clone(), U, V);\r\n        console.log(U,V,B)\r\n        return { U: U, \"Sigma\": B, V: V }; */\r\n    }\r\n}","import { euclidean } from \"../metrics/index\"\r\nimport { Matrix } from \"./Matrix\";\r\n\r\nexport default function(A, metric = euclidean) {\r\n    let n = A.shape[0];\r\n    /* let D = new Array(n);\r\n    for (let i = 0; i < n; ++i) {\r\n        D[i] = new Float64Array(n);\r\n    }\r\n    for (let i = 0; i < n; ++i) {\r\n        for (let j = i + 1; j < n; ++j) {\r\n            D[i][j] = D[j][i] = metric(A[i], A[j]);\r\n        }\r\n    } */\r\n    const D = new Matrix(n, n);\r\n    for (let i = 0; i < n; ++i) {\r\n        const A_i = A.row(i);\r\n        for (let j = i + 1; j < n; ++j) {\r\n            const dist = metric(A_i, A.row(j));\r\n            D.set_entry(i, j, dist);\r\n            D.set_entry(j, i, dist);\r\n        }\r\n    }\r\n    return D;\r\n}\r\n","export default function(start, end, number = null) {\r\n    if (!number) {\r\n        number = Math.max(Math.round(end - start) + 1, 1);\r\n    }\r\n    if (number < 2) {\r\n        return number === 1 ? [start] : [];\r\n    }\r\n    let result = new Array(number)\r\n    number -= 1\r\n    for (let i = number; i >= 0; --i) {\r\n        result[i] = (i * end + (number - i) * start) / number;\r\n    }\r\n    return result\r\n}","import { euclidean } from \"../metrics/index\";\r\nimport { Matrix } from \"../matrix/index\";\r\n//import { neumair_sum } from \"../numerical/index\";\r\n\r\nexport default function(v, metric = euclidean) {\r\n//export default function(vector, p=2, metric = euclidean) {\r\n    let vector = null;\r\n    if (v instanceof Matrix) {\r\n        let [rows, cols] = v.shape;\r\n        if (rows === 1) vector = v.row(0);\r\n        else if (cols === 1) vector = v.col(0);\r\n        else throw \"matrix must be 1d!\"\r\n    } else {\r\n        vector = v;\r\n    }\r\n    let n = vector.length;\r\n    let z = new Array(n)\r\n    z.fill(0);\r\n    return metric(vector, z);\r\n    \r\n    \r\n    /*let v;\r\n    if (vector instanceof Matrix) {\r\n        let [ rows, cols ] = v.shape;\r\n        if (rows === 1) {\r\n            v = vector.row(0);\r\n        } else if (cols === 1) {\r\n            v = vector.col(0);\r\n        } else {\r\n            throw \"matrix must be 1d\"\r\n        }\r\n    } else {\r\n        v = vector;\r\n    }\r\n    return Math.pow(neumair_sum(v.map(e => Math.pow(e, p))), 1 / p)*/\r\n}","import { linspace, Matrix } from \"../matrix/index\";\r\n\r\nexport class Randomizer {\r\n    // https://github.com/bmurray7/mersenne-twister-examples/blob/master/javascript-mersenne-twister.js\r\n    /**\r\n     * Mersenne Twister\r\n     * @param {*} _seed \r\n     */\r\n    constructor(_seed) {\r\n        this._N = 624;\r\n        this._M = 397;\r\n        this._MATRIX_A = 0x9908b0df;\r\n        this._UPPER_MASK = 0x80000000;\r\n        this._LOWER_MASK = 0x7fffffff;\r\n        this._mt = new Array(this._N);\r\n        this._mti = this.N + 1;\r\n\r\n        this.seed = _seed || new Date().getTime();\r\n        return this;\r\n    }\r\n\r\n    set seed(_seed) {\r\n        this._seed = _seed;\r\n        let mt = this._mt;\r\n\r\n        mt[0] = _seed >>> 0;\r\n        for (this._mti = 1; this._mti < this._N; this._mti += 1) {\r\n            let mti = this._mti;\r\n            let s = mt[mti - 1] ^ (mt[mti - 1] >>> 30);\r\n            mt[mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253) + mti;\r\n            mt[mti] >>>= 0;\r\n        }\r\n    }\r\n\r\n    get seed() {\r\n        return this._seed;\r\n    }\r\n\r\n    get random() {\r\n        return this.random_int * (1.0 / 4294967296.0)\r\n    }\r\n\r\n    get random_int() {\r\n        let y, mag01 = new Array(0x0, this._MATRIX_A);\r\n        if (this._mti >= this._N) {\r\n            let kk;\r\n\r\n            if (this._mti == this._N + 1) {\r\n                this.seed = 5489;\r\n            }\r\n\r\n            let N_M = this._N - this._M;\r\n            let M_N = this._M - this._N;\r\n\r\n            for (kk = 0; kk < N_M; ++kk) {\r\n                y = (this._mt[kk] & this._UPPER_MASK) | (this._mt[kk + 1] & this._LOWER_MASK);\r\n                this._mt[kk] = this._mt[kk + this._M] ^ (y >>> 1) ^ mag01[y & 0x1];\r\n            }\r\n            for (; kk < this._N - 1; ++kk) {\r\n                y = (this._mt[kk] & this._UPPER_MASK) | (this._mt[kk + 1] & this._LOWER_MASK);\r\n                this._mt[kk] = this._mt[kk + M_N] ^ (y >>> 1) ^ mag01[y & 0x1];\r\n            }\r\n\r\n            y = (this._mt[this._N - 1] & this._UPPER_MASK) | (this._mt[0] & this._LOWER_MASK);\r\n            this._mt[this._N - 1] = this._mt[this._M - 1] ^ (y >>> 1) ^ mag01[y & 0x1];\r\n\r\n            this._mti = 0;\r\n        }\r\n\r\n        y = this._mt[this._mti += 1];\r\n        y ^= (y >>> 11);\r\n        y ^= (y << 7) & 0x9d2c5680;\r\n        y ^= (y << 15) & 0xefc60000;\r\n        y ^= (y >>> 18);\r\n\r\n        return y >>> 0;\r\n    }\r\n\r\n    choice(A, n) {\r\n        if (A instanceof Matrix) {\r\n            let [rows, cols] = A.shape;\r\n            if (n > rows) throw \"n bigger than A!\";\r\n            let sample = new Array(n);\r\n            let index_list = linspace(0, rows - 1);\r\n            for (let i = 0, l = index_list.length; i < n; ++i, --l) {\r\n                let random_index = this.random_int % l;\r\n                sample[i] = index_list.splice(random_index, 1)[0]\r\n            }\r\n            return sample.map(d => A.row(d));\r\n        } else if (Array.isArray(A) || A instanceof Float64Array) {\r\n            let rows = A.length;\r\n            if (n > rows) {\r\n                throw \"n bigger than A!\";\r\n            }\r\n            let sample = new Array(n);\r\n            let index_list = linspace(0, rows - 1);\r\n            for (let i = 0, l = index_list.length; i < n; ++i, --l) {\r\n                let random_index = this.random_int % l;\r\n                sample[i] = index_list.splice(random_index, 1)[0];\r\n            }\r\n            return sample.map(d => A[d]);\r\n        }\r\n    }\r\n\r\n    static choice(A, n, seed=19870307) {\r\n        let [rows, cols] = A.shape;\r\n        if (n > rows) throw \"n bigger than A!\"\r\n        let rand = new Randomizer(seed);\r\n        let sample = new Array(n);\r\n        let index_list = linspace(0, rows - 1);\r\n        /*let index_list = new Array(rows);\r\n        for (let i = 0; i < rows; ++i) {\r\n            index_list[i] = i;\r\n        }*/\r\n        //let result = new Matrix(n, cols);\r\n        for (let i = 0, l = index_list.length; i < n; ++i, --l) {\r\n            let random_index = rand.random_int % l;\r\n            sample[i] = index_list.splice(random_index, 1)[0]\r\n            //random_index = index_list.splice(random_index, 1)[0];\r\n            //result.set_row(i, A.row(random_index))\r\n        }\r\n        //return result;\r\n        //return new Matrix(n, cols, (row, col) => A.entry(sample[row], col))\r\n        return sample.map(d => A.row(d));\r\n    }\r\n}","export function max(values) {\r\n  let max;\r\n  for (const value of values) {\r\n    if (value != null\r\n        && (max < value || (max === undefined && value >= value))) {\r\n      max = value;\r\n    }\r\n  }\r\n  return max;\r\n}\r\n","/**\r\n * Numerical stable summation with the Kahan summation algorithm.\r\n * @memberof module:numerical\r\n * @alias kahan_sum\r\n * @param {Array} summands - Array of values to sum up.\r\n * @returns {number} The sum.\r\n * @see {@link https://en.wikipedia.org/wiki/Kahan_summation_algorithm}\r\n */\r\nexport default function(summands) {\r\n    let n = summands.length\r\n    let sum = 0;\r\n    let compensation = 0;\r\n    let y, t;\r\n\r\n    for (let i = 0; i < n; ++i) {\r\n        y = summands[i] - compensation;\r\n        t = sum + y;\r\n        compensation = (t - sum) - y;\r\n        sum = t;\r\n    }\r\n    return sum;\r\n}","/**\r\n * Computes the cosine distance (not similarity) between {@link a} and {@link b}.\r\n * @memberof module:metrics\r\n * @alias cosine\r\n * @param {Array<Number>} a \r\n * @param {Array<Number>} b \r\n * @example\r\n * druid.cosine([1,0],[1,1]) == 0.7853981633974484 == /4\r\n * @returns {Number} The cosine distance between {@link a} and {@link b}.\r\n */\r\nexport default function(a, b) {\r\n    if (a.length !== b.length) return undefined;\r\n    let n = a.length;\r\n    let sum = 0;\r\n    let sum_a = 0;\r\n    let sum_b = 0;\r\n    for (let i = 0; i < n; ++i) {\r\n        sum += (a[i] * b[i])\r\n        sum_a += (a[i] * a[i])\r\n        sum_b += (b[i] * b[i])\r\n    }\r\n    return Math.acos(sum / ((Math.sqrt(sum_a) * Math.sqrt(sum_b))));\r\n}","/**\r\n * Computes the manhattan distance (l_1) between {@link a} and {@link b}.\r\n * @memberof module:metrics\r\n * @alias manhattan\r\n * @param {Array<Number>} a \r\n * @param {Array<Number>} b \r\n * @returns {Number} the manhattan distance between {@link a} and {@link b}.  \r\n */export default function(a, b) {\r\n    if (a.length != b.length) return undefined\r\n    let n = a.length\r\n    let sum = 0;\r\n    for (let i = 0; i < n; ++i) {\r\n        sum += Math.abs(a[i] - b[i])\r\n    }\r\n    return sum\r\n}","/**\r\n * Computes the chebyshev distance (l_) between {@link a} and {@link b}.\r\n * @memberof module:metrics\r\n * @alias chebyshev\r\n * @param {Array<Number>} a \r\n * @param {Array<Number>} b \r\n * @returns {Number} the chebyshev distance between {@link a} and {@link b}.  \r\n */\r\nexport default function(a, b) {\r\n    if (a.length != b.length) return undefined\r\n    let n = a.length\r\n    let res = [];\r\n    for (let i = 0; i < n; ++i) {\r\n        res.push(Math.abs(a[i] - b[i]))\r\n    }\r\n    return Math.max(...res)\r\n}","/**\r\n * Computes the canberra distance between {@link a} and {@link b}.\r\n * @memberof module:metrics\r\n * @alias canberra\r\n * @param {Array<Number>} a \r\n * @param {Array<Number>} b \r\n * @returns {Number} The canberra distance between {@link a} and {@link b}.\r\n * @see {@link https://en.wikipedia.org/wiki/Canberra_distance}\r\n */\r\nexport default function(a, b) {\r\n    if (a.length !== b.length) return undefined;\r\n    let n = a.length;\r\n    let sum = 0;\r\n    for (let i = 0; i < n; ++i) {\r\n        sum += (Math.abs(a[i] - b[i]) / (Math.abs(a[i]) + Math.abs(b[i])))\r\n    }\r\n    return sum;\r\n}","/**\r\n * @class\r\n * @alias Heap\r\n */\r\nexport class Heap {\r\n    /**\r\n     * A heap is a datastructure holding its elements in a specific way, so that the top element would be the first entry of an ordered list.\r\n     * @constructor\r\n     * @memberof module:datastructure\r\n     * @alias Heap\r\n     * @param {Array=} elements - Contains the elements for the Heap. {@link elements} can be null.\r\n     * @param {Function} [accessor = (d) => d] - Function returns the value of the element.\r\n     * @param {(\"min\"|\"max\"|Function)} [comparator = \"min\"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. (\"min\" for a Min-Heap, \"max\" for a Max_heap)\r\n     * @returns {Heap}\r\n     * @see {@link https://en.wikipedia.org/wiki/Binary_heap}\r\n     */\r\n    constructor(elements = null, accessor = d => d, comparator = \"min\") {\r\n        if (elements) {\r\n            return Heap.heapify(elements, accessor, comparator);\r\n        } else {\r\n            this._accessor = accessor;\r\n            this._container = [];\r\n            if (comparator == \"min\") {\r\n                this._comparator = (a, b) => a < b;\r\n            } else if (comparator == \"max\") {\r\n                this._comparator = (a, b) => a > b;\r\n            } else {\r\n                this._comparator = comparator;\r\n            }\r\n            return this\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a Heap from an Array\r\n     * @param {Array|Set} elements - Contains the elements for the Heap.\r\n     * @param {Function=} [accessor = (d) => d] - Function returns the value of the element.\r\n     * @param {(String=|Function)} [comparator = \"min\"] - Function returning true or false defining the wished order of the Heap, or String for predefined function. (\"min\" for a Min-Heap, \"max\" for a Max_heap)\r\n     * @returns {Heap}\r\n     */\r\n    static heapify(elements, accessor = d => d, comparator = \"min\") {\r\n        const heap = new Heap(null, accessor, comparator);\r\n        const container = heap._container;\r\n        for (const e of elements) {\r\n            container.push({\r\n                \"element\": e,\r\n                \"value\": accessor(e),\r\n            });\r\n        }\r\n        for (let i = Math.floor((elements.length / 2) - 1); i >= 0; --i) {\r\n            heap._heapify_down(i);\r\n        }\r\n        return heap;\r\n    }\r\n\r\n    /**\r\n     * Swaps elements of container array.\r\n     * @private\r\n     * @param {Number} index_a \r\n     * @param {Number} index_b \r\n     */\r\n    _swap(index_a, index_b) {\r\n        const container = this._container;\r\n        [container[index_b], container[index_a]] = [container[index_a], container[index_b]];\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    _heapify_up() {\r\n        const container = this._container;\r\n        let index = container.length - 1;\r\n        while (index > 0) {\r\n            let parentIndex = Math.floor((index - 1) / 2);\r\n            if (!this._comparator(container[index].value, container[parentIndex].value)) {\r\n                break;\r\n            } else {\r\n            this._swap(parentIndex, index)\r\n            index = parentIndex;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Pushes the element to the heap.\r\n     * @param {} element\r\n     * @returns {Heap}\r\n     */\r\n    push(element) {\r\n        const value = this._accessor(element);\r\n        //const node = new Node(element, value);\r\n        const node = {\"element\": element, \"value\": value};\r\n        this._container.push(node);\r\n        this._heapify_up();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Number} [start_index = 0] \r\n     */\r\n    _heapify_down(start_index=0) {\r\n        const container = this._container;\r\n        const comparator = this._comparator;\r\n        const length = container.length;\r\n        let left = 2 * start_index + 1;\r\n        let right = 2 * start_index + 2;\r\n        let index = start_index;\r\n        if (index > length) throw \"index higher than length\"\r\n        if (left < length && comparator(container[left].value, container[index].value)) {\r\n            index = left;\r\n        }\r\n        if (right < length && comparator(container[right].value, container[index].value)) {\r\n            index = right;\r\n        }\r\n        if (index !== start_index) {\r\n            this._swap(start_index, index);\r\n            this._heapify_down(index);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes and returns the top entry of the heap.\r\n     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).\r\n     */\r\n    pop() {\r\n        const container = this._container;\r\n        if (container.length === 0) {\r\n            return null;\r\n        } else if (container.length === 1) {\r\n            return container.pop();\r\n        }\r\n        this._swap(0, container.length - 1);\r\n        const item = container.pop();\r\n        this._heapify_down();\r\n        return item;\r\n    }\r\n\r\n    /**\r\n     * Returns the top entry of the heap without removing it.\r\n     * @returns {Object} Object consists of the element and its value (computed by {@link accessor}).\r\n     */\r\n    get first() {\r\n        return this._container.length > 0 ? this._container[0] : null;\r\n    }\r\n\r\n\r\n    /**\r\n     * Yields the raw data\r\n     * @yields {Object} Object consists of the element and its value (computed by {@link accessor}).\r\n     */\r\n    * iterate() {\r\n        for (let i = 0, n = this._container.length; i < n; ++i) {\r\n            yield this._container[i].element;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the heap as ordered array.\r\n     * @returns {Array} Array consisting the elements ordered by {@link comparator}.\r\n     */\r\n    toArray() {\r\n        return this.data()\r\n            .sort((a,b) => this._comparator(a, b) ? -1 : 0)\r\n    }\r\n\r\n    /**\r\n     * Returns elements of container array.\r\n     * @returns {Array} Array consisting the elements.\r\n     */\r\n    data() {\r\n        return this._container\r\n            .map(d => d.element)\r\n    }\r\n\r\n    /**\r\n     * Returns the container array.\r\n     * @returns {Array} The container array.\r\n     */\r\n    raw_data() {\r\n        return this._container;\r\n    }\r\n\r\n    /**\r\n     * The size of the heap.\r\n     * @returns {Number}\r\n     */\r\n    get length() {\r\n        return this._container.length;\r\n    }\r\n\r\n    /**\r\n     * Returns false if the the heap has entries, true if the heap has no entries.\r\n     * @returns {Boolean}\r\n     */\r\n    get empty() {\r\n        return this.length === 0;\r\n    }\r\n}","import { euclidean } from \"../metrics/index\";\r\nimport { Heap } from \"../datastructure/index\";\r\n/**\r\n * @class\r\n * @alias BallTree\r\n */\r\nexport class BallTree {\r\n    /**\r\n     * Generates a BallTree with given {@link elements}.\r\n     * @constructor\r\n     * @memberof module:knn\r\n     * @alias BallTree\r\n     * @param {Array=} elements - Elements which should be added to the BallTree\r\n     * @param {Function} [metric = euclidean] metric to use: (a, b) => distance\r\n     * @see {@link https://en.wikipedia.org/wiki/Ball_tree}\r\n     * @see {@link https://github.com/invisal/noobjs/blob/master/src/tree/BallTree.js}\r\n     * @returns {BallTree}\r\n     */\r\n    constructor(elements = null, metric = euclidean) {\r\n        this._Node = class {\r\n            constructor(pivot, child1=null, child2=null, radius=null) {\r\n                this.pivot = pivot;\r\n                this.child1 = child1;\r\n                this.child2 = child2;\r\n                this.radius = radius;\r\n            }\r\n        }\r\n        this._Leaf = class {\r\n            constructor(points) {\r\n                this.points = points;\r\n            }\r\n        }\r\n        this._metric = metric;\r\n        if (elements) {\r\n            this.add(elements);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Array<*>} elements - new elements.\r\n     * @returns {BallTree}\r\n     */\r\n    add(elements) {\r\n        elements = elements.map((element, index) => {\r\n            return {index: index, element: element}\r\n        })\r\n        this._root = this._construct(elements)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array<*>} elements \r\n     * @returns {Node} root of balltree.\r\n     */\r\n    _construct(elements) {\r\n        if (elements.length === 1) {\r\n            return new this._Leaf(elements);\r\n        } else {\r\n            let c = this._greatest_spread(elements);\r\n            let sorted_elements = elements.sort((a, b) => a.element[c] - b.element[c])\r\n            let n = sorted_elements.length;\r\n            let p_index = Math.floor(n / 2);\r\n            let p = elements[p_index];\r\n            let L = sorted_elements.slice(0, p_index);\r\n            let R = sorted_elements.slice(p_index, n);\r\n            let radius = Math.max(...elements.map(d => this._metric(p.element, d.element)));\r\n            let B\r\n            if (L.length > 0 && R.length > 0) {         \r\n                B = new this._Node(p, this._construct(L), this._construct(R), radius);\r\n            } else {\r\n                B = new this._Leaf(elements)\r\n            }\r\n            return B;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Node} B \r\n     * @returns {Number}\r\n     */\r\n    _greatest_spread(B) {\r\n        let d = B[0].element.length;\r\n        let start = new Array(d);\r\n\r\n        for (let i = 0; i < d; ++i) {\r\n            start[i] = [Infinity, -Infinity];\r\n        }\r\n\r\n        let spread = B.reduce((acc, current) => {\r\n            for (let i = 0; i < d; ++i) {\r\n                acc[i][0] = Math.min(acc[i][0], current.element[i]);\r\n                acc[i][1] = Math.max(acc[i][1], current.element[i]);\r\n            }\r\n            return acc;\r\n        }, start)\r\n        spread = spread.map(d => d[1] - d[0]);\r\n        \r\n        let c = 0;\r\n        for (let i = 0; i < d; ++i) {\r\n            c = spread[i] > spread[c] ? i : c;\r\n        }\r\n        return c\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} t - query element.\r\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\r\n     * @returns {Heap} - Heap consists of the {@link k} nearest neighbors.\r\n     */\r\n    search(t, k = 5) {\r\n        return this._search(t, k, new Heap(null, d => this._metric(d.element, t), \"max\"), this._root);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {*} t - query element.\r\n     * @param {Number} [k = 5] - number of nearest neighbors to return.\r\n     * @param {Heap} Q - Heap consists of the currently found {@link k} nearest neighbors.\r\n     * @param {Node|Leaf} B \r\n     */\r\n    _search(t, k, Q, B) {\r\n        // B is Node\r\n        if (Q.length >= k && B.pivot && B.radius && this._metric(t, B.pivot.element) - B.radius >= Q.first.value) {\r\n            return Q;\r\n        } \r\n        if (B.child1) this._search(t, k, Q, B.child1);\r\n        if (B.child2) this._search(t, k, Q, B.child2);\r\n        \r\n        // B is leaf\r\n        if (B.points) {\r\n            for (let i = 0, n = B.points.length; i < n; ++i) {\r\n                let p = B.points[i];\r\n                if (k > Q.length) {\r\n                    Q.push(p);\r\n                } else {\r\n                    Q.push(p);\r\n                    Q.pop();\r\n                }\r\n            }\r\n        }\r\n        return Q;\r\n    }\r\n\r\n\r\n}\r\n","import { Matrix, norm } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\"\r\nimport { neumair_sum } from \"../numerical/index\";\r\n\r\n/**\r\n * Computes the QR Decomposition of the Matrix {@link A} using Gram-Schmidt process.\r\n * @memberof module:linear_algebra\r\n * @alias qr\r\n * @param {Matrix} A\r\n * @returns {{R: Matrix, Q: Matrix}}\r\n * @see {@link https://en.wikipedia.org/wiki/QR_decomposition#Using_the_Gram%E2%80%93Schmidt_process}\r\n */\r\nexport default function(A) {\r\n    const [rows, cols] = A.shape;\r\n    const Q = new Matrix(rows, cols, \"identity\");\r\n    const R = new Matrix(cols, cols, 0);\r\n\r\n    for (let j = 0; j < cols; ++j) {\r\n        let v = A.col(j);\r\n        for (let i = 0; i < j; ++i) {\r\n            const q = Q.col(i);\r\n            const q_dot_v = neumair_sum(q.map((q_, k) => q_ * v[k]));\r\n            R.set_entry(i,j, q_dot_v);\r\n            v = v.map((v_, k) => v_ - q_dot_v * q[k]);\r\n        }\r\n        const v_norm = norm(v, euclidean);\r\n        for (let k = 0; k < rows; ++k) {\r\n            Q.set_entry(k, j, v[k] / v_norm);\r\n        }\r\n        R.set_entry(j,j, v_norm)\r\n    }\r\n    return {\"R\": R, \"Q\": Q};\r\n}\r\n\r\n","import { qr } from \"./index\";\r\nimport { Matrix } from \"../matrix/Matrix\";\r\nimport { Randomizer } from \"../util/index\";\r\nimport { neumair_sum } from \"../numerical/index\";\r\n\r\n/**\r\n * Computes the {@link k} biggest Eigenvectors and Eigenvalues from Matrix {@link A} with the QR-Algorithm.\r\n * @param {Matrix} A - The Matrix\r\n * @param {Number} k - The number of eigenvectors and eigenvalues to compute.\r\n * @param {Number} [max_iterations=100] - The number of maxiumum iterations the algorithm should run.\r\n * @param {Number|Randomizer} [seed=1212] - The seed value or a randomizer used in the algorithm.\r\n * @returns {{eigenvalues: Array, eigenvectors: Array}} - The {@link k} biggest eigenvectors and eigenvalues of Matrix {@link A}.\r\n */\r\nexport default function(A, k = 2, max_iterations=100, seed=1212) {\r\n    const randomizer = seed instanceof Randomizer ? seed : new Randomizer(seed);\r\n    if (!(A instanceof Matrix)) A = Matrix.from(A);\r\n    const n = A.shape[0]\r\n    let { Q: Q, R: R } = qr(new Matrix(n, k, () => randomizer.random));\r\n    while (max_iterations--) {\r\n        const oldR = R.clone();\r\n        const Z = A.dot(Q);\r\n        const QR = qr(Z); \r\n        Q = QR.Q;\r\n        R = QR.R;\r\n        if (neumair_sum(R.sub(oldR).diag) / n < 1e-12) {\r\n            max_iterations = 0;\r\n        }        \r\n    }\r\n\r\n    const eigenvalues = R.diag;\r\n    const eigenvectors = Q.transpose().to2dArray;\r\n    return {\r\n        \"eigenvalues\": eigenvalues,\r\n        \"eigenvectors\": eigenvectors,\r\n    };\r\n}\r\n\r\n","import { euclidean } from \"../metrics/index\";\r\nimport { Matrix } from \"../matrix/index\";\r\nimport { Randomizer } from \"../util/randomizer\";\r\n\r\n/**\r\n * @class\r\n * @alias DR\r\n */\r\nexport class DR{\r\n    //static parameter_list = [];\r\n    get parameter_list() {\r\n        return this._parameter_list;\r\n    }\r\n\r\n    set parameter_list(list) {\r\n        this._parameter_list = list;\r\n        return this;\r\n    }\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias DR\r\n     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data. \r\n     * @param {number} [d = 2] - the dimensionality of the projection.\r\n     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {seed} [seed=1987] - the seed value for the random number generator.\r\n     * @returns {DR}\r\n     */\r\n    constructor(X, d=2, metric=euclidean, seed=1212) {\r\n        if (Array.isArray(X)) {\r\n            this._type = \"array\";\r\n            this.X = Matrix.from(X);\r\n        } else if (X instanceof Matrix) {\r\n            this._type = \"matrix\";\r\n            this.X = X;\r\n        } else {\r\n            throw \"no valid type for X\";\r\n        }\r\n        [this._N, this._D] = this.X.shape;\r\n        this._d = d;\r\n        this._metric = metric;\r\n        this._seed = seed;\r\n        this._randomizer = new Randomizer(seed);\r\n        this._is_initialized = false;\r\n        return this;\r\n    }\r\n        \r\n    /**\r\n     * Set and get parameters\r\n     * @param {String} name - name of the parameter.\r\n     * @param {Number} [value = null] - value of the parameter to set, if null then return actual parameter value.\r\n     */\r\n    parameter(name, value=null) {\r\n        if (this.parameter_list.findIndex(parameter => parameter === name) === -1) {\r\n            throw `${name} is not a valid parameter!`;\r\n        } \r\n        if (value) {\r\n            this[`_${name}`] = value;\r\n            return this; \r\n        } else {\r\n            return this[`_${name}`];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Alias for 'parameter'.\r\n     * @param {String} name \r\n     * @param {Number} value \r\n     */\r\n    para(name, value=null) {\r\n        return this.parameter(name, value);\r\n    }\r\n\r\n    /**\r\n     * Alias for 'parameter'.\r\n     * @param {String} name \r\n     * @param {Number} value \r\n     */\r\n    p(name, value=null) {\r\n        return this.parameter(name, value);\r\n    }\r\n\r\n    /**\r\n     * Computes the projection.\r\n     * @returns {Matrix} Returns the projection.\r\n     */\r\n    transform() {\r\n        this.check_init();\r\n        return this.Y;\r\n    }\r\n\r\n    generator() {\r\n        return this.transform();\r\n    }\r\n\r\n    check_init() {\r\n        if (!this._is_initialized && typeof this.init === \"function\") {\r\n            this.init();\r\n            this._is_initialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {Matrix} Returns the projection.\r\n     */\r\n    get projection() {\r\n        return this._type === \"matrix\" ? this.Y : this.Y.to2dArray;\r\n    }\r\n\r\n    async transform_async() {\r\n        return this.transform();\r\n    }\r\n\r\n    static transform(...args) {\r\n        let dr = new this(...args);\r\n        return dr.transform();\r\n    }\r\n\r\n    static async transform_async(...args) {\r\n        return this.transform(...args);\r\n    }\r\n\r\n    static *generator(...args) {\r\n        const dr = new this(...args);\r\n        const gen = dr.generator();\r\n        for (const res of gen) {\r\n            yield res;\r\n        }\r\n    }\r\n} ","import { simultaneous_poweriteration} from \"../linear_algebra/index\";\r\nimport { Matrix } from \"../matrix/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias PCA\r\n * @augments DR\r\n */\r\nexport class PCA extends DR{\r\n    /**\r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias PCA \r\n     * @param {Matrix|Array<Array<Number>>} X - the high-dimensional data.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @returns {PCA}\r\n     */\r\n    constructor(X, d=2) {\r\n        super(X, d);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\r\n     */\r\n    transform() {\r\n        let X = this.X;\r\n        let D = X.shape[1];\r\n        let O = new Matrix(D, D, \"center\");\r\n        let X_cent = X.dot(O);\r\n\r\n        let C = X_cent.transpose().dot(X_cent)\r\n        let { eigenvectors: V } = simultaneous_poweriteration(C, this._d)\r\n        V = Matrix.from(V).transpose()\r\n        this.Y = X.dot(V)\r\n        return this.projection;\r\n    }\r\n} ","import { simultaneous_poweriteration} from \"../linear_algebra/index\";\r\nimport { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias MDS\r\n */\r\nexport class MDS extends DR{\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias MDS\r\n     * @param {Matrix} X - the high-dimensional data.\r\n     * @param {Number} neighbors - the label / class of each data point.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     */\r\n    \r\n    constructor(X, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\r\n     */\r\n    transform() {\r\n        const X = this.X;\r\n        const rows = X.shape[0];\r\n        const metric = this._metric;\r\n        let ai_ = new Float64Array(rows);\r\n        let a_j = new Float64Array(rows);\r\n        let a__ = 0;\r\n\r\n        const A = new Matrix();\r\n        A.shape = [rows, rows, (i,j) => {\r\n            if (i === j) return 0;\r\n            const val = (i < j) ? metric(X.row(i), X.row(j)) : A.entry(j,i);\r\n            ai_[i] += val;\r\n            a_j[j] += val;\r\n            a__ += val;\r\n            return val;\r\n        }];\r\n        this._d_X = A;\r\n        ai_ = ai_.map(v => v / rows);\r\n        a_j = a_j.map(v => v / rows);\r\n        a__ /= (rows ** 2);\r\n        const B = new Matrix(rows, rows, (i, j) => (A.entry(i, j) - ai_[i] - a_j[j] + a__));\r\n        //B.shape = [rows, rows, (i,j) => (A.entry(i,j) - (A.row(i).reduce(sum_reduce) / rows) - (A.col(j).reduce(sum_reduce) / rows) + a__)]\r\n                \r\n        const { eigenvectors: V } = simultaneous_poweriteration(B, this._d);\r\n        this.Y = Matrix.from(V).transpose()\r\n        \r\n        return this.projection;\r\n    }\r\n\r\n    get stress() {\r\n        const N = this.X.shape[0];\r\n        const Y = this.Y;\r\n        const d_X = this._d_X; /*new Matrix();\r\n        d_X.shape = [N, N, (i, j) => {\r\n            return i < j ? metric(X.row(i), X.row(j)) : d_X.entry(j, i);\r\n        }]*/\r\n        const d_Y = new Matrix();\r\n        d_Y.shape = [N, N, (i, j) => {\r\n            return i < j ? euclidean(Y.row(i), Y.row(j)) : d_Y.entry(j, i);\r\n        }]\r\n        let top_sum = 0;\r\n        let bottom_sum = 0;\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let j = i + 1; j < N; ++j) {\r\n                top_sum += Math.pow(d_X.entry(i, j) - d_Y.entry(i, j), 2);\r\n                bottom_sum += Math.pow(d_X.entry(i, j), 2);\r\n            }\r\n        }\r\n        return Math.sqrt(top_sum / bottom_sum);\r\n    }\r\n}","import { simultaneous_poweriteration} from \"../linear_algebra/index\";\r\nimport { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { Heap } from \"../datastructure/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias ISOMAP\r\n */\r\nexport class ISOMAP extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias ISOMAP\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {Number} neighbors - the number of neighbors {@link ISOMAP} should use to project the data.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection. \r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points. \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     */\r\n    constructor(X, neighbors, d = 2, metric = euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"k\"];\r\n        this.parameter(\"k\", Math.min(neighbors ?? Math.max(Math.floor(this.X.shape[0] / 10), 2), this._N -1));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the projection.\r\n     * @returns {Matrix} Returns the projection.\r\n     */\r\n    transform() {\r\n        this.check_init();\r\n        const X = this.X;\r\n        const rows = this._N;\r\n        const metric = this._metric;\r\n        // TODO: make knn extern and parameter for constructor or transform?\r\n        const D = new Matrix();\r\n        D.shape = [rows, rows, (i,j) => i <= j ? metric(X.row(i), X.row(j)) : D.entry(j,i)]\r\n        const kNearestNeighbors = [];\r\n        for (let i = 0; i < rows; ++i) {\r\n            const row = [];\r\n            for (let j = 0; j < rows; ++j) {\r\n                row.push({\r\n                    \"index\": j,\r\n                    \"distance\": D.entry(i, j),\r\n                })\r\n            }\r\n            const H = new Heap(row, d => d.distance, \"min\");\r\n            kNearestNeighbors.push(H.toArray().slice(1, this._k + 1))\r\n        }\r\n        \r\n        /*D = dijkstra(kNearestNeighbors);*/\r\n        // compute shortest paths\r\n        // TODO: make extern\r\n        /** @see {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm} */\r\n        const G = new Matrix(rows, rows, (i,j) => {\r\n            const other = kNearestNeighbors[i].find(n => n.index === j);\r\n            return other ? other.distance : Infinity\r\n        });\r\n\r\n        for (let i = 0; i < rows; ++i) {\r\n            for (let j = 0; j < rows; ++j) {\r\n                for (let k = 0; k < rows; ++k) {\r\n                    G.set_entry(i, j, Math.min(G.entry(i, j), G.entry(i, k) + G.entry(k, j)));\r\n                }\r\n            }\r\n        }\r\n        \r\n        let ai_ = new Float64Array(rows);\r\n        let a_j = new Float64Array(rows);\r\n        let a__ = 0;\r\n        let A = new Matrix(rows, rows, (i,j) => {\r\n            let val = G.entry(i, j);\r\n            val = val === Infinity ? 0 : val;\r\n            ai_[i] += val;\r\n            a_j[j] += val;\r\n            a__ += val;\r\n            return val;\r\n        });\r\n        \r\n        ai_ = ai_.map(v => v / rows);\r\n        a_j = a_j.map(v => v / rows);\r\n        a__ /= (rows ** 2);\r\n        const B = new Matrix(rows, rows, (i,j) => (A.entry(i,j) - ai_[i] - a_j[j] + a__));\r\n             \r\n        // compute d eigenvectors\r\n        const { eigenvectors: V } = simultaneous_poweriteration(B, this._d);\r\n        this.Y = Matrix.from(V).transpose();\r\n        // return embedding\r\n        return this.projection;\r\n    }\r\n\r\n\r\n}","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { DR } from \"./DR.js\";\r\n/**\r\n * @class\r\n * @alias FASTMAP\r\n */\r\nexport class FASTMAP extends DR{\r\n    /**\r\n     * FastMap: a fast algorithm for indexing, data-mining and visualization of traditional and multimedia datasets\r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias FASTMAP\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     * @returns {FASTMAP}\r\n     * @see {@link https://doi.org/10.1145/223784.223812}\r\n     */\r\n    constructor(X, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Chooses two points which are the most distant in the actual projection.\r\n     * @private\r\n     * @param {function} dist \r\n     * @returns {Array} An array consisting of first index, second index, and distance between the two points.\r\n     */\r\n    _choose_distant_objects(dist) {\r\n        const X = this.X;\r\n        const N = X.shape[0];\r\n        let a_index = this._randomizer.random_int % N - 1;\r\n        let b_index = null;\r\n        let max_dist = -Infinity;\r\n        for (let i = 0; i < N; ++i) {\r\n            const d_ai = dist(a_index, i)\r\n            if (d_ai > max_dist) {\r\n                max_dist = d_ai;\r\n                b_index = i;\r\n            }\r\n        }\r\n        max_dist = -Infinity;\r\n        for (let i = 0; i < N; ++i) {\r\n            const d_bi = dist(b_index, i)\r\n            if (d_bi > max_dist) {\r\n                max_dist = d_bi;\r\n                a_index = i;\r\n            }\r\n        }\r\n        return [a_index, b_index, max_dist];\r\n    }\r\n\r\n    /**\r\n     * Computes the projection.\r\n     * @returns {Matrix} The {@link d}-dimensional projection of the data matrix {@link X}.\r\n     */\r\n    transform() {\r\n        const X = this.X;\r\n        const N = X.shape[0];\r\n        const d = this._d;\r\n        const metric = this._metric;\r\n        const Y = new Matrix(N, d, 0);\r\n        let dist = (a, b) => metric(X.row(a), X.row(b));\r\n\r\n        for (let _col = 0; _col < d; ++_col) {\r\n            let old_dist = dist;\r\n            // choose pivot objects\r\n            const [a_index, b_index, d_ab] = this._choose_distant_objects(dist);\r\n            // record id of pivot objects\r\n            //PA[0].push(a_index);\r\n            //PA[1].push(b_index);\r\n            /* if (d_ab === 0) {\r\n                // because all inter-object distances are zeros\r\n                for (let i = 0; i < N; ++i) {\r\n                    Y.set_entry(i, _col, 0);\r\n                }\r\n            } else { */\r\n            if (d_ab !== 0) {\r\n                // project the objects on the line (O_a, O_b)\r\n                for (let i = 0; i < N; ++i) {\r\n                    const d_ai = dist(a_index, i);\r\n                    const d_bi = dist(b_index, i);\r\n                    const y_i = (d_ai ** 2 + d_ab ** 2 - d_bi ** 2) / (2 * d_ab);\r\n                    Y.set_entry(i, _col, y_i);\r\n                }\r\n                // consider the projections of the objects on a\r\n                // hyperplane perpendicluar to the line (a, b);\r\n                // the distance function D'() between two \r\n                // projections is given by Eq.4\r\n                dist = (a, b) => Math.sqrt(old_dist(a, b) ** 2 - (Y.entry(a, _col) - Y.entry(b, _col)) ** 2)\r\n            }\r\n        }\r\n        // return embedding\r\n        this.Y = Y;\r\n        return this.projection;\r\n    }\r\n}","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { simultaneous_poweriteration} from \"../linear_algebra/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias LDA\r\n */\r\nexport class LDA extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias LDA\r\n     * @param {Matrix} X - the high-dimensional data.\r\n     * @param {Array} labels - the label / class of each data point.\r\n     * @param {number} [d = 2] - the dimensionality of the projection.\r\n     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     */\r\n    constructor(X, labels, d = 2, metric = euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"labels\"];\r\n        this.parameter(\"labels\", labels);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\r\n     */\r\n    transform() {\r\n        let X = this.X;\r\n        let [ rows, cols ] = X.shape;\r\n        let labels = this._labels;\r\n        let unique_labels = {};\r\n        let label_id = 0;\r\n        labels.forEach((l, i) => {\r\n            if (l in unique_labels) {\r\n                unique_labels[l].count++;\r\n                unique_labels[l].rows.push(X.row(i));\r\n            } else {\r\n                unique_labels[l] = {\r\n                    \"id\": label_id++,\r\n                    \"count\": 1,\r\n                    \"rows\": [X.row(i)]\r\n                };\r\n            }\r\n        })\r\n        \r\n        // create X_mean and vector means;\r\n        let X_mean = X.mean;\r\n        let V_mean = new Matrix(label_id, cols)\r\n        for (let label in unique_labels) {\r\n            let V = Matrix.from(unique_labels[label].rows);\r\n            let v_mean = V.meanCols;\r\n            for (let j = 0; j < cols; ++j) {\r\n                V_mean.set_entry(unique_labels[label].id, j, v_mean[j]);\r\n            }           \r\n        }\r\n        // scatter_between\r\n        let S_b = new Matrix(cols, cols);\r\n        for (let label in unique_labels) {\r\n            let v = V_mean.row(unique_labels[label].id);\r\n            let m = new Matrix(cols, 1, (j) => v[j] - X_mean);\r\n            let N = unique_labels[label].count;\r\n            S_b = S_b.add(m.dot(m.transpose()).mult(N));\r\n        }\r\n\r\n        // scatter_within\r\n        let S_w = new Matrix(cols, cols);\r\n        for (let label in unique_labels) {\r\n            let v = V_mean.row(unique_labels[label].id);\r\n            let m = new Matrix(cols, 1, (j) => v[j])\r\n            let R = unique_labels[label].rows;\r\n            for (let i = 0, n = unique_labels[label].count; i < n; ++i) {\r\n                let row_v = new Matrix(cols, 1, (j,_) => R[i][j] - m.entry(j, 0));\r\n                S_w = S_w.add(row_v.dot(row_v.transpose()));\r\n            }\r\n        }\r\n\r\n        let { eigenvectors: V } = simultaneous_poweriteration(S_w.inverse().dot(S_b), this._d)\r\n        V = Matrix.from(V).transpose()\r\n        this.Y = X.dot(V)\r\n\r\n        // return embedding\r\n        return this.projection;\r\n    }\r\n}","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { simultaneous_poweriteration} from \"../linear_algebra/index\";\r\nimport { k_nearest_neighbors } from \"../matrix/index\";\r\nimport { neumair_sum } from \"../numerical/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias LLE\r\n */\r\nexport class LLE extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias LLE\r\n     * @param {Matrix} X - the high-dimensional data.\r\n     * @param {Number} neighbors - the label / class of each data point.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     */\r\n    constructor(X, neighbors, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"k\"];\r\n        this.parameter(\"k\", Math.min(neighbors ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1));\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\r\n     */\r\n    transform() {\r\n        const X = this.X;\r\n        const d = this._d;\r\n        const rows = this._N;\r\n        const cols = this._D;\r\n        const k = this.parameter(\"k\");\r\n        const nN = k_nearest_neighbors(X, k, null, this._metric);\r\n        const O = new Matrix(k, 1, 1);\r\n        const W = new Matrix(rows, rows);\r\n\r\n        for (let row = 0; row < rows; ++row) {\r\n            const nN_row = nN[row];\r\n            const Z = new Matrix(k, cols, (i, j) => X.entry(nN_row[i].j, j) - X.entry(row, j));\r\n            const C = Z.dot(Z.T);\r\n            if ( k > cols ) {\r\n                const C_trace = neumair_sum(C.diag) / 1000;\r\n                for (let j = 0; j < k; ++j) {\r\n                    C.set_entry(j, j, C.entry(j, j) + C_trace);\r\n                }\r\n            }\r\n            // reconstruct;\r\n            let w = Matrix.solve_CG(C, O, this._randomizer);\r\n            w = w.divide(w.sum);\r\n            for (let j = 0; j < k; ++j) {\r\n                W.set_entry(row, nN_row[j].j, w.entry(j, 0));\r\n            }\r\n        }\r\n        // comp embedding\r\n        const I = new Matrix(rows, rows, \"identity\");\r\n        const IW = I.sub(W);\r\n        const M = IW.T.dot(IW);\r\n        const { eigenvectors: V } = simultaneous_poweriteration(M.T.inverse(), d + 1);\r\n        this.Y = Matrix.from(V.slice(1, 1 + d)).T;\r\n\r\n        // return embedding\r\n        return this.projection;\r\n    }\r\n}","import { Matrix, k_nearest_neighbors } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { simultaneous_poweriteration} from \"../linear_algebra/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias LTSA\r\n */\r\nexport class LTSA extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias LTSA\r\n     * @param {Matrix} X - the high-dimensional data.\r\n     * @param {Number} neighbors - the label / class of each data point.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     * @see {@link https://epubs.siam.org/doi/abs/10.1137/S1064827502419154}\r\n     */\r\n    constructor(X, neighbors, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"k\"];\r\n        this.parameter(\"k\", Math.min(neighbors ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1));\r\n        if (this._D <= d) throw `Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${d})!`;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality {@link d}.\r\n     */\r\n    transform() {\r\n        const X = this.X;\r\n        const d = this._d;\r\n        const [ rows, D ] = X.shape;\r\n        const k = this.parameter(\"k\");\r\n        // 1.1 determine k nearest neighbors\r\n        const nN = k_nearest_neighbors(X, k, null, this._metric);\r\n        // center matrix\r\n        const O = new Matrix(D, D, \"center\");\r\n        const B = new Matrix(rows, rows, 0);\r\n        \r\n        for (let row = 0; row < rows; ++row) {\r\n            // 1.2 compute the d largest eigenvectors of the correlation matrix\r\n            const I_i = [row, ...nN[row].map(n => n.j)]\r\n            let X_i = Matrix.from(I_i.map(n => X.row(n)));\r\n            // center X_i\r\n            X_i = X_i.dot(O)\r\n            // correlation matrix\r\n            const C = X_i.dot(X_i.transpose());\r\n            const { eigenvectors: g } = simultaneous_poweriteration(C, d);\r\n            //g.push(linspace(0, k).map(_ => 1 / Math.sqrt(k + 1)));\r\n            const G_i_t = Matrix.from(g);\r\n            // 2. Constructing alignment matrix\r\n            const W_i = G_i_t.transpose().dot(G_i_t).add(1 / Math.sqrt(k + 1));\r\n            for (let i = 0; i < k + 1; ++i) {\r\n                for (let j = 0; j < k + 1; ++j) {\r\n                    B.set_entry(I_i[i], I_i[j], B.entry(I_i[i], I_i[j]) - (i === j ? 1 : 0 ) + W_i.entry(i, j));\r\n                }\r\n            }\r\n        }\r\n\r\n        // 3. Aligning global coordinates\r\n        const { eigenvectors: Y } = simultaneous_poweriteration(B, d + 1);\r\n        this.Y = Matrix.from(Y.slice(1)).transpose();\r\n\r\n        // return embedding\r\n        return this.projection;\r\n    }\r\n}","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias TSNE\r\n */\r\nexport class TSNE extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias TSNE\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {Number} [perplexity = 50] - perplexity.\r\n     * @param {Number} [epsilon = 10] - learning parameter.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     * @returns {TSNE}\r\n     */\r\n    \r\n    constructor(X, perplexity=50, epsilon=10, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"perplexity\", \"epsilon\"];\r\n        [ this._N, this._D ] = this.X.shape;\r\n        this.parameter(\"perplexity\", Math.min(perplexity, this._N - 1));\r\n        this.parameter(\"epsilon\", epsilon);\r\n        this._iter = 0;\r\n        this.Y = new Matrix(this._N, this._d, () => this._randomizer.random);\r\n        return this;\r\n    }\r\n\r\n    init(distance_matrix=null) {\r\n        // init\r\n        const Htarget = Math.log(this._perplexity);\r\n        const N = this._N;\r\n        const D = this._D;\r\n        const metric = this._metric;\r\n        const X = this.X;\r\n        let Delta;\r\n        if (distance_matrix) {\r\n            Delta = distance_matrix;\r\n        } else {\r\n            Delta = new Matrix(N, N);\r\n            for (let i = 0; i < N; ++i) {\r\n                const X_i = X.row(i);\r\n                for (let j = i + 1; j < N; ++j) {\r\n                    const distance = metric(X_i, X.row(j))\r\n                    Delta.set_entry(i, j, distance);\r\n                    Delta.set_entry(j, i, distance);\r\n                }\r\n            }\r\n\r\n        } \r\n            \r\n        const P = new Matrix(N, N, \"zeros\");\r\n\r\n        this._ystep = new Matrix(N, D, \"zeros\");\r\n        this._gains = new Matrix(N, D, 1);\r\n\r\n        // search for fitting sigma\r\n        let prow = new Array(N).fill(0);\r\n        const tol = 1e-4;\r\n        const maxtries = 50;\r\n        for (let i = 0; i < N; ++i) {\r\n            let betamin = -Infinity;\r\n            let betamax = Infinity;\r\n            let beta = 1;\r\n            let done = false;\r\n\r\n            let num = 0;\r\n            while(!done) {\r\n                let psum = 0;\r\n                for (let j = 0; j < N; ++j) {\r\n                    let pj = Math.exp(-Delta.entry(i, j) * beta);\r\n                    if (i === j) pj = 0;\r\n                    prow[j] = pj;\r\n                    psum += pj;\r\n                }\r\n                let Hhere = 0;\r\n                for (let j = 0; j < N; ++j) {\r\n                    let pj = (psum === 0) ? 0 : prow[j] / psum;\r\n                    prow[j] = pj;\r\n                    if (pj > 1e-7) {\r\n                        Hhere -= pj * Math.log(pj);\r\n                    }\r\n                }\r\n                if (Hhere > Htarget) {\r\n                    betamin = beta;\r\n                    beta = (betamax === Infinity) ? (beta * 2) : ((beta + betamax) / 2);\r\n                } else {\r\n                    betamax = beta;\r\n                    beta = (betamin === -Infinity) ? (beta / 2) : ((beta + betamin) / 2);\r\n                }\r\n                ++num;\r\n                if (Math.abs(Hhere - Htarget) < tol) done = true;\r\n                if (num >= maxtries) done = true;\r\n            }\r\n\r\n            for (let j = 0; j < N; ++j) {\r\n                P.set_entry(i, j, prow[j]);\r\n            }\r\n        }\r\n\r\n        //compute probabilities\r\n        const Pout = new Matrix(N, N, \"zeros\")\r\n        const N2 = N * 2;\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let j = i; j < N; ++j) {\r\n                const p = Math.max((P.entry(i, j) + P.entry(j, i)) / N2, 1e-100);\r\n                Pout.set_entry(i, j, p);\r\n                Pout.set_entry(j, i, p);\r\n            }\r\n        }\r\n        this._P = Pout;\r\n        return this;\r\n    }\r\n\r\n    transform(iterations=500) {\r\n        this.check_init();\r\n        for (let i = 0; i < iterations; ++i) {\r\n            this.next();\r\n        }\r\n        return this.projection;\r\n    }\r\n\r\n    * generator() {\r\n        this.check_init();\r\n        while (true) {\r\n            this.next();\r\n            yield this.projection;\r\n        }\r\n    }\r\n\r\n    // perform optimization\r\n    next() {\r\n        const iter = ++this._iter;\r\n        const P = this._P;\r\n        const ystep = this._ystep;\r\n        const gains = this._gains;\r\n        const N = this._N;\r\n        const epsilon = this._epsilon;\r\n        const dim = this._d;\r\n        let Y = this.Y;\r\n\r\n        //calc cost gradient;\r\n        const pmul = iter < 100 ? 4 : 1;\r\n        \r\n        // compute Q dist (unnormalized)\r\n        const Qu = new Matrix(N, N, \"zeros\")\r\n        let qsum = 0;\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let j = i + 1; j < N; ++j) {\r\n                let dsum = 0;\r\n                for (let d = 0; d < dim; ++d) {\r\n                    const dhere = Y.entry(i, d) - Y.entry(j, d);\r\n                    dsum += dhere * dhere;\r\n                }\r\n                const qu = 1 / (1 + dsum);\r\n                Qu.set_entry(i, j, qu);\r\n                Qu.set_entry(j, i, qu);\r\n                qsum += 2 * qu;\r\n            }\r\n        }\r\n\r\n        // normalize Q dist\r\n        const Q = new Matrix(N, N, 0)\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let j = i + 1; j < N; ++j) {\r\n                const val = Math.max(Qu.entry(i, j) / qsum, 1e-100);\r\n                Q.set_entry(i, j, val);\r\n                Q.set_entry(j, i, val);\r\n            }\r\n        }\r\n\r\n        const grad = new Matrix(N, dim, \"zeros\");\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let j = 0; j < N; ++j) {\r\n                const premult = 4 * (pmul * P.entry(i, j) - Q.entry(i, j)) * Qu.entry(i, j);\r\n                for (let d = 0; d < dim; ++d) {\r\n                    grad.set_entry(i, d, grad.entry(i, d) + premult * (Y.entry(i, d) - Y.entry(j, d)));\r\n                }\r\n            }\r\n        }\r\n\r\n        // perform gradient step\r\n        let ymean = new Float64Array(dim);\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let d = 0; d < dim; ++d) {\r\n                const gid = grad.entry(i, d);\r\n                const sid = ystep.entry(i, d);\r\n                const gainid = gains.entry(i, d);\r\n                \r\n                let newgain = Math.sign(gid) === Math.sign(sid) ? gainid * .8 : gainid + .2;\r\n                if (newgain < .01) newgain = .01;\r\n                gains.set_entry(i, d, newgain);\r\n\r\n                const momval = iter < 250 ? .5 : .8;\r\n                const newsid = momval * sid - epsilon * newgain * gid;\r\n                ystep.set_entry(i, d, newsid);\r\n\r\n                Y.set_entry(i, d, Y.entry(i, d) + newsid);\r\n                ymean[d] += Y.entry(i, d);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let d = 0; d < 2; ++d) {\r\n                Y.set_entry(i, d, Y.entry(i, d) - ymean[d] / N)\r\n            }\r\n        }\r\n\r\n        return this.Y;\r\n    }\r\n} ","// http://optimization-js.github.io/optimization-js/optimization.js.html#line438\r\nexport default function(f, x0, max_iter=300) {\r\n    const epsilon = 1e-2;\r\n    const n = x0.length;\r\n    let alpha = 1e-3;\r\n    let pfx = 10000;\r\n    let x = x0.slice();\r\n    let fx = f(x);\r\n    let convergence = false;\r\n    \r\n    while (max_iter-- >= 0 && !convergence) {\r\n        convergence = true;\r\n        for (let i = 0; i < n; ++i) {\r\n            x[i] += 1e-6;\r\n            let fxi = f(x);\r\n            x[i] -= 1e-6;\r\n            let dx = (fxi - fx) / 1e-6;\r\n            if (Math.abs(dx) > epsilon) {\r\n                convergence = false;\r\n            }\r\n            x[i] -= alpha * dx;\r\n            fx = f(x);\r\n        }\r\n        alpha *= (pfx >= fx ? 1.05 : 0.4);\r\n        pfx = fx;\r\n    }\r\n    return x;\r\n}\r\n","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean, euclidean_squared } from \"../metrics/index\";\r\nimport { BallTree } from \"../knn/index\";\r\nimport { neumair_sum } from \"../numerical/index\";\r\nimport { linspace } from \"../matrix/index\";\r\nimport { powell } from \"../optimization/index\";\r\nimport { DR } from \"./DR.js\";\r\nimport { max } from \"../util/index\";\r\n\r\nexport class UMAP extends DR {\r\n    constructor(X, n_neighbors=15, local_connectivity=1, min_dist=1, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed)\r\n        super.parameter_list = [\"n_neighbors\", \"local_connectivity\", \"min_dist\"];\r\n        [ this._N, this._D ] = this.X.shape;\r\n        n_neighbors = Math.min(this._N - 1, n_neighbors);\r\n        this.parameter(\"n_neighbors\", n_neighbors);\r\n        this.parameter(\"local_connectivity\", Math.min(local_connectivity, n_neighbors - 1));\r\n        this.parameter(\"min_dist\", min_dist);\r\n        this._iter = 0;\r\n        this._spread = 1;\r\n        this._set_op_mix_ratio = 1;\r\n        this._repulsion_strength = 1;\r\n        this._negative_sample_rate = 5;\r\n        this._n_epochs = 350;\r\n        this._initial_alpha = 1;\r\n        this.Y = new Matrix(this._N, this._d, () => this._randomizer.random);\r\n        return this;\r\n    }\r\n\r\n    _find_ab_params(spread, min_dist) {\r\n        const curve = (x, a, b) => 1 / (1 + a * Math.pow(x, 2 * b));\r\n        const xv = linspace(0, spread * 3, 300);\r\n        const yv = linspace(0, spread * 3, 300);\r\n        \r\n        for (let i = 0, n = xv.length; i < n; ++i) {\r\n            const xv_i = xv[i];\r\n            yv[i] = (xv_i < min_dist ? 1 : Math.exp(-(xv_i - min_dist) / spread));\r\n        }\r\n      \r\n        const err = (p) => {\r\n            const error = linspace(1, 300).map((_, i) => yv[i] - curve(xv[i], p[0], p[1]));\r\n            return Math.sqrt(neumair_sum(error.map(e => e * e)));\r\n        }\r\n      \r\n        return powell(err, [1, 1]);\r\n    }\r\n\r\n    _compute_membership_strengths(distances, sigmas, rhos) {\r\n        for (let i = 0, n = distances.length; i < n; ++i) {\r\n            for (let j = 0, m = distances[i].length; j < m; ++j) {\r\n                const v = distances[i][j].value - rhos[i];\r\n                distances[i][j].value = v > 0 ? Math.exp(-v / sigmas[i]) : 1;\r\n            }\r\n        }\r\n        return distances;\r\n    }\r\n\r\n    _smooth_knn_dist(knn, k) {\r\n        const SMOOTH_K_TOLERANCE = 1e-5;\r\n        const MIN_K_DIST_SCALE = 1e-3;\r\n        const n_iter = 64;\r\n        const local_connectivity = this._local_connectivity;\r\n        const target = Math.log2(k);\r\n        const rhos = []\r\n        const sigmas = []\r\n        const X = this.X\r\n\r\n        const distances = [...X].map(x_i => knn.search(x_i, k).raw_data().reverse());\r\n\r\n        for (let i = 0, n = X.shape[0]; i < n; ++i) {\r\n            let lo = 0;\r\n            let hi = Infinity;\r\n            let mid = 1;\r\n\r\n            const search_result = distances[i]\r\n            const non_zero_dist = search_result.filter(d => d.value > 0);\r\n            const non_zero_dist_length = non_zero_dist.length;\r\n            if (non_zero_dist_length >= local_connectivity) {\r\n                const index = Math.floor(local_connectivity);\r\n                const interpolation = local_connectivity - index;\r\n                if (index > 0) {\r\n                    rhos.push(non_zero_dist[index - 1]);\r\n                    if (interpolation > SMOOTH_K_TOLERANCE) {\r\n                        rhos[i].value += interpolation * (non_zero_dist[index].value - non_zero_dist[index - 1]);\r\n                    }\r\n                } else {\r\n                    rhos[i].value = interpolation * non_zero_dist[0].value;\r\n                }\r\n            } else if (non_zero_dist_length > 0) {\r\n                rhos[i] = non_zero_dist[non_zero_dist_length - 1].value;\r\n            }\r\n            for (let x = 0; x < n_iter; ++x) {\r\n                let psum = 0;\r\n                for (let j = 0; j < k; ++j) {\r\n                    const d = search_result[j].value - rhos[i];\r\n                    psum += (d > 0 ? Math.exp(-(d / mid)) : 1);\r\n                }\r\n                if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {\r\n                    break;\r\n                }\r\n                if (psum > target) {\r\n                    [hi, mid] = [mid, (lo + hi) / 2];\r\n                } else {\r\n                    if (hi === Infinity) {\r\n                        [lo, mid] = [mid, mid * 2];\r\n                    } else {\r\n                        [lo, mid] = [mid, (lo + hi) / 2];\r\n                    }\r\n                }\r\n            }\r\n            sigmas[i] = mid;\r\n\r\n            const mean_ithd = search_result.reduce((a, b) => a + b.value, 0) / search_result.length;\r\n            //let mean_d = null;\r\n            if (rhos[i] > 0) {\r\n                if (sigmas[i] < MIN_K_DIST_SCALE * mean_ithd) {\r\n                    sigmas[i] = MIN_K_DIST_SCALE * mean_ithd;\r\n                }\r\n            } else {\r\n                const mean_d = distances.reduce((acc, res) => acc + res.reduce((a, b) => a + b.value, 0) / res.length);\r\n                if (sigmas[i] > MIN_K_DIST_SCALE * mean_d) {\r\n                    sigmas[i] = MIN_K_DIST_SCALE * mean_d;\r\n                }\r\n                \r\n            }\r\n        }\r\n        return {\r\n            \"distances\": distances, \r\n            \"sigmas\": sigmas, \r\n            \"rhos\": rhos\r\n        }\r\n    }\r\n\r\n    _fuzzy_simplicial_set(X, n_neighbors) {\r\n        const N = X.shape[0];\r\n        const knn = new BallTree(X.to2dArray, euclidean);\r\n        let { distances, sigmas, rhos } = this._smooth_knn_dist(knn, n_neighbors);\r\n        distances = this._compute_membership_strengths(distances, sigmas, rhos);\r\n        const result = new Matrix(N, N, \"zeros\");\r\n        for (let i = 0; i < N; ++i) {\r\n            const distances_i = distances[i];\r\n            for (let j = 0; j < distances_i.length; ++j) {\r\n                result.set_entry(i, distances_i[j].element.index, distances_i[j].value);\r\n            }\r\n        }\r\n        const transposed_result = result.T;\r\n        const prod_matrix = result.mult(transposed_result);\r\n        return result\r\n            .add(transposed_result)\r\n            .sub(prod_matrix)\r\n            .mult(this._set_op_mix_ratio)\r\n            .add(prod_matrix.mult(1 - this._set_op_mix_ratio));\r\n    }\r\n\r\n    _make_epochs_per_sample(n_epochs) {\r\n        const weights = this._weights;\r\n        const result = new Float32Array(weights.length).fill(-1);\r\n        const weights_max = max(weights);\r\n        const n_samples = weights.map(w => n_epochs * (w / weights_max));\r\n        for (let i = 0; i < result.length; ++i) \r\n          if (n_samples[i] > 0) result[i] = Math.round(n_epochs / n_samples[i]);\r\n        return result;\r\n    }\r\n\r\n    _tocoo(graph) {\r\n        const rows = [];\r\n        const cols = [];\r\n        const data = [];\r\n        const [ rows_n, cols_n ] = graph.shape;\r\n        for (let row = 0; row < rows_n; ++row) {\r\n            for (let col = 0; col < cols_n; ++col) {\r\n                const entry = graph.entry(row, col);\r\n                if (entry !== 0) {\r\n                    rows.push(row);\r\n                    cols.push(col);\r\n                    data.push(entry);\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            \"rows\": rows, \r\n            \"cols\": cols, \r\n            \"data\": data\r\n        };\r\n    }\r\n\r\n    init() {\r\n        const [ a, b ] = this._find_ab_params(this._spread, this._min_dist);\r\n        this._a = a;\r\n        this._b = b;\r\n        this._graph = this._fuzzy_simplicial_set(this.X, this._n_neighbors);\r\n        const { rows, cols, data: weights } = this._tocoo(this._graph);\r\n        this._head = rows;\r\n        this._tail = cols;\r\n        this._weights = weights;\r\n        this._epochs_per_sample = this._make_epochs_per_sample(this._n_epochs);\r\n        this._epochs_per_negative_sample = this._epochs_per_sample.map(d => d * this._negative_sample_rate);\r\n        this._epoch_of_next_sample = this._epochs_per_sample.slice();\r\n        this._epoch_of_next_negative_sample = this._epochs_per_negative_sample.slice();\r\n        return this;\r\n    }\r\n\r\n    set local_connectivity(value) {\r\n        this._local_connectivity = value;\r\n    }\r\n\r\n    get local_connectivity() {\r\n        return this._local_connectivity;\r\n    }\r\n\r\n    set min_dist(value) {\r\n        this._min_dist = value;\r\n    }\r\n\r\n    get min_dist() {\r\n        return this._min_dist;\r\n    }\r\n\r\n    graph() {\r\n        this.check_init();\r\n        return { cols: this._head, rows: this._tail, weights: this._weights };\r\n    }\r\n\r\n    transform(iterations) {\r\n        this.check_init();\r\n        iterations = iterations || this._n_epochs;\r\n        for (let i = 0; i < iterations; ++i) {\r\n            this.next();\r\n        }\r\n        return this.projection;\r\n    }\r\n\r\n    * generator() {\r\n        this.check_init();\r\n        this._iter = 0\r\n        while (this._iter < this._n_epochs) {\r\n            this.next();\r\n            yield this.projection;\r\n        }\r\n        return this.projection;\r\n    }\r\n\r\n    _clip(x) {\r\n        if (x > 4) return 4;\r\n        if (x < -4) return -4;\r\n        return x;\r\n    }\r\n\r\n    _optimize_layout(head_embedding, tail_embedding, head, tail) {\r\n        const { \r\n            _d: dim, \r\n            _alpha: alpha, \r\n            _repulsion_strength: repulsion_strength, \r\n            _a: a, \r\n            _b: b,\r\n            _epochs_per_sample: epochs_per_sample,\r\n            _epochs_per_negative_sample: epochs_per_negative_sample,\r\n            _epoch_of_next_negative_sample: epoch_of_next_negative_sample,\r\n            _epoch_of_next_sample: epoch_of_next_sample,\r\n            _clip: clip\r\n        } = this;\r\n        const tail_length = tail.length;\r\n\r\n        for (let i = 0, n = epochs_per_sample.length; i < n; ++i) {\r\n            if (epoch_of_next_sample[i] <= this._iter) {\r\n                const j = head[i];\r\n                const k = tail[i];\r\n                const current = head_embedding.row(j);\r\n                const other = tail_embedding.row(k);\r\n                const dist = euclidean_squared(current, other)//this._metric(current, other);\r\n                let grad_coeff = 0;\r\n                if (dist > 0) {\r\n                    grad_coeff = (-2 * a * b * Math.pow(dist, b - 1)) / (a * Math.pow(dist, b) + 1);\r\n                }\r\n                for (let d = 0; d < dim; ++d) {\r\n                    const grad_d = clip(grad_coeff * (current[d] - other[d])) * alpha;\r\n                    const c = current[d] + grad_d;\r\n                    const o = other[d] - grad_d;\r\n                    current[d] = c;\r\n                    other[d] = o;\r\n                    head_embedding.set_entry(j, d, c);\r\n                    tail_embedding.set_entry(k, d, o);\r\n                }\r\n                epoch_of_next_sample[i] += epochs_per_sample[i];\r\n                const n_neg_samples = (this._iter - epoch_of_next_negative_sample[i]) / epochs_per_negative_sample[i];\r\n                for (let p = 0; p < n_neg_samples; ++p) {\r\n                    const k = Math.floor(this._randomizer.random * tail_length);\r\n                    const other = tail_embedding.row(tail[k]);\r\n                    const dist = euclidean_squared(current, other)//this._metric(current, other);\r\n                    let grad_coeff = 0;\r\n                    if (dist > 0) {\r\n                        grad_coeff = (2 * repulsion_strength * b) / ((.01 + dist) * (a * Math.pow(dist, b) + 1));\r\n                    } else if (j === k) {\r\n                        continue;\r\n                    }\r\n                    for (let d = 0; d < dim; ++d) {\r\n                        const grad_d = clip(grad_coeff * (current[d] - other[d])) * alpha;\r\n                        const c = current[d] + grad_d;\r\n                        const o = other[d] - grad_d;\r\n                        current[d] = c;\r\n                        other[d] = o;\r\n                        head_embedding.set_entry(j, d, c);\r\n                        tail_embedding.set_entry(tail[k], d, o);\r\n                    }\r\n                }\r\n                epoch_of_next_negative_sample[i] += (n_neg_samples * epochs_per_negative_sample[i]);\r\n            }\r\n        }\r\n        return head_embedding;\r\n    }\r\n\r\n    next() {\r\n        let iter = ++this._iter;\r\n        let Y = this.Y;\r\n\r\n        this._alpha = (this._initial_alpha * (1 - iter / this._n_epochs));\r\n        this.Y = this._optimize_layout(Y, Y, this._head, this._tail);\r\n\r\n        return this.Y;\r\n    }\r\n} ","import { Matrix, linspace } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { PCA } from \"./PCA\";\r\nimport { BallTree } from \"../knn/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\n/**\r\n * @class\r\n * @alias TriMap\r\n */\r\nexport class TriMap extends DR{\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias TriMap\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {Number} [weight_adj = 500] - scaling factor.\r\n     * @param {Number} [c = 5] - number of triplets multiplier.\r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     * @returns {TriMap}\r\n     * @see {@link https://arxiv.org/pdf/1910.00204v1.pdf}\r\n     * @see {@link https://github.com/eamid/trimap}\r\n     */\r\n    constructor(X, weight_adj = 500, c = 5, d = 2, metric = euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"weight_adj\", \"c\"];\r\n        this.parameter(\"weight_adj\", weight_adj);\r\n        this.parameter(\"c\", c)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Matrix} [pca = null] - Initial Embedding (if null then PCA gets used). \r\n     * @param {KNN} [knn = null] - KNN Object (if null then BallTree gets used). \r\n     */\r\n    init(pca = null, knn = null) {\r\n        const X = this.X;\r\n        const N = X.shape[0];\r\n        const d = this._d;\r\n        const metric = this._metric;\r\n        const c = this._c;\r\n        this.n_inliers = 2 * c;\r\n        this.n_outliers = 1 * c;\r\n        this.n_random = 1 * c;\r\n        this.Y = pca || new PCA(X, d).transform()//.mult(.01);\r\n        this.knn = knn || new BallTree(X.to2dArray, metric);\r\n        const {triplets, weights} = this._generate_triplets(this.n_inliers, this.n_outliers, this.n_random);\r\n        this.triplets = triplets;\r\n        this.weights = weights;\r\n        this.lr = 1000 * N / triplets.shape[0];\r\n        this.C = Infinity;\r\n        this.tol = 1e-7;\r\n        this.vel = new Matrix(N, d, 0);\r\n        this.gain = new Matrix(N, d, 1);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Generates {@link n_inliers} x {@link n_outliers} x {@link n_random} triplets.\r\n     * @param {Number} n_inliers \r\n     * @param {Number} n_outliers \r\n     * @param {Number} n_random \r\n     */\r\n    _generate_triplets(n_inliers, n_outliers, n_random) {\r\n        const metric = this._metric;\r\n        const weight_adj = this._weight_adj;\r\n        const X = this.X;\r\n        const N = X.shape[0];\r\n        const knn = this.knn;\r\n        const n_extra = Math.min(n_inliers + 20, N);\r\n        const nbrs = new Matrix(N, n_extra);\r\n        const knn_distances = new Matrix(N, n_extra);\r\n        for (let i = 0; i < N; ++i) {\r\n            knn.search(X.row(i), n_extra + 1)\r\n                .raw_data()\r\n                .filter(d => d.value != 0)\r\n                .sort((a, b) => a.value - b.value)\r\n                .forEach((d, j) => {\r\n                    nbrs.set_entry(i, j, d.element.index)\r\n                    knn_distances.set_entry(i, j, d.value)\r\n                });\r\n        }\r\n        // scale parameter\r\n        const sig = new Float64Array(N);\r\n        for (let i = 0; i < N; ++i) {\r\n            sig[i] = Math.max(\r\n                   (knn_distances.entry(i, 3) +\r\n                    knn_distances.entry(i, 4) +\r\n                    knn_distances.entry(i, 5) +\r\n                    knn_distances.entry(i, 6)) / 4,\r\n                    1e-10);\r\n        }\r\n        \r\n        const P = this._find_p(knn_distances, sig, nbrs);\r\n        \r\n        let triplets = this._sample_knn_triplets(P, nbrs, n_inliers, n_outliers);\r\n        let n_triplets = triplets.shape[0];\r\n        const outlier_distances = new Float64Array(n_triplets);\r\n        for (let i = 0; i < n_triplets; ++i) {\r\n            const j = triplets.entry(i, 0);\r\n            const k = triplets.entry(i, 2);\r\n            outlier_distances[i] = metric(X.row(j), X.row(k));\r\n        }\r\n        let weights = this._find_weights(triplets, P, nbrs, outlier_distances, sig);\r\n        \r\n        if (n_random > 0) {\r\n            const {random_triplets, random_weights} = this._sample_random_triplets(X, n_random, sig);\r\n            triplets = triplets.concat(random_triplets, \"vertical\");\r\n            weights = Float64Array.from([...weights, ...random_weights])\r\n        }\r\n        n_triplets = triplets.shape[0];\r\n        let max_weight = -Infinity;\r\n        for (let i = 0; i < n_triplets; ++i) {\r\n            if (isNaN(weights[i])) {weights[i] = 0;}\r\n            if (max_weight < weights[i]) max_weight = weights[i];\r\n        }\r\n        let max_weight_2 = -Infinity;\r\n        for (let i = 0; i < n_triplets; ++i) {\r\n            weights[i] /= max_weight;\r\n            weights[i] += .0001;\r\n            weights[i] = Math.log(1 + weight_adj * weights[i]);\r\n            if (max_weight_2 < weights[i]) max_weight_2 = weights[i];\r\n        }\r\n        for (let i = 0; i < n_triplets; ++i) {\r\n            weights[i] /= max_weight_2;\r\n        }\r\n        return {\r\n            \"triplets\": triplets,\r\n            \"weights\": weights,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the similarity matrix P\r\n     * @private\r\n     * @param {Matrix} knn_distances - matrix of pairwise knn distances\r\n     * @param {Float64Array} sig - scaling factor for the distances\r\n     * @param {Matrix} nbrs - nearest neighbors\r\n     * @returns {Matrix} pairwise similarity matrix\r\n     */\r\n    _find_p(knn_distances, sig, nbrs) {\r\n        const [N, n_neighbors] = knn_distances.shape;\r\n        return new Matrix(N, n_neighbors, (i, j) => {\r\n            return Math.exp(-((knn_distances.entry(i, j) ** 2) / sig[i] / sig[nbrs.entry(i, j)]));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sample nearest neighbors triplets based on the similarity values given in P.\r\n     * @private\r\n     * @param {Matrix} P - Matrix of pairwise similarities between each point and its neighbors given in matrix nbrs.\r\n     * @param {Matrix} nbrs - Nearest neighbors indices for each point. The similarity values are given in matrix {@link P}. Row i corresponds to the i-th point.\r\n     * @param {Number} n_inliers - Number of inlier points.\r\n     * @param {Number} n_outliers - Number of outlier points.\r\n     * \r\n     */\r\n    _sample_knn_triplets(P, nbrs, n_inliers, n_outliers) {\r\n        const N = nbrs.shape[0];\r\n        const triplets = new Matrix(N * n_inliers * n_outliers, 3);\r\n        for (let i = 0; i < N; ++i) {\r\n            let n_i = i * n_inliers * n_outliers;\r\n            const sort_indices = this.__argsort(P.row(i).map(d => -d));\r\n            for (let j = 0; j < n_inliers; ++j) {\r\n                let n_j = j * n_outliers;\r\n                const sim = nbrs.entry(i, sort_indices[j]);\r\n                const samples = this._rejection_sample(n_outliers, N, sort_indices.slice(0, j + 1));\r\n                for (let k = 0; k < n_outliers; ++k) {\r\n                    const index = n_i + n_j + k;\r\n                    const out = samples[k];\r\n                    triplets.set_entry(index, 0, i);\r\n                    triplets.set_entry(index, 1, sim);\r\n                    triplets.set_entry(index, 2, out);\r\n                }\r\n            }\r\n        }\r\n        return triplets;\r\n    }\r\n\r\n    /**\r\n     * Should do the same as np.argsort()\r\n     * @private\r\n     * @param {Array} A \r\n     */\r\n    __argsort(A) {\r\n        return A\r\n            .map((d, i) => {return {d: d, i: i};})\r\n            .sort((a, b) => a.d - b.d)\r\n            .map((d) => d.i);\r\n    }\r\n\r\n    /**\r\n     * Samples {@link n_samples} integers from a given interval [0, {@link max_int}] while rejection the values that are in the {@link rejects}.\r\n     * @private\r\n     * @param {*} n_samples \r\n     * @param {*} max_int \r\n     * @param {*} rejects \r\n     */\r\n    _rejection_sample(n_samples, max_int, rejects) {\r\n        const randomizer = this._randomizer;\r\n        const interval = linspace(0, max_int - 1).filter(d => rejects.indexOf(d) < 0);\r\n        return randomizer.choice(interval, Math.min(n_samples, interval.length - 2));\r\n    }\r\n\r\n    /**\r\n     * Calculates the weights for the sampled nearest neighbors triplets\r\n     * @private\r\n     * @param {Matrix} triplets - Sampled Triplets.\r\n     * @param {Matrix} P - Pairwise similarity matrix.\r\n     * @param {Matrix} nbrs - nearest Neighbors\r\n     * @param {Float64Array} outlier_distances - Matrix of pairwise outlier distances\r\n     * @param {Float64Array} sig - scaling factor for the distances.\r\n     */\r\n    _find_weights(triplets, P, nbrs, outlier_distances, sig) {\r\n        const n_triplets = triplets.shape[0];\r\n        const weights = new Float64Array(n_triplets);\r\n        for (let t = 0; t < n_triplets; ++t) {\r\n            const i = triplets.entry(t, 0);\r\n            const sim = nbrs.row(i).indexOf(triplets.entry(t, 1));\r\n            const p_sim = P.entry(i, sim);\r\n            let p_out = Math.exp(-(outlier_distances[t] ** 2 / (sig[i] * sig[triplets.entry(t, 2)])));\r\n            if (p_out < 1e-20) p_out = 1e-20;\r\n            weights[t] = p_sim / p_out;\r\n        }\r\n        return weights;\r\n    }\r\n\r\n    /**\r\n     * Sample uniformly ranom triplets\r\n     * @private\r\n     * @param {Matrix} X - Data matrix.\r\n     * @param {Number} n_random - Number of random triplets per point\r\n     * @param {Float64Array} sig - Scaling factor for the distances\r\n     */\r\n    _sample_random_triplets(X, n_random, sig) {\r\n        const metric = this._metric;\r\n        const randomizer = this._randomizer;\r\n        const N = X.shape[0];\r\n        const random_triplets = new Matrix(N * n_random, 3);\r\n        const random_weights = new Float64Array(N * n_random);\r\n        for (let i = 0; i < N; ++i) {\r\n            const n_i = i * n_random;\r\n            const indices = [...linspace(0, i - 1), ...linspace(i + 1, N - 1)]\r\n            for (let j = 0; j < n_random; ++j) {\r\n                let [sim, out] = randomizer.choice(indices, 2);\r\n                let p_sim = Math.exp(-((metric(X.row(i), X.row(sim)) ** 2) / (sig[i] * sig[sim])));\r\n                if (p_sim < 1e-20) p_sim = 1e-20;\r\n                let p_out = Math.exp(-((metric(X.row(i), X.row(out)) ** 2) / (sig[i] * sig[out]))); \r\n                if (p_out < 1e-20) p_out = 1e-20;\r\n\r\n                if (p_sim < p_out) {\r\n                    [sim, out] = [out, sim];\r\n                    [p_sim, p_out] = [p_out, p_sim];\r\n                }\r\n                const index = n_i + j;\r\n                random_triplets.set_entry(index, 0, i);\r\n                random_triplets.set_entry(index, 1, sim);\r\n                random_triplets.set_entry(index, 2, out);\r\n                random_weights[index] = p_sim / p_out;\r\n            }\r\n        }\r\n        return {\r\n            \"random_triplets\": random_triplets,\r\n            \"random_weights\": random_weights,\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes the gradient for updating the embedding.\r\n     * @param {Matrix} Y - The embedding\r\n     */\r\n    _grad(Y) {\r\n        const n_inliers = this.n_inliers;\r\n        const n_outliers = this.n_outliers;\r\n        const triplets = this.triplets;\r\n        const weights = this.weights;\r\n        const [N, dim] = Y.shape;\r\n        const n_triplets = triplets.shape[0];\r\n        const grad = new Matrix(N, dim, 0);\r\n        let y_ij = new Array(dim).fill(0);\r\n        let y_ik = new Array(dim).fill(0);\r\n        let d_ij = 1;\r\n        let d_ik = 1;\r\n        let n_viol = 0;\r\n        let loss = 0;\r\n        const n_knn_triplets = N * n_inliers * n_outliers;\r\n\r\n        for (let t = 0; t < n_triplets; ++t) {\r\n            const [i, j, k] = triplets.row(t);\r\n            // update y_ij, y_ik, d_ij, d_ik\r\n            if (t % n_outliers == 0 || t >= n_knn_triplets) {\r\n                d_ij = 1\r\n                d_ik = 1\r\n                for (let d = 0; d < dim; ++d) {\r\n                    const Y_id = Y.entry(i, d);\r\n                    const Y_jd = Y.entry(j, d);\r\n                    const Y_kd = Y.entry(k, d);\r\n                    y_ij[d] = Y_id - Y_jd;\r\n                    y_ik[d] = Y_id - Y_kd;\r\n                    d_ij += (y_ij[d] ** 2);\r\n                    d_ik += (y_ik[d] ** 2);\r\n                }\r\n            // update y_ik and d_ik only\r\n            } else {\r\n                d_ik = 1;\r\n                for (let d = 0; d < dim; ++d) {\r\n                    const Y_id = Y.entry(i, d);\r\n                    const Y_kd = Y.entry(k, d);\r\n                    y_ik[d] = Y_id - Y_kd;\r\n                    d_ik += (y_ik[d] ** 2);\r\n                }\r\n            }\r\n\r\n            if (d_ij > d_ik) ++n_viol;\r\n            loss += weights[t] / (1 + d_ik / d_ij);\r\n            const w = (weights[t] / (d_ij + d_ik)) ** 2;\r\n            for (let d = 0; d < dim; ++d) {\r\n                const gs = y_ij[d] * d_ik * w;\r\n                const go = y_ik[d] * d_ij * w;\r\n                grad.set_entry(i, d, grad.entry(i, d) + gs - go);\r\n                grad.set_entry(j, d, grad.entry(j, d) - gs);\r\n                grad.set_entry(k, d, grad.entry(k, d) + go);\r\n            }\r\n        }\r\n        return {\r\n            \"grad\": grad,\r\n            \"loss\": loss,\r\n            \"n_viol\": n_viol,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Number} max_iteration \r\n     */\r\n    transform(max_iteration = 400) {\r\n        this.check_init();\r\n        for (let iter = 0; iter < max_iteration; ++iter) {\r\n            this._next(iter)\r\n        }\r\n        return this.projection;\r\n    }\r\n\r\n    /**\r\n     * @yields {Matrix}\r\n     * @returns {Matrix}\r\n     */\r\n    * generator() {\r\n        this.check_init();\r\n        for (let iter = 0; iter < 800; ++iter) {\r\n            this._next(iter);\r\n            yield this.projection;\r\n        }\r\n        return this.projection;\r\n    }\r\n\r\n    /**\r\n     * Does the iteration step.\r\n     * @private\r\n     * @param {Number} iter \r\n     */\r\n    _next(iter) {\r\n        const gamma = iter > 150 ? .5 : .3;\r\n        const old_C = this.C;\r\n        const vel = this.vel;\r\n        const Y = this.Y.add(vel.mult(gamma));\r\n        const {grad, loss, n_viol} = this._grad(Y);\r\n        this.C = loss;\r\n        this.Y = this._update_embedding(Y, iter, grad);\r\n        this.lr *= (old_C > loss + this.tol)  ? 1.01 : .9;\r\n        return this.Y;\r\n    }\r\n\r\n    /**\r\n     * Updates the embedding.\r\n     * @private\r\n     * @param {Matrix} Y \r\n     * @param {Number} iter \r\n     * @param {Matrix} grad \r\n     */\r\n    _update_embedding(Y, iter, grad) {\r\n        const [N, dim] = Y.shape;\r\n        const gamma = iter > 150 ? .9 : .5; // moment parameter\r\n        const min_gain = .01;\r\n        const gain = this.gain;\r\n        const vel = this.vel;\r\n        const lr = this.lr;\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let d = 0; d < dim; ++d) {\r\n                const new_gain = (Math.sign(vel.entry(i, d)) != Math.sign(grad.entry(i, d))) ? gain.entry(i, d) + .2 : Math.max(gain.entry(i, d) * .8, min_gain);\r\n                gain.set_entry(i, d, new_gain);\r\n                vel.set_entry(i, d, gamma * vel.entry(i, d) - lr * gain.entry(i, d) * grad.entry(i, d));\r\n                Y.set_entry(i, d, Y.entry(i, d) + vel.entry(i, d));\r\n            }\r\n        }\r\n        return Y;\r\n    }\r\n}","import { euclidean } from \"../metrics/index\";\r\n\r\n/**\r\n * @class\r\n * @alias Hierarchical_Clustering\r\n */\r\nexport class Hierarchical_Clustering {\r\n    /**\r\n     * @constructor\r\n     * @memberof module:clustering\r\n     * @alias Hierarchical_Clustering\r\n     * @todo needs restructuring. \r\n     * @param {Matrix} matrix \r\n     * @param {(\"single\"|\"complete\"|\"average\")} [linkage = \"single\"] \r\n     * @param {Function} [metric = euclidean] \r\n     * @returns {Hierarchical_Clustering}\r\n     */\r\n    constructor(matrix, linkage=\"single\", metric=euclidean) {\r\n        this._id = 0;\r\n        this._matrix = matrix;\r\n        this._metric = metric;\r\n        this._linkage = linkage;\r\n        this.init();\r\n        this.root = this.do();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {Number} value - value where to cut the tree.\r\n     * @param {(\"distance\"|\"depth\")} [type = \"distance\"] - type of value.\r\n     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.\r\n     */\r\n    get_clusters(value, type=\"distance\") {\r\n        let clusters = [];\r\n        let accessor;\r\n        switch (type) {\r\n            case \"distance\":\r\n                accessor = d => d.dist;\r\n                break;\r\n            case \"depth\":\r\n                accessor = d => d.depth;\r\n                break;\r\n            default:\r\n                throw \"invalid type\";\r\n        }\r\n        this._traverse(this.root, accessor, value, clusters)\r\n        return clusters\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {} node \r\n     * @param {*} f \r\n     * @param {*} value \r\n     * @param {*} result \r\n     */\r\n    _traverse(node, f, value, result) {\r\n        if (f(node) <= value) {\r\n            result.push(node.leaves())\r\n        } else {\r\n            this._traverse(node.left, f, value, result);\r\n            this._traverse(node.right, f, value, result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * computes the tree.\r\n     */\r\n    init() {\r\n        const metric = this._metric;\r\n        const A = this._matrix;\r\n        const n = this._n = A.shape[0];\r\n        const d_min = this._d_min = new Float64Array(n);\r\n        const distance_matrix = this._distance_matrix = new Array(n);\r\n        for (let i = 0; i < n; ++i) {\r\n            d_min[i] = 0;\r\n            distance_matrix[i] = new Float64Array(n);\r\n            for (let j = 0; j < n; ++j) {\r\n                distance_matrix[i][j] = i === j ? Infinity : metric(A.row(i), A.row(j))\r\n                if (distance_matrix[i][d_min[i]] > distance_matrix[i][j]) {\r\n                    d_min[i] = j;\r\n                }\r\n            }\r\n        }\r\n        const clusters = this._clusters = new Array(n);\r\n        const c_size = this._c_size = new Uint16Array(n);\r\n        for (let i = 0; i < n; ++i) {\r\n            clusters[i] = [];\r\n            clusters[i][0] = new Cluster(this._id++, null, null, 0, A.row(i), i, 1, 0);\r\n            c_size[i] = 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * computes the tree.\r\n     */\r\n    do() {\r\n        const n = this._n;\r\n        const d_min = this._d_min;\r\n        const D = this._distance_matrix;\r\n        const clusters = this._clusters;\r\n        const c_size = this._c_size;\r\n        const linkage = this._linkage;\r\n        let root = null;\r\n        for (let p = 0, p_max = n - 1; p < p_max; ++p) {\r\n            let c1 = 0;\r\n            for (let i = 0; i < n; ++i) {\r\n                if (D[i][d_min[i]] < D[c1][d_min[c1]]) {\r\n                    c1 = i;\r\n                }\r\n            }\r\n            let c2 = d_min[c1];\r\n            let c1_cluster = clusters[c1][0];\r\n            let c2_cluster = clusters[c2][0];\r\n            let new_cluster = new Cluster(this._id++, c1_cluster, c2_cluster, D[c1][c2]);\r\n            clusters[c1].unshift(new_cluster);\r\n            c_size[c1] += c_size[c2];\r\n            for (let j = 0; j < n; ++j) {\r\n                switch(linkage) {\r\n                    case \"single\":\r\n                        if (D[c1][j] > D[c2][j]) {\r\n                            D[j][c1] = D[c1][j] = D[c2][j];\r\n                        }\r\n                        break;\r\n                    case \"complete\":\r\n                        if (D[c1][j] < D[c2][j]) {\r\n                            D[j][c1] = D[c1][j] = D[c2][j];\r\n                        }\r\n                        break;\r\n                    case \"average\":\r\n                        D[j][c1] = D[c1][j] = (c_size[c1] * D[c1][j] + c_size[c2] * D[c2][j]) / (c_size[c1] + c_size[j]);\r\n                        break;\r\n                }\r\n            }\r\n            D[c1][c1] = Infinity;\r\n            for (let i = 0; i < n; ++i) {\r\n                D[i][c2] = D[c2][i] = Infinity;\r\n            }\r\n            for (let j = 0; j < n; ++j) {\r\n                if (d_min[j] === c2) {\r\n                    d_min[j] = c1;\r\n                }\r\n                if (D[c1][j] < D[c1][d_min[c1]]) {\r\n                    d_min[c1] = j;\r\n                }\r\n            }\r\n            root = new_cluster\r\n        }\r\n        return root;\r\n    }\r\n    \r\n}\r\n\r\nclass Cluster {\r\n    constructor(id, left, right, dist, centroid, index, size, depth) {\r\n        this.id = id;\r\n        this.left = left;\r\n        this.right = right;\r\n        this.dist = dist;\r\n        this.index = index;\r\n        this.size = size != null ? size : left.size + right.size;\r\n        this.depth = depth != null ? depth : 1 + Math.max(left.depth, right.depth);\r\n        this.centroid = centroid != null ? centroid : this._calculate_centroid(left, right);\r\n        return this;\r\n    }\r\n\r\n    _calculate_centroid(left, right) {\r\n        const l_size = left.size;\r\n        const r_size = right.size;\r\n        const l_centroid = left.centroid;\r\n        const r_centroid = right.centroid;\r\n        const size = this.size;\r\n        const n = left.centroid.length;\r\n        const new_centroid = new Float64Array(n);\r\n        for (let i = 0; i < n; ++i) {\r\n            new_centroid[i] = (l_size * l_centroid[i] + r_size * r_centroid[i]) / size;\r\n        }\r\n        return new_centroid;\r\n    }\r\n\r\n    get isLeaf() {\r\n        return this.depth === 0;\r\n    }\r\n\r\n    leaves() {\r\n        if (this.isLeaf) return [this.index];\r\n        const left = this.left;\r\n        const right = this.right;\r\n        return (left.isLeaf ? [left.index] : left.leaves())\r\n            .concat(right.isLeaf ? [right.index] : right.leaves())\r\n    }\r\n}","import { euclidean } from \"../metrics/index\";\r\nimport { Randomizer } from \"../util/index\";\r\nimport { Heap } from \"../datastructure/index\";\r\nimport { linspace } from \"../matrix/index\";\r\n\r\n/**\r\n * @class\r\n * @alias KMeans\r\n */\r\nexport class KMeans {\r\n    /**\r\n     * @constructor\r\n     * @memberof module:clustering\r\n     * @alias KMeans\r\n     * @todo needs restructuring. \r\n     * @param {Matrix} matrix \r\n     * @param {Numbers} K \r\n     * @param {Function} [metric = euclidean] \r\n     * @param {Number} [seed = 1987]\r\n     * @param {Boolean} [init = true]\r\n     * @returns {KMeans}\r\n     */\r\n    constructor(matrix, K, metric = euclidean, seed=1987, init = true) {\r\n        this._metric = metric;\r\n        this._matrix = matrix;\r\n        this._K = K;\r\n        const [N, D] = matrix.shape;\r\n        this._N = N;\r\n        this._D = D;\r\n        if (K > N) K = N;\r\n        this._randomizer = new Randomizer(seed);\r\n        this._clusters = new Array(N).fill(undefined);\r\n        this._cluster_centroids = this._get_random_centroids(K);\r\n        if (init) this.init(K, this._cluster_centroids);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. \r\n     */\r\n    get_clusters() {\r\n        const K = this._K;\r\n        const clusters = this._clusters;\r\n        const result = new Array(K).fill().map(() => new Array());\r\n        clusters.forEach((c, i) => result[c].push(i));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array} points \r\n     * @param {Array} candidates \r\n     */\r\n    _furthest_point(points, candidates) {\r\n        const A = this._matrix;\r\n        const metric = this._metric;\r\n        let i = points.length;\r\n        let H = Heap.heapify(\r\n            candidates, \r\n            (d) => {\r\n                const Ad = A.row(d)\r\n                let sum = 0;\r\n                for (let j = 0; j < i; ++j) {\r\n                    sum += metric(Ad, points[j])\r\n                }\r\n                return sum;\r\n            }, \r\n            \"max\"\r\n        )\r\n        return H.pop().element;\r\n    }\r\n\r\n    _get_random_centroids(K) {\r\n        const N = this._N;\r\n        const randomizer = this._randomizer;\r\n        const A = this._matrix;\r\n        const cluster_centroids = new Array(K).fill()\r\n        const indices = linspace(0, N - 1);\r\n        const random_point = randomizer.random_int % (N - 1);\r\n        cluster_centroids[0] = A.row(random_point);\r\n        const init_points = [random_point];\r\n        const sample_size = Math.floor((N - K) / K);// / K\r\n        for (let i = 1; i < K; ++i) {\r\n            // sampling + kmeans++ improvement?\r\n            const sample = randomizer.choice(indices.filter(d => init_points.indexOf(d) == -1), sample_size);\r\n            const furthest_point = this._furthest_point(cluster_centroids.slice(0, i), sample);\r\n            init_points.push(furthest_point);\r\n            cluster_centroids[i] = A.row(furthest_point);\r\n        }\r\n        return cluster_centroids;\r\n    }\r\n\r\n    _iteration(cluster_centroids) {\r\n        const K = cluster_centroids.length;\r\n        const N = this._N;\r\n        const D = this._D;\r\n        const A = this._matrix;\r\n        const metric = this._metric;\r\n        const clusters = this._clusters;\r\n        let clusters_changed = false;\r\n        // find nearest cluster centroid.\r\n        for (let i = 0; i < N; ++i) {\r\n            const Ai = A.row(i)\r\n            let min_dist = Infinity;\r\n            let min_cluster = null;\r\n            for (let j = 0; j < K; ++j) {\r\n                let d = metric(cluster_centroids[j], Ai);\r\n                if (d < min_dist) {\r\n                    min_dist = d;\r\n                    min_cluster = j; \r\n                }\r\n            }\r\n            if (clusters[i] !== min_cluster) {\r\n                clusters_changed = true;\r\n            }\r\n            clusters[i] = min_cluster;\r\n        }\r\n        // update cluster centroid\r\n        // reset cluster centroids to 0\r\n        for (let i = 0; i < K; ++i) {\r\n            const centroid = cluster_centroids[i];\r\n            for (let j = 0; j < D; ++j) {\r\n                centroid[j] = 0;\r\n            }\r\n        }\r\n        // compute centroid\r\n        this._compute_centroid(cluster_centroids);\r\n\r\n        return {   \r\n            \"clusters_changed\": clusters_changed,\r\n            \"cluster_centroids\": cluster_centroids\r\n        };\r\n    }\r\n\r\n    _compute_centroid(cluster_centroids) {\r\n        const K = cluster_centroids.length;\r\n        const N = this._N;\r\n        const D = this._D;\r\n        const A = this._matrix;\r\n        const clusters = this._clusters;\r\n        const cluster_counter = new Array(K).fill(0);\r\n\r\n        for (let i = 0; i < N; ++i) {\r\n            const Ai = A.row(i);\r\n            const ci = clusters[i];\r\n            cluster_counter[ci]++;\r\n            const centroid = cluster_centroids[ci];\r\n            for (let j = 0; j < D; ++j) {\r\n                centroid[j] += Ai[j];\r\n            }\r\n        }\r\n        for (let i = 0; i < K; ++i) {\r\n            const n = cluster_counter[i];\r\n            cluster_centroids[i] = cluster_centroids[i].map(c => c / n);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * Computes {@link K} clusters out of the {@link matrix}.\r\n     * @param {Number} K - number of clusters.\r\n     */\r\n    init(K, cluster_centroids) {\r\n        if (!K) K = this._K;\r\n        if (!cluster_centroids) cluster_centroids = this._get_random_centroids(K);\r\n        let clusters_changed = false;\r\n        do {\r\n            const iteration_result = this._iteration(cluster_centroids)\r\n            cluster_centroids = iteration_result.cluster_centroids;\r\n            clusters_changed = iteration_result.clusters_changed;\r\n        } while (clusters_changed)\r\n    }\r\n    \r\n}\r\n","import { euclidean } from \"../metrics/index\";\r\nimport { Randomizer } from \"../util/index\";\r\nimport { linspace, Matrix } from \"../matrix/index\";\r\n\r\n/**\r\n * @class\r\n * @alias KMedoids\r\n */\r\nexport class KMedoids {\r\n    /**\r\n     * @constructor\r\n     * @memberof module:clustering\r\n     * @alias KMedoids\r\n     * @todo needs restructuring. \r\n     * @param {Matrix} matrix - data matrix\r\n     * @param {Numbers} K - number of clusters\r\n     * @param {number} [max_iter=null] - maximum number of iterations. Default is 10 * Math.log10(N)\r\n     * @param {Function} [metric = euclidean] - metric defining the dissimilarity \r\n     * @param {Number} [seed = 1212] - seed value for random number generator\r\n     * @returns {KMedoids}\r\n     * @see {@link https://link.springer.com/chapter/10.1007/978-3-030-32047-8_16} Faster k-Medoids Clustering: Improving the PAM, CLARA, and CLARANS Algorithms\r\n     */\r\n    constructor(matrix, K, max_iter=null, metric = euclidean, seed=1212) {\r\n        this._metric = metric;\r\n        this._matrix = matrix;\r\n        this._A = this._matrix.to2dArray;\r\n        this._K = K;\r\n        const [N, D] = matrix.shape;\r\n        this._N = N;\r\n        this._D = D;\r\n        this._max_iter = max_iter || 10 * Math.log10(N) \r\n        this._distance_matrix = new Matrix(N, N, \"zeros\");\r\n        /* for (let i = 1; i < N; ++i) {\r\n            for (let j = i + 1; j < N; ++j) {\r\n                let dist = metric(this._A[i], this._A[j]);\r\n                this._distance_matrix.set_entry(i, j, dist);\r\n                this._distance_matrix.set_entry(j, i, dist)\r\n            }\r\n        } */\r\n        if (K > N) K = N;\r\n        this._randomizer = new Randomizer(seed);\r\n        this._clusters = new Array(N).fill(undefined);\r\n        this._cluster_medoids = this._get_random_medoids(K);\r\n        //if (init) this.init(K, this._cluster_medoids);\r\n        this._is_initialized = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<Array>} - Array of clusters with the indices of the rows in given {@link matrix}. \r\n     */\r\n    get_clusters() {\r\n        const K = this._K;\r\n        const A = this._A;\r\n        if (!this._is_initialized) {\r\n            this.init(K, this._cluster_medoids);\r\n        }\r\n        const result = new Array(K).fill().map(() => new Array());\r\n        A.forEach((x_j, j) => {\r\n            result[this._nearest_medoid(x_j, j).index_nearest].push(j);\r\n        })\r\n        result.medoids = this._cluster_medoids;\r\n        return result;\r\n    }\r\n\r\n    async* generator() {\r\n        const max_iter = this._max_iter;\r\n        yield this.get_clusters()\r\n        let finish = false;\r\n        let i = 0\r\n        do {\r\n            finish = this._iteration();\r\n            yield this.get_clusters();\r\n        } while (!finish && ++i < max_iter)\r\n    }\r\n\r\n    /**\r\n     * Algorithm 1. FastPAM1: Improved SWAP algorithm\r\n     */\r\n    /* _iteration_1() {\r\n        const A = this._A;\r\n        const N = this._N;\r\n        const K = this._K;\r\n        const medoids = this._cluster_medoids;\r\n        let DeltaTD = 0;\r\n        let m0 = null;\r\n        let x0 = null;\r\n        A.forEach((x_j, j) => {\r\n            if (medoids.findIndex(m => m === j) < 0) {\r\n                const nearest_medoid = this._nearest_medoid(x_j, j);\r\n                const d_j = nearest_medoid.distance_nearest; // distance to current medoid\r\n                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid\r\n                A.forEach((x_o, o) => {\r\n                    // disance to new medoid\r\n                    const d_oj = this._get_distance(o, j, x_o, x_j);\r\n                    const {\r\n                        \"index_nearest\": n,\r\n                        \"distance_nearest\": d_n,\r\n                        \"distance_second\": d_s,\r\n                    } = this._nearest_medoid(x_o, o); \r\n                    this._clusters[o] = n; // cached values\r\n                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change\r\n                    if (d_oj < d_n) { // reassignment check\r\n                        deltaTD.forEach((d_i, i) => {\r\n                            if (n !== i) {\r\n                                deltaTD[i] = d_i + d_oj - d_n; // update loss change\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                // choose best medoid i;\r\n                const i = deltaTD\r\n                    .map((d, i) => [d, i])\r\n                    .sort((d1, d2) => d1[0] - d2[0])[0][1];\r\n                const deltaTD_i = deltaTD[i];\r\n                // store\r\n                if (deltaTD_i < DeltaTD) {\r\n                    DeltaTD = deltaTD_i;\r\n                    m0 = i;\r\n                    x0 = j;\r\n                }\r\n            }\r\n        });\r\n\r\n        if (DeltaTD >= 0) {\r\n            return true // break loop if DeltaTD >= 0\r\n        }\r\n        // swap roles of medoid m and non-medoid x;\r\n        medoids[m0] = x0;\r\n        this._cluster_medoids = medoids;\r\n        return false\r\n    } */\r\n\r\n    /** Algorithm 2. FastPAM2: SWAP with multiple candidates\r\n     * \r\n     */\r\n    _iteration() {\r\n        const A = this._A;\r\n        const K = this._K;\r\n        const medoids = this._cluster_medoids;\r\n        const cache = A.map((x_o, o) => this._nearest_medoid(x_o, o));\r\n        // empty best candidates array\r\n        const DeltaTD = new Array(K).fill(0);\r\n        const xs = new Array(K).fill(null);\r\n        A.forEach((x_j, j) => {\r\n            if (medoids.findIndex(m => m === j) < 0) {\r\n                const d_j = cache[j].distance_nearest; // distance to current medoid\r\n                const deltaTD = new Array(K).fill(-d_j); // change if making j a medoid\r\n                A.forEach((x_o, o) => {\r\n                    if (j === o) return;\r\n                    const d_oj = this._get_distance(o, j, x_o, x_j); // distance to new medoid\r\n                    const {\"index_nearest\": n, \"distance_nearest\": d_n, \"distance_second\": d_s} = cache[o]; // cached\r\n                    deltaTD[n] += Math.min(d_oj, d_s) - d_n; // loss change for x_o\r\n                    // Reassignment check\r\n                    if (d_oj < d_n) { \r\n                        // update loss change\r\n                        for (let i = 0; i < K; ++i) {\r\n                            if (i !== n) deltaTD[i] += d_oj - d_n;\r\n                        }\r\n                    }\r\n                });\r\n                // remember best swap for i;\r\n                deltaTD\r\n                    .map((d, i) => [d, i])\r\n                    .filter(([d, i]) => d < DeltaTD[i])\r\n                    .forEach(([d, i]) => {\r\n                        if (d < DeltaTD[i]) {\r\n                            DeltaTD[i] = d;\r\n                            xs[i] = j;\r\n                        }\r\n                    })\r\n            }\r\n        })\r\n        // stop if no improvements were found\r\n        if (Math.min(...DeltaTD) >= 0) return true; \r\n\r\n        // execute all improvements\r\n        while (Math.min(...DeltaTD) < 0) {\r\n            // swap roles of medoid m_i and non_medoid xs_i\r\n            const i = DeltaTD\r\n                .map((d, i) => [d, i])\r\n                .sort(([a], [b]) => a - b)[0][1];\r\n            if (medoids.filter(m => m == xs[i]).length == 0) {\r\n                medoids[i] = xs[i];\r\n            }\r\n            // disable the swap just performed\r\n            DeltaTD[i] = 0; \r\n            // recompute TD for remaining swap candidates\r\n            DeltaTD\r\n                .map((d_j, j) => [d_j, j])\r\n                .filter(([d_j]) => d_j < 0)\r\n                .forEach(([_, j]) => {\r\n                    const x_j = A[j];\r\n                    let sum = 0;\r\n                    A.forEach((x_o, o) => {\r\n                        if (medoids.findIndex(m => m != j && m == o) >= 0) return;\r\n                        if (i == j) return;\r\n                        if (cache[o].index_nearest === medoids[j])\r\n                            sum += (Math.min(this._get_distance(o, j, x_o, x_j), cache[o].distance_second) - cache[o].distance_nearest); \r\n                        else {\r\n                            sum += (Math.min(this._get_distance(o, j, x_o, x_j) - cache[o].distance_nearest, 0));\r\n                        }\r\n                    });\r\n                    DeltaTD[j] = sum;\r\n                })\r\n        }\r\n        this._cluster_medoids = medoids;\r\n        return false;\r\n    }\r\n\r\n    _get_distance(i, j, x_i=null, x_j=null) {\r\n        if (i === j) return 0;\r\n        const D = this._distance_matrix;\r\n        const A = this._A;\r\n        const metric = this._metric;\r\n        let d_ij = D.entry(i, j);\r\n        if (d_ij === 0) {\r\n            d_ij = metric(x_i || A[i], x_j || A[j]);\r\n            D.set_entry(i, j, d_ij);\r\n            D.set_entry(j, i, d_ij);\r\n        }\r\n        return d_ij;\r\n    }\r\n\r\n    _nearest_medoid(x_j, j) {\r\n        const medoids = this._cluster_medoids;\r\n        const A = this._A;\r\n        const [nearest, second] = medoids\r\n            .map((m, i) => {\r\n                const x_m = A[m]; \r\n                return [this._get_distance(j, m, x_j, x_m), i];\r\n            })\r\n            .sort((m1, m2) => m1[0] - m2[0]);\r\n        \r\n        return { \r\n            \"distance_nearest\": nearest[0], \r\n            \"index_nearest\": nearest[1],\r\n            \"distance_second\": second[0],\r\n            \"index_second\": second[1],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Computes {@link K} clusters out of the {@link matrix}.\r\n     * @param {Number} K - number of clusters.\r\n     */\r\n    init(K, cluster_medoids) {\r\n        if (!K) K = this._K;\r\n        if (!cluster_medoids) cluster_medoids = this._get_random_medoids(K);\r\n        const max_iter = this._max_iter;\r\n        let finish = false;\r\n        let i = 0\r\n        do {\r\n            finish = this._iteration();\r\n        } while (!finish && ++i < max_iter)\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Algorithm 3. FastPAM LAB: Linear Approximate BUILD initialization.\r\n     * @param {number} K - number of clusters\r\n     * \r\n     */\r\n    _get_random_medoids(K) {\r\n        const N = this._N;\r\n        const A = this._A;\r\n        const indices = linspace(0, N - 1);\r\n        const randomizer = this._randomizer;\r\n        const n = Math.min(N, 10 + Math.ceil(Math.sqrt(N)));\r\n        const TD = new Array(n).fill(Infinity);\r\n        const medoids = [];\r\n        // first medoid\r\n        let TD0 = Infinity;\r\n        let S = randomizer.choice(indices, n);\r\n        for (let j = 0; j < n; ++j) {\r\n            const S_j = S[j];\r\n            const x_j = A[S_j];\r\n            for (let o = 0; o < n; ++o) {\r\n                if (o === j) continue;\r\n                const x_o = A[S[o]];\r\n                TD[j] += this._get_distance(j, o, x_j, x_o);\r\n            }\r\n            if (TD[j] < TD0) {\r\n                TD0 = TD[j]; // smallest distance sum\r\n                medoids.push(S_j);\r\n            }\r\n        }\r\n        // other medoids\r\n        for (let i = 1; i < K; ++i) {\r\n            let DeltaTD = Infinity;\r\n            S = randomizer.choice(indices.filter(index => medoids.findIndex(d => d === index) < 0), n);\r\n            for (let j = 0; j < n; ++j) {\r\n                let deltaTD = 0;\r\n                const S_j = S[j];\r\n                const x_j = A[S_j];\r\n                for (let o = 0; o < n; ++o) {\r\n                    if (o === j) continue;\r\n                    const S_o = S[o];\r\n                    const x_o = A[S_o];\r\n                    let delta = this._get_distance(S_j, S_o, x_j, x_o) - Math.min(...medoids.map(m => this._get_distance(S_o, m, x_o)));\r\n                    if (delta < 0) {\r\n                        deltaTD = deltaTD + delta;\r\n                    }\r\n                }\r\n                // best reduction\r\n                if (deltaTD < DeltaTD) {\r\n                    DeltaTD = deltaTD;\r\n                    medoids.push(S_j);\r\n                }\r\n            }\r\n            TD0 += DeltaTD;\r\n        }\r\n        return medoids.slice(0, K);\r\n    }\r\n    \r\n}\r\n","import { euclidean } from \"../metrics/index\";\r\nimport { Heap } from \"../datastructure/index\";\r\n\r\n/**\r\n * @class\r\n * @alias OPTICS\r\n */\r\nexport class OPTICS {\r\n    /**\r\n     * **O**rdering **P**oints **T**o **I**dentify the **C**lustering **S**tructure.\r\n     * @constructor\r\n     * @memberof module:clustering\r\n     * @alias OPTICS\r\n     * @todo needs restructuring. \r\n     * @param {Matrix} matrix - the data.\r\n     * @param {Number} epsilon - the minimum distance which defines whether a point is a neighbor or not.\r\n     * @param {Number} min_points - the minimum number of points which a point needs to create a cluster. (Should be higher than 1, else each point creates a cluster.)\r\n     * @param {Function} [metric = euclidean] - the distance metric which defines the distance between two points of the {@link matrix}.\r\n     * @returns {OPTICS}\r\n     * @see {@link https://www.dbs.ifi.lmu.de/Publikationen/Papers/OPTICS.pdf}\r\n     * @see {@link https://en.wikipedia.org/wiki/OPTICS_algorithm}\r\n     */\r\n    constructor(matrix, epsilon, min_points, metric = euclidean) {\r\n        this._matrix = matrix;\r\n        this._epsilon = epsilon;\r\n        this._min_points = min_points;\r\n        this._metric = metric;\r\n\r\n        this._ordered_list = [];\r\n        this._clusters = [];\r\n        this._DB = new Array(matrix.shape[0]).fill();\r\n        this.init();\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Computes the clustering.\r\n     */\r\n    init() {\r\n        const ordered_list = this._ordered_list;\r\n        const matrix = this._matrix;\r\n        const N = matrix.shape[0];\r\n        const DB = this._DB;\r\n        const clusters = this._clusters;\r\n        let cluster_index = this._cluster_index = 0;\r\n\r\n        for (let i = 0; i < N; ++i) {\r\n            DB[i] = {\r\n                \"element\": matrix.row(i),\r\n                \"index\": i,\r\n                \"reachability_distance\": undefined,\r\n                \"processed\": false,\r\n            }\r\n        }\r\n        for (const p of DB) {\r\n            if (p.processed) continue;\r\n            p.neighbors = this._get_neighbors(p);\r\n            p.processed = true;\r\n            clusters.push([p.index])\r\n            cluster_index = clusters.length - 1;\r\n            ordered_list.push(p);\r\n            if (this._core_distance(p) != undefined) {\r\n                const seeds = new Heap(null, d => d.reachability_distance, \"min\")\r\n                this._update(p, seeds);\r\n                this._expand_cluster(seeds, clusters[cluster_index]);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     * @param {Object} p - a point of {@link matrix}.\r\n     * @returns {Array} An array consisting of the {@link epsilon}-neighborhood of {@link p}.\r\n     */\r\n    _get_neighbors(p) {\r\n        if (\"neighbors\" in p) return p.neighbors;\r\n        const DB = this._DB;\r\n        const metric = this._metric;\r\n        const epsilon = this._epsilon;\r\n        const neighbors = [];\r\n        for (const q of DB) {\r\n            if (q.index == p.index) continue;\r\n            if (metric(p.element, q.element) < epsilon) {\r\n                neighbors.push(q);\r\n            }\r\n        }\r\n        return neighbors;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @private\r\n     * @param {Object} p - a point of {@link matrix}.\r\n     * @returns {Number} The distance to the {@link min_points}-th nearest point of {@link p}, or undefined if the {@link epsilon}-neighborhood has fewer elements than {@link min_points}.\r\n     */\r\n    _core_distance(p) {\r\n        const min_points = this._min_points;\r\n        const metric = this._metric;\r\n        if (p.neighbors && p.neighbors.length <= min_points) {\r\n            return undefined;\r\n        }\r\n        return metric(p.element, p.neighbors[min_points].element);\r\n    }\r\n\r\n    /**\r\n     * Updates the reachability distance of the points.\r\n     * @private\r\n     * @param {Object} p \r\n     * @param {Heap} seeds \r\n     */\r\n    _update(p, seeds) {\r\n        const metric = this._metric;\r\n        const core_distance = this._core_distance(p);\r\n        const neighbors = this._get_neighbors(p);//p.neighbors;\r\n        for (const q of neighbors) {\r\n            if (q.processed) continue;\r\n            const new_reachability_distance = Math.max(core_distance, metric(p.element, q.element));\r\n            //if (q.reachability_distance == undefined) { // q is not in seeds\r\n            if (seeds.raw_data().findIndex(d => d.element == q) < 0) {\r\n                q.reachability_distance = new_reachability_distance;\r\n                seeds.push(q);\r\n            } else { // q is in seeds\r\n                if (new_reachability_distance < q.reachability_distance) {\r\n                    q.reachability_distance = new_reachability_distance;\r\n                    seeds = Heap.heapify(seeds.data(), d => d.reachability_distance, \"min\"); // seeds change key =/\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Expands the {@link cluster} with points in {@link seeds}.\r\n     * @private\r\n     * @param {Heap} seeds \r\n     * @param {Array} cluster \r\n     */\r\n    _expand_cluster(seeds, cluster) {\r\n        const ordered_list = this._ordered_list;\r\n        while (!seeds.empty) {\r\n            const q = seeds.pop().element;\r\n            q.neighbors = this._get_neighbors(q);\r\n            q.processed = true;\r\n            cluster.push(q.index);\r\n            ordered_list.push(q);\r\n            if (this._core_distance(q) != undefined) {\r\n                this._update(q, seeds);\r\n                this._expand_cluster(seeds, cluster);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of clusters.\r\n     * @returns {Array<Array>} Array of clusters with the indices of the rows in given {@link matrix}.\r\n     */\r\n    get_clusters() {\r\n        const clusters = [];\r\n        const outliers = [];\r\n        const min_points = this._min_points;\r\n        for (const cluster of this._clusters) {\r\n            if (cluster.length < min_points) {\r\n                outliers.push(...cluster);\r\n            } else {\r\n                clusters.push(cluster);\r\n            }\r\n        }\r\n        clusters.push(outliers);\r\n        return clusters;\r\n    }\r\n\r\n    /**\r\n     * @returns {Array} Returns an array, where the ith entry defines the cluster affirmation of the ith point of {@link matrix}. (-1 stands for outlier)\r\n     */\r\n    get_cluster_affirmation() {\r\n        const N = this._matrix.shape[0];\r\n        const result = new Array(N).fill();\r\n        const clusters = this.get_clusters();\r\n        for (let i = 0, n = clusters.length; i < n; ++i) {\r\n            const cluster = clusters[i]\r\n            for (const index of cluster) {\r\n                result[index] = (i < n - 1) ? i : -1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","import { Matrix } from \"../matrix/index\";\r\nimport { DR } from \"./DR.js\";\r\nimport { MDS } from \"./MDS.js\";\r\nimport { KMedoids } from \"../clustering/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { BallTree } from \"../knn/index\";\r\n/**\r\n * @class\r\n * @alias LSP\r\n */\r\nexport class LSP extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias LSP\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {number} [k = Math.max(Math.floor(N / 10), 2)] - number of neighbors to consider.\r\n     * @param {number} [control_points = Math.ceil(Math.sqrt(N))] - number of controlpoints\r\n     * @param {number} [d = 2] - the dimensionality of the projection.\r\n     * @param {function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @returns {LSP}\r\n     * @see {@link https://ieeexplore.ieee.org/document/4378370}\r\n     */\r\n    constructor(X, k, control_points, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed);\r\n        super.parameter_list = [\"k\", \"control_points\"];\r\n        this.parameter(\"k\", Math.min(k ?? Math.max(Math.floor(this._N / 10), 2), this._N - 1));\r\n        this.parameter(\"control_points\", Math.min(control_points ?? Math.ceil(Math.sqrt(this._N)), this._N - 1));\r\n        this._is_initialized = false;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {DR} DR - method used for position control points.\r\n     * @param {DR_parameters} DR_parameters - array containing parameters for the DR method which projects the control points\r\n     * @returns {LSP} \r\n     */\r\n    init(DR=MDS, DR_parameters=[], KNN=BallTree) {\r\n        if (this._is_initialized) return this;\r\n        const X = this.X;\r\n        const N = this._N;\r\n        const K = this.parameter(\"k\");\r\n        const d = this._d;\r\n        const metric = this._metric;\r\n        const nc = this.parameter(\"control_points\");\r\n        const control_points = new KMedoids(X, nc, null, metric).get_clusters().medoids;\r\n        const C = new Matrix(nc, N, \"zeros\")\r\n        control_points.forEach((c_i, i) => {\r\n            C.set_entry(i, c_i, 1);\r\n        })\r\n        const Y_C = new DR(Matrix.from(control_points.map(c_i => X.row(c_i))), ...DR_parameters, d).transform();\r\n        \r\n        const XA = X.to2dArray;\r\n        const knn = new KNN(XA, metric);\r\n        const L = new Matrix(N, N, \"I\");\r\n        const alpha = -1/K;\r\n        XA.forEach((x_i, i) => {\r\n            for (const {\"index\": j} of knn.search(x_i, K).iterate()) {\r\n                if (i === j) continue;\r\n                L.set_entry(i, j, alpha);\r\n            }\r\n        })\r\n        const A = L.concat(C, \"vertical\");\r\n\r\n        const z = new Matrix(N, d, \"zeros\");\r\n        const b = z.concat(Y_C, \"vertical\");\r\n        \r\n        this._A = A;\r\n        this._b = b;\r\n        this._is_initialized = true;\r\n        return this;\r\n    }\r\n\r\n\r\n    /**\r\n     * Computes the projection.\r\n     * @returns {Matrix} Returns the projection.\r\n     */\r\n    transform() {\r\n        this.check_init();\r\n        const A = this._A;\r\n        const AT = A.T\r\n        const b = this._b;\r\n        const ATA = AT.dot(A);\r\n        const ATb = AT.dot(b);\r\n        this.Y = Matrix.solve_CG(ATA, ATb, this._randomizer);\r\n        return this.projection;\r\n    }\r\n} ","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { DR } from \"./DR.js\";\r\n\r\nexport class TopoMap extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias Topomap\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     * @returns {TopoMap}\r\n     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}\r\n     */\r\n    constructor(X, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed)\r\n        super.parameter_list = [];\r\n        [ this._N, this._D ] = this.X.shape;\r\n        this._distance_matrix = new Matrix(this._N, this._N, 0);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    __lazy_distance_matrix(i, j, metric) {\r\n        const D = this._distance_matrix;\r\n        const X = this.X;\r\n        const D_ij = D.entry(i, j);\r\n        if (D_ij === 0) {\r\n            let dist = metric(X.row(i), X.row(j));\r\n            D.set_entry(i, j, dist);\r\n            D.set_entry(j, i, dist);\r\n            return dist;\r\n        }\r\n        return D_ij;\r\n    }\r\n\r\n    /**\r\n     * Computes the minimum spanning tree, using a given metric\r\n     * @private\r\n     * @param {Function} metric \r\n     * @see {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\r\n     */\r\n    _make_minimum_spanning_tree(metric = euclidean) {\r\n        const N = this._N;\r\n        const X = [...this.X];\r\n\r\n        let disjoint_set = new DisjointSet(X);\r\n        const F = [];\r\n        let E = [];\r\n        for (let i = 0; i < N; ++i) {\r\n            for (let j = i + 1; j < N; ++j) {\r\n                E.push([i, j, this.__lazy_distance_matrix(i, j, metric)])\r\n            }\r\n        }\r\n        E = E.sort((a, b) => a[2] - b[2]);\r\n\r\n        for (const [u, v, w] of E) {\r\n            const set_u = disjoint_set.find(X[u]);\r\n            const set_v = disjoint_set.find(X[v]);\r\n            if (set_u !== set_v) {\r\n                F.push([u, v, w]);\r\n                disjoint_set.union(set_u, set_v);\r\n            }\r\n        }\r\n\r\n        return F.sort((a, b) => a[2] - b[2])\r\n    }\r\n\r\n    /**\r\n     * initializes TopoMap. Sets all projcted points to zero, and computes a minimum spanning tree.\r\n     */\r\n    init() {\r\n        this.Y = new Matrix(this._N, this._d, 0);\r\n        this._Emst = this._make_minimum_spanning_tree(this._metric);\r\n        this._is_initialized = true;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Returns true if Point C is left of line AB.\r\n     * @private\r\n     * @param {Array} PointA - Point A of line AB\r\n     * @param {Array} PointB - Point B of line AB\r\n     * @param {Array} PointC - Point C\r\n     * @returns {Boolean}\r\n     */\r\n    __hull_cross([ax, ay], [bx, by], [sx, sy]) {\r\n        return ((bx - ax) * (sy - ay) - (by - ay) * (sx - ax) <= 0)\r\n    }\r\n\r\n    /**\r\n     * Computes the convex hull of the set of Points S\r\n     * @private\r\n     * @param {Array} S - Set of Points.\r\n     * @see {@link https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#JavaScript}\r\n     * @returns {Array} convex hull of S. Starts at the bottom-most point and continues counter-clockwise.\r\n     */\r\n    __hull(S) {\r\n        const points = S.sort(([x1, y1], [x2, y2]) => y1 - y2 || x1 - x2);\r\n        const N = points.length;\r\n        if (N <= 2) return points;\r\n\r\n        const lower = [];\r\n        for (let i = 0; i < N; ++i) {\r\n            while (lower.length >= 2 && this.__hull_cross(lower[lower.length - 2], lower[lower.length -1], points[i])) {\r\n                lower.pop();\r\n            }\r\n            lower.push(points[i]);\r\n        }\r\n        const upper = [];\r\n        for (let i = N - 1; i >= 0; --i) {\r\n            while (upper.length >= 2 && this.__hull_cross(upper[upper.length - 2], upper[upper.length -1], points[i])) {\r\n                upper.pop();\r\n            }\r\n            upper.push(points[i]);\r\n        }\r\n        upper.pop();\r\n        lower.pop();\r\n        return lower.concat(upper);\r\n    }\r\n\r\n    /**\r\n     * Finds the angle to rotate Point A and B to lie on a line parallel to the x-axis.\r\n     * @private\r\n     * @param {Array} PointA \r\n     * @param {Array} PointB\r\n     * @return {Object} Object containing the sinus- and cosinus-values for a rotation.  \r\n     */\r\n    __findAngle([p1x, p1y], [p2x, p2y]) {\r\n        const n = euclidean([p1x, p1y], [p2x, p2y]);\r\n        if (n === 0) return {\r\n            \"sin\": 0, \r\n            \"cos\": 1\r\n        }\r\n        const vec = [(p2x - p1x) / n, (p2y - p1y) / n];\r\n        const cos = vec[0];\r\n        let sin = Math.sqrt(1 - (cos * cos));\r\n        sin = vec[1] >= 0 ? -sin : sin;\r\n        return {\r\n            \"sin\": sin, \r\n            \"cos\": cos\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array} hull \r\n     * @param {Array} p \r\n     * @param {Bool} topEdge\r\n     */\r\n    __align_hull(hull, p, topEdge) {\r\n        let v = -1;\r\n        let d2;\r\n        for (let i = 0; i < hull.length; ++i) {\r\n            const d = euclidean(hull[i], p);\r\n            if (v === -1) {\r\n                d2 = d; \r\n                v = i;\r\n            } else {\r\n                if (d2 > d) {\r\n                    d2 = d; \r\n                    v = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        let v1;\r\n        let v2;\r\n        if (topEdge) {\r\n            v1 = hull[v];\r\n            v2 = hull[(v + 1) % hull.length];\r\n        } else {\r\n            if (v == 0) v = hull.length - 1;\r\n            v1 = hull[v];\r\n            v2 = hull[(v - 1) % hull.length];\r\n        }\r\n        \r\n        const transformation = {\r\n            \"tx\": -hull[v][0],\r\n            \"ty\": -hull[v][1],\r\n        };\r\n\r\n        if (hull.length >= 2) {\r\n            const {sin, cos} = this.__findAngle(v1, v2);\r\n            transformation.sin = sin;\r\n            transformation.cos = cos;\r\n        } else {\r\n            transformation.sin = 0;\r\n            transformation.cos = 1;\r\n        }\r\n\r\n        return transformation;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array} Point - The point which should get transformed.\r\n     * @param {Object} Transformation - contains the values for translation and rotation.\r\n     */\r\n    __transform([px, py], {tx, ty, sin, cos}) {\r\n        let x = px + tx;\r\n        let y = py + ty;\r\n        let xx = x * cos - y * sin;\r\n        let yy = x * sin + y * cos;\r\n        return [xx, yy];\r\n    }\r\n\r\n    /**\r\n     * Calls {@link __transform} for each point in Set C\r\n     * @private\r\n     * @param {Array} C - Set of points.\r\n     * @param {Object} t - Transform object. \r\n     * @param {Number} yOffset - value to offset set C.\r\n     */\r\n    __transform_component(C, t, yOffset) {\r\n        const N = C.length;\r\n        for (let i = 0; i < N; ++i) {\r\n            const c = C[i];\r\n            const [cx, cy] = this.__transform(c, t);\r\n            c[0] = cx; \r\n            c[1] = cy + yOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Array} u - point u\r\n     * @param {Array} v - point v\r\n     * @param {Number} w - edge weight w\r\n     */\r\n    __align_components = (u, v, w)  => {\r\n        const points_u = [...u.__disjoint_set.children];\r\n        const points_v = [...v.__disjoint_set.children];\r\n        \r\n        const hull_u = this.__hull(points_u);\r\n        const hull_v = this.__hull(points_v);        \r\n\r\n        const t_u = this.__align_hull(hull_u, u, false);\r\n        const t_v = this.__align_hull(hull_v, v, true);\r\n\r\n        this.__transform_component(points_u, t_u, 0);\r\n        this.__transform_component(points_v, t_v, w);\r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality 2.\r\n     */\r\n    transform() {\r\n        if (!this._is_initialized) this.init();\r\n        const Emst = this._Emst;\r\n        const Y = [...this.Y];\r\n        const components = new DisjointSet(Y.map((y, i) => {\r\n            y.i = i;\r\n            return y;\r\n        }));\r\n        \r\n        for (const [u, v, w] of Emst) {\r\n            const component_u = components.find(Y[u]);\r\n            const component_v = components.find(Y[v]);\r\n            if (component_u === component_v) continue;\r\n            this.__align_components(component_u, component_v, w);\r\n            components.union(component_u, component_v);\r\n        }\r\n        return this.projection;\r\n    }\r\n\r\n    * generator() {\r\n        if (!this._is_initialized) this.init();\r\n        const Emst = this._Emst;\r\n        const Y = [...this.Y];\r\n        const components = new DisjointSet(Y.map((y, i) => {\r\n            y.i = i;\r\n            return y;\r\n        }));\r\n        \r\n        for (const [u, v, w] of Emst) {\r\n            const component_u = components.find(Y[u]);\r\n            const component_v = components.find(Y[v]);\r\n            if (component_u === component_v) continue;\r\n            this.__align_components(component_u, component_v, w);\r\n            components.union(component_u, component_v);\r\n            /* let ok = true\r\n            Y.forEach(([x, y]) => ok = ok && !isNaN(x) && !isNaN(y))\r\n            if (!ok) {\r\n                console.log(...Y) \r\n                throw \"error\" \r\n            } */\r\n            yield this.projection;\r\n        }\r\n        return this.projection;\r\n    }\r\n} \r\n\r\n/**\r\n * @see {@link https://en.wikipedia.org/wiki/Disjoint-set_data_structure}\r\n */\r\nclass DisjointSet {\r\n    constructor(elements = null) {\r\n        this._list = new Set();\r\n        if (elements) {\r\n            for (const e of elements) {\r\n                this.make_set(e);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    make_set(x) {\r\n        const list = this._list;\r\n        if (!list.has(x)) {\r\n            list.add(x);\r\n            x.__disjoint_set = {};\r\n            x.__disjoint_set.parent = x;\r\n            x.__disjoint_set.children = new Set([x]);\r\n            x.__disjoint_set.size = 1;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    find(x) {\r\n        const list = this._list;\r\n        if (list.has(x)) {\r\n            if (x.__disjoint_set.parent !== x) {\r\n                x.__disjoint_set.children.add(...x);\r\n                x.__disjoint_set.parent = this.find(x.__disjoint_set.parent);\r\n                return x.__disjoint_set.parent;\r\n            } else {\r\n                return x;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    union(x, y) {\r\n        let node_x = this.find(x);\r\n        let node_y = this.find(y);\r\n\r\n        if (node_x === node_y) return this;\r\n        if (node_x.__disjoint_set.size < node_y.__disjoint_set.size) [node_x, node_y] = [node_y, node_x];\r\n\r\n        node_y.__disjoint_set.parent = node_x;\r\n        // keep track of children?\r\n        node_y.__disjoint_set.children.forEach(node_x.__disjoint_set.children.add, node_x.__disjoint_set.children);\r\n        node_x.__disjoint_set.size += node_y.__disjoint_set.size;\r\n\r\n        return this;\r\n    }\r\n}","import { Matrix } from \"../matrix/index\";\r\nimport { euclidean } from \"../metrics/index\";\r\nimport { DR } from \"./DR.js\";\r\nimport { PCA } from \"./index.js\";\r\n\r\nexport class SAMMON extends DR {\r\n    /**\r\n     * \r\n     * @constructor\r\n     * @memberof module:dimensionality_reduction\r\n     * @alias SAMMON\r\n     * @param {Matrix} X - the high-dimensional data. \r\n     * @param {Number} [d = 2] - the dimensionality of the projection.\r\n     * @param {Function} [metric = euclidean] - the metric which defines the distance between two points.  \r\n     * @param {Number} [seed = 1212] - the dimensionality of the projection.\r\n     * @returns {SAMMON}\r\n     * @see {@link https://arxiv.org/pdf/2009.01512.pdf}\r\n     */\r\n    constructor(X, max_halves=5, d=2, metric=euclidean, seed=1212) {\r\n        super(X, d, metric, seed)\r\n        super.parameter_list = [\"max_halves\"];\r\n        this.parameter(\"max_halves\", max_halves);\r\n        [ this._N, this._D ] = this.X.shape;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * initializes SAMMON. Sets all projcted points to zero, and computes a minimum spanning tree.\r\n     */\r\n    init(DR=\"random\", Distance_matrix=null) {\r\n        const N = this._N;\r\n        const d = this._d;\r\n\r\n        if (DR === \"random\") {\r\n            const randomizer = this._randomizer;\r\n            console.log(randomizer)\r\n            this.Y = new Matrix(N, d, () => randomizer.random);\r\n        } else {\r\n            this.Y = DR.transform(this.X);\r\n        }\r\n        const Y = this.Y;\r\n\r\n        if (!Distance_matrix) {\r\n            Distance_matrix = new Matrix(N, N);\r\n        }\r\n\r\n        const metric = this._metric;\r\n        let distance_matrix = new Matrix(N, N);\r\n        let distance_inverse_matrix = new Matrix(N, N);\r\n        for (let i = 0; i < N; ++i) {\r\n            const Y_i = Y.row(i);\r\n            for (let j = i; j < N; ++j) {\r\n                let distance = i === j ? 1 : metric(Y_i, Y.row(j));\r\n                let distance_inverse = 1 / distance;\r\n                distance_matrix.set_entry(i, j, distance);\r\n                distance_matrix.set_entry(j, i, distance);\r\n                distance_inverse_matrix.set_entry(i, j, distance_inverse);\r\n                distance_inverse_matrix.set_entry(j, i, distance_inverse);\r\n                if (!Distance_matrix) {\r\n                    let Distance = i === j ? 1 : metric(X.row(i), X.row(j));\r\n                    Distance_matrix.set_entry(i, j, Distance);\r\n                    Distance_matrix.set_entry(j, i, Distance);\r\n                }\r\n            }\r\n        }\r\n        let Distance_inverse_matrix = Distance_matrix._apply(1, (d, v) => v / d);\r\n        let delta = Distance_matrix.sub(distance_matrix);\r\n        let E = delta._apply(2, (d, v) => Math.pow(d, v)).mult(Distance_inverse_matrix);\r\n        console.log(E)\r\n        this._distance_matrix = distance_matrix;\r\n        this._distance_inverse_matrix = distance_inverse_matrix;\r\n        this._Distance_matrix = Distance_matrix;\r\n        this._Distance_inverse_matrix = distance_inverse_matrix;\r\n        this._delta = delta;\r\n        this._ones = new Matrix(N, d, 1);\r\n        this._E = E.sum;\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {Matrix} A\r\n     * @returns {Matrix} \r\n     */\r\n    __distance_matrix(A) {\r\n        const metric = this._metric;\r\n        const N = A.shape[0];\r\n        const D = new Matrix(N, N);\r\n        for (let i = 0; i < N; ++i) {\r\n            const A_i = A.row(i);\r\n            for (let j = i; j < N; ++j) {\r\n                let distance = (i === j ? 1 : metric(A_i, A.row(j)));\r\n                D.set_entry(i, j, distance);\r\n                D.set_entry(j, i, distance);\r\n            }\r\n        }\r\n        return D;                \r\n    }\r\n\r\n    /**\r\n     * Transforms the inputdata {@link X} to dimenionality 2.\r\n     */\r\n    transform(max_iter=20) {\r\n        if (!this._is_initialized) this.init();\r\n\r\n        for (let j = 0; j < max_iter; ++j) {\r\n            console.log([...this.Y])\r\n            this._step()\r\n        }\r\n\r\n        return this.projection;\r\n    }\r\n\r\n    * generator() {\r\n        if (!this._is_initialized) this.init();\r\n\r\n        for (let j = 0; j < max_iter; ++j) {\r\n            this._step()\r\n            yield this.projection;\r\n        }\r\n\r\n        return this.projection;\r\n    }\r\n\r\n    _step() {\r\n        const max_halves = this.parameter(\"max_halves\");\r\n\r\n        let distance_matrix = this._distance_matrix;\r\n        let distance_inverse_matrix = this._distance_inverse_matrix;\r\n        let Distance_matrix = this._Distance_matrix;\r\n        let Distance_inverse_matrix = this._Distance_inverse_matrix;\r\n        let ones = this._ones;\r\n        let E = this._E;\r\n        let Y = this.Y;\r\n\r\n        let delta = distance_inverse_matrix.sub(Distance_inverse_matrix);\r\n        let delta_one = delta.dot(ones);\r\n        let g = delta.dot(Y).sub(Y.mult(delta_one));\r\n        let dinv3 = distance_inverse_matrix._apply(3, (d, v) => Math.pow(d, v));\r\n        let Y2 = Y._apply(2, (d, v) => Math.pow(d, v));\r\n        let H = dinv3.dot(Y2).sub(delta_one).sub(Y.mult(2).mult(dinv3.dot(Y))).add(Y2.mult(dinv3.dot(ones)));\r\n        H = H._apply(null, (d) => Math.abs(d));\r\n        let s = g.divide(H);\r\n        let Y_old = Y.clone();\r\n\r\n        for (let j = 0; j < max_halves; ++j) {\r\n            Y = Y_old.add(s);\r\n            distance_matrix = this.__distance_matrix(Y);\r\n            distance_inverse_matrix = distance_matrix._apply(1, (d, v) => v / d);\r\n            delta = Distance_matrix.sub(distance_matrix);\r\n            let E_new = delta._apply(2, (d, v) => Math.pow(d, v)).mult(Distance_inverse_matrix).sum;\r\n            if (E_new < E) {\r\n                break;\r\n            } else {\r\n                s = s.mult(.5);\r\n            }\r\n        }\r\n\r\n        this.Y = Y;\r\n    }\r\n} "],"sourceRoot":""}