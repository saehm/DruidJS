// https://renecutura.eu v0.3.16 Copyright 2021 Rene Cutura
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).druid=t.druid||{})}(this,(function(t){"use strict";function e(t,e){return Math.sqrt(r(t,e))}function s(t){let e=t.length,s=0,r=0;for(let n=0;n<e;++n){let e=t[n],i=s+e;Math.abs(s)>=Math.abs(e)?r+=s-i+e:r+=e-i+s,s=i}return s+r}function r(t,e){if(t.length!=e.length)return;let r=t.length,n=new Array(r);for(let s=0;s<r;++s){let r=t[s],i=e[s];n[s]=(r-i)*(r-i)}return s(n)}function n(t,s,r=null,n=e){const i=t.shape[0];let h=r??o(t,n),a=new Array(i);for(let t=0;t<i;++t)a[t]=Array.from(h.row(t)).map(((e,s)=>({i:t,j:s,distance:e}))).sort(((t,e)=>t.distance-e.distance)).slice(1,s+1);return a}class i{constructor(t=null,e=null,s=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!s)return this._data=new Float64Array(t*e),this;if("function"==typeof s){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)for(let t=0;t<e;++t)this._data[r*e+t]=s(r,t);return this}if("string"==typeof s){if("zeros"===s)return new i(t,e,0);if("identity"===s||"I"===s){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)this._data[s*e+s]=1;return this}if("center"===s&&t==e){this._data=new Float64Array(t*e),s=(e,s)=>(e===s?1:0)-1/t;for(let r=0;r<t;++r)for(let t=0;t<e;++t)this._data[r*e+t]=s(r,t);return this}}if("number"==typeof s){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)for(let t=0;t<e;++t)this._data[r*e+t]=s;return this}}return this}static from(t,e="row"){if(t instanceof i)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new i(1,1,t);throw"error"}{let s=t.length;if(0===s)throw"Array is empty";if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new i(1,s,((e,s)=>t[s]));if("col"===e)return new i(s,1,(e=>t[e]));if("diag"===e)return new i(s,s,((e,s)=>e==s?t[e]:0));throw"1d array has NaN entries"}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let r=0;r<s;++r)if(t[r].length!==e)throw"various array lengths";return new i(s,e,((e,s)=>t[e][s]))}}}row(t){const e=this._data,s=this._cols;return e.subarray(t*s,(t+1)*s)}*iterate_rows(){const t=this._cols,e=this._rows,s=this._data;for(let r=0;r<e;++r)yield s.subarray(r*t,(r+1)*t)}*[Symbol.iterator](){for(const t of this.iterate_rows())yield t}set_row(t,e){let s=this._cols;if(Array.isArray(e)&&e.length===s){let r=t*s;for(let t=0;t<s;++t)this._data[r+t]=e[t]}else if(e instanceof i&&e.shape[1]===s&&1===e.shape[0]){let r=t*s;for(let t=0;t<s;++t)this._data[r+t]=e._data[t]}return this}col(t){let e=new Float64Array(this._rows);for(let s=0;s<this._rows;++s)e[s]=this._data[s*this._cols+t];return e}entry(t,e){return this._data[t*this._cols+e]}set_entry(t,e,s){return this._data[t*this._cols+e]=s,this}transpose(){return new i(this._cols,this._rows,((t,e)=>this.entry(e,t)))}get T(){return this.transpose()}inverse(){const t=this._rows,e=this._cols;let s=new i(t,2*e,((t,s)=>s>=e?t===s-e?1:0:this.entry(t,s))),r=0,n=0;for(;r<t&&n<e;){var o=0;let i=-1/0;for(let e=r;e<t;++e){let t=Math.abs(s.entry(e,n));i<t&&(o=e,i=t)}if(0==s.entry(o,n))n++;else{for(let t=0;t<2*e;++t){let e=s.entry(r,t),n=s.entry(o,t);s.set_entry(r,t,e),s.set_entry(o,t,n)}for(let i=r+1;i<t;++i){let t=s.entry(i,n)/s.entry(r,n);s.set_entry(i,n,0);for(let o=n+1;o<2*e;++o)s.set_entry(i,o,s.entry(i,o)-s.entry(r,o)*t)}r++,n++}}for(let r=0;r<t;++r){let t=s.entry(r,r);for(let n=r;n<2*e;++n)s.set_entry(r,n,s.entry(r,n)/t)}for(let r=t-1;r>=0;--r){let t=s.entry(r,r);for(let n=0;n<r;n++){let i=s.entry(n,r)/t;for(let t=n;t<2*e;++t){let e=s.entry(n,t);e-=s.entry(r,t)*i,s.set_entry(n,t,e)}}}return new i(t,e,((t,r)=>s.entry(t,r+e)))}dot(t){if(t instanceof i){let e=this;if(e.shape[1]!==t.shape[0])throw`A.dot(B): A is a ${e.shape.join(" x ")}-Matrix, B is a ${t.shape.join(" x ")}-Matrix: \n                A has ${e.shape[1]} cols and B ${t.shape[0]} rows. \n                Must be equal!`;let s=e.shape[1];return new i(e.shape[0],t.shape[1],((r,n)=>{const i=e.row(r),o=t.col(n);let h=0;for(let t=0;t<s;++t)h+=i[t]*o[t];return h}))}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)throw`A.dot(B): A has ${e} cols and B has ${t.length} rows. Must be equal!`;let r=new Array(e);for(let n=0;n<e;++n)r[n]=s(this.row(n).map((e=>e*t[n])));return r}throw"B must be Matrix or Array"}outer(t){let e=this,s=e._data.length;if(s!=t._data.length)return;let r=new i;return r.shape=[s,s,(s,n)=>s<=n?e._data[s]*t._data[n]:r.entry(n,s)],r}concat(t,e="horizontal"){const s=this,[r,n]=s.shape,[o,h]=t.shape;if("horizontal"==e){if(r!=o)throw`A.concat(B, "horizontal"): A and B need same number of rows, A has ${r} rows, B has ${o} rows.`;const e=new i(r,n+h,"zeros");return e.set_block(0,0,s),e.set_block(0,n,t),e}if("vertical"==e){if(n!=h)throw`A.concat(B, "vertical"): A and B need same number of columns, A has ${n} columns, B has ${h} columns.`;const e=new i(r+o,n,"zeros");return e.set_block(0,0,s),e.set_block(r,0,t),e}if("diag"==e){const e=new i(r+o,n+h,"zeros");return e.set_block(0,0,s),e.set_block(r,n,t),e}throw`type must be "horizontal" or "vertical", but type is ${e}!`}set_block(t,e,s){let[r,n]=s.shape;for(let i=0;i<r;++i)if(!(i>this._rows))for(let r=0;r<n;++r)r>this._cols||this.set_entry(i+t,r+e,s.entry(i,r));return this}get_block(t,e,s=null,r=null){const[n,o]=this.shape;if(r=r??o,(s=s??n)<=t||r<=e)throw`\n                end_row must be greater than start_row, and \n                end_col must be greater than start_col, but\n                end_row = ${s}, start_row = ${t}, end_col = ${r}, and start_col = ${e}!`;const h=new i(s-t,r-e,"zeros");for(let n=t,i=0;n<s;++n,++i)for(let t=e,s=0;t<r;++t,++s)h.set_entry(i,s,this.entry(n,t));return h}gather(t,e){const s=t.length,r=e.length,n=new i(s,r);for(let r=0;r<s;++r){const i=t[r];for(let t=0;t<s;++t){const s=e[t];n.set_entry(r,t,this.entry(i,s))}}return n}_apply_array(t,e){const s=this._data,[r,n]=this.shape;for(let i=0;i<r;++i){const r=i*n;for(let o=0;o<n;++o){const n=r+o;s[n]=t(s[n],e(i,o))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,((e,s)=>t[s]))}_apply_colwise_array(t,e){const s=this._data,[r,n]=this.shape;for(let i=0;i<r;++i){const r=i*n;for(let o=0;o<n;++o){const n=r+o;s[n]=e(s[n],t[i])}}return this}_apply(t,e){let s=this._data;if(t instanceof i){let[r,n]=t.shape,[i,o]=this.shape;if(1===r){if(o!==n)throw"cols !== value_cols";for(let r=0;r<i;++r)for(let n=0;n<o;++n)s[r*o+n]=e(s[r*o+n],t.entry(0,n))}else if(1===n){if(i!==r)throw"rows !== value_rows";for(let r=0;r<i;++r)for(let n=0;n<o;++n)s[r*o+n]=e(s[r*o+n],t.entry(r,0))}else{if(i!=r||o!=n)throw"error";for(let r=0;r<i;++r)for(let n=0;n<o;++n)s[r*o+n]=e(s[r*o+n],t.entry(r,n))}}else if(Array.isArray(t)){let r=this._rows,n=this._cols;if(t.length===r)for(let i=0;i<r;++i)for(let r=0;r<n;++r)s[i*n+r]=e(s[i*n+r],t[i]);else{if(t.length!==n)throw"error";for(let i=0;i<r;++i)for(let r=0;r<n;++r)s[i*n+r]=e(s[i*n+r],t[r])}}else for(let r=0,n=this._rows*this._cols;r<n;++r)s[r]=e(s[r],t);return this}clone(){let t=new i;return t._rows=this._rows,t._cols=this._cols,t._data=this._data.slice(0),t}mult(t){return this.clone()._apply(t,((t,e)=>t*e))}divide(t){return this.clone()._apply(t,((t,e)=>t/e))}add(t){return this.clone()._apply(t,((t,e)=>t+e))}sub(t){return this.clone()._apply(t,((t,e)=>t-e))}get shape(){return[this._rows,this._cols]}set shape([t,e,s=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let r=0;r<t;++r)for(let t=0;t<e;++t)this._data[r*e+t]=s(r,t);return this}get to2dArray(){return[...this.iterate_rows()]}get diag(){const t=this._rows,e=this._cols,s=Math.min(t,e);let r=new Float64Array(s);for(let t=0;t<s;++t)r[t]=this.entry(t,t);return r}get mean(){return this.sum/(this._rows*this._cols)}get sum(){return s(this._data)}get meanRows(){const t=this._data,e=this._rows,s=this._cols;let r=Float64Array.from({length:e});for(let n=0;n<e;++n){r[n]=0;for(let e=0;e<s;++e)r[n]+=t[n*s+e];r[n]/=s}return r}get meanCols(){const t=this._data,e=this._rows,s=this._cols;let r=Float64Array.from({length:s});for(let n=0;n<s;++n){r[n]=0;for(let i=0;i<e;++i)r[n]+=t[i*s+n];r[n]/=e}return r}static solve_CG(t,e,s,r=.001){const n=t.shape[0],o=e.shape[1];let h=new i(n,0);for(let a=0;a<o;++a){const o=i.from(e.col(a)).T;let l=new i(n,1,(()=>s.random)),_=o.sub(t.dot(l)),c=_.clone();do{const e=t.dot(c),s=_.T.dot(_).entry(0,0)/c.T.dot(e).entry(0,0);l=l.add(c.mult(s));const r=_.sub(e.mult(s)),n=r.T.dot(r).entry(0,0)/_.T.dot(_).entry(0,0);c=r.add(c.mult(n)),_=r}while(Math.abs(_.mean)>r);h=h.concat(l,"horizontal")}return h}static solve(t,e){let{L:s,U:r}="L"in t&&"U"in t?t:i.LU(t),n=s.shape[0],o=e.clone();for(let t=0;t<n;++t){for(let e=0;e<t-1;++e)o.set_entry(0,t,o.entry(0,t)-s.entry(t,e)*o.entry(1,e));o.set_entry(0,t,o.entry(0,t)/s.entry(t,t))}for(let t=n-1;t>=0;--t){for(let e=n-1;e>t;--e)o.set_entry(0,t,o.entry(0,t)-r.entry(t,e)*o.entry(0,e));o.set_entry(0,t,o.entry(0,t)/r.entry(t,t))}return o}static LU(t){const e=t.shape[0],s=new i(e,e,"zeros"),r=new i(e,e,"identity");for(let n=0;n<e;++n){for(let i=n;i<e;++i){let e=0;for(let t=0;t<n;++t)e+=s.entry(i,t)*r.entry(t,n);s.set_entry(i,n,t.entry(i,n)-e)}for(let i=n;i<e;++i){if(0===s.entry(n,n))return;let e=0;for(let t=0;t<n;++t)e+=s.entry(n,t)*r.entry(t,i);r.set_entry(n,i,(t.entry(n,i)-e)/s.entry(n,n))}}return{L:s,U:r}}static SVD(t,e=2){const s=t.T;let r=s.dot(t),n=t.dot(s),{eigenvectors:i,eigenvalues:o}=simultaneous_poweriteration(r,e),{eigenvectors:h}=simultaneous_poweriteration(n,e);return{U:h,Sigma:o.map((t=>Math.sqrt(t))),V:i}}}function o(t,s=e){let r=t.shape[0];const n=new i(r,r);for(let e=0;e<r;++e){const i=t.row(e);for(let o=e+1;o<r;++o){const r=s(i,t.row(o));n.set_entry(e,o,r),n.set_entry(o,e,r)}}return n}function h(t,e,s=null){if(s||(s=Math.max(Math.round(e-t)+1,1)),s<2)return 1===s?[t]:[];let r=new Array(s);for(let n=s-=1;n>=0;--n)r[n]=(n*e+(s-n)*t)/s;return r}function a(t,s=e){let r=null;if(t instanceof i){let[e,s]=t.shape;if(1===e)r=t.row(0);else{if(1!==s)throw"matrix must be 1d!";r=t.col(0)}}else r=t;let n=r.length,o=new Array(n);return o.fill(0),s(r,o)}class l{constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,s=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&s)>>>16)<<16)+1812433253*(65535&s)+t,e[t]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let s;this._mti==this._N+1&&(this.seed=5489);let r=this._N-this._M,n=this._M-this._N;for(s=0;s<r;++s)t=this._mt[s]&this._UPPER_MASK|this._mt[s+1]&this._LOWER_MASK,this._mt[s]=this._mt[s+this._M]^t>>>1^e[1&t];for(;s<this._N-1;++s)t=this._mt[s]&this._UPPER_MASK|this._mt[s+1]&this._LOWER_MASK,this._mt[s]=this._mt[s+n]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,t^=t>>>18,t>>>0}choice(t,e){if(t instanceof i){let[s,r]=t.shape;if(e>s)throw"n bigger than A!";let n=new Array(e),i=h(0,s-1);for(let t=0,s=i.length;t<e;++t,--s){let e=this.random_int%s;n[t]=i.splice(e,1)[0]}return n.map((e=>t.row(e)))}if(Array.isArray(t)||t instanceof Float64Array){let s=t.length;if(e>s)throw"n bigger than A!";let r=new Array(e),n=h(0,s-1);for(let t=0,s=n.length;t<e;++t,--s){let e=this.random_int%s;r[t]=n.splice(e,1)[0]}return r.map((e=>t[e]))}}static choice(t,e,s=19870307){let[r,n]=t.shape;if(e>r)throw"n bigger than A!";let i=new l(s),o=new Array(e),a=h(0,r-1);for(let t=0,s=a.length;t<e;++t,--s){let e=i.random_int%s;o[t]=a.splice(e,1)[0]}return o.map((e=>t.row(e)))}}function _(t){let e;for(const s of t)null!=s&&(e<s||void 0===e&&s>=s)&&(e=s);return e}class c{constructor(t=null,e=(t=>t),s="min"){return t?c.heapify(t,e,s):(this._accessor=e,this._container=[],this._comparator="min"==s?(t,e)=>t<e:"max"==s?(t,e)=>t>e:s,this)}static heapify(t,e=(t=>t),s="min"){const r=new c(null,e,s),n=r._container;for(const s of t)n.push({element:s,value:e(s)});for(let e=Math.floor(t.length/2-1);e>=0;--e)r._heapify_down(e);return r}_swap(t,e){const s=this._container;[s[e],s[t]]=[s[t],s[e]]}_heapify_up(){const t=this._container;let e=t.length-1;for(;e>0;){let s=Math.floor((e-1)/2);if(!this._comparator(t[e].value,t[s].value))break;this._swap(s,e),e=s}}push(t){const e={element:t,value:this._accessor(t)};return this._container.push(e),this._heapify_up(),this}_heapify_down(t=0){const e=this._container,s=this._comparator,r=e.length;let n=2*t+1,i=2*t+2,o=t;if(o>r)throw"index higher than length";n<r&&s(e[n].value,e[o].value)&&(o=n),i<r&&s(e[i].value,e[o].value)&&(o=i),o!==t&&(this._swap(t,o),this._heapify_down(o))}pop(){const t=this._container;if(0===t.length)return null;if(1===t.length)return t.pop();this._swap(0,t.length-1);const e=t.pop();return this._heapify_down(),e}get first(){return this._container.length>0?this._container[0]:null}*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}toArray(){return this.data().sort(((t,e)=>this._comparator(t,e)?-1:0))}data(){return this._container.map((t=>t.element))}raw_data(){return this._container}get length(){return this._container.length}get empty(){return 0===this.length}}class u{constructor(t=null){if(this._list=new Set,t)for(const e of t)this.make_set(e);return this}make_set(t){const e=this._list;return e.has(t)||(e.add(t),t.__disjoint_set={},t.__disjoint_set.parent=t,t.__disjoint_set.children=new Set([t]),t.__disjoint_set.size=1),this}find(t){return this._list.has(t)?t.__disjoint_set.parent!==t?(t.__disjoint_set.children.add(...t),t.__disjoint_set.parent=this.find(t.__disjoint_set.parent),t.__disjoint_set.parent):t:null}union(t,e){let s=this.find(t),r=this.find(e);return s===r||(s.__disjoint_set.size<r.__disjoint_set.size&&([s,r]=[r,s]),r.__disjoint_set.parent=s,r.__disjoint_set.children.forEach(s.__disjoint_set.children.add,s.__disjoint_set.children),s.__disjoint_set.size+=r.__disjoint_set.size),this}}class f{constructor(t=null,s=e){return this._Node=class{constructor(t,e=null,s=null,r=null){this.pivot=t,this.child1=e,this.child2=s,this.radius=r}},this._Leaf=class{constructor(t){this.points=t}},this._metric=s,t&&this.add(t),this}add(t){return t=t.map(((t,e)=>({index:e,element:t}))),this._root=this._construct(t),this}_construct(t){if(1===t.length)return new this._Leaf(t);{let e,s=this._greatest_spread(t),r=t.sort(((t,e)=>t.element[s]-e.element[s])),n=r.length,i=Math.floor(n/2),o=t[i],h=r.slice(0,i),a=r.slice(i,n),l=Math.max(...t.map((t=>this._metric(o.element,t.element))));return e=h.length>0&&a.length>0?new this._Node(o,this._construct(h),this._construct(a),l):new this._Leaf(t),e}}_greatest_spread(t){let e=t[0].element.length,s=new Array(e);for(let t=0;t<e;++t)s[t]=[1/0,-1/0];let r=t.reduce(((t,s)=>{for(let r=0;r<e;++r)t[r][0]=Math.min(t[r][0],s.element[r]),t[r][1]=Math.max(t[r][1],s.element[r]);return t}),s);r=r.map((t=>t[1]-t[0]));let n=0;for(let t=0;t<e;++t)n=r[t]>r[n]?t:n;return n}search(t,e=5){return this._search(t,e,new c(null,(e=>this._metric(e.element,t)),"max"),this._root)}_search(t,e,s,r){if(s.length>=e&&r.pivot&&r.radius&&this._metric(t,r.pivot.element)-r.radius>=s.first.value)return s;if(r.child1&&this._search(t,e,s,r.child1),r.child2&&this._search(t,e,s,r.child2),r.points)for(let t=0,n=r.points.length;t<n;++t){let n=r.points[t];e>s.length?s.push(n):(s.push(n),s.pop())}return s}}class d{constructor(t=null,s=e){this._metric=s,this._elements=t instanceof i?t:i.from(t);const r=this._elements.shape[0];this._D="precomputed"===s?this._elements.clone():o(this._elements,s),this.KNN=[];for(let t=0;t<r;++t){const e=this._D.row(t),s=new c(null,(t=>t.value),"min");for(let t=0;t<r;++t)s.push({value:e[t],index:t});this.KNN.push(s)}}search(t,e=5){const s=this._metric,r=this.KNN;let n;if(Array.isArray(t)){if("precomputed"==this._metric)throw"Search by query element is only possible when not using a precomputed distance matrix!";const e=this._elements,i=r.length;let o=null,h=1/0;for(let r=0;r<i;++r){const n=s(t,e.row(r));n<h&&(o=r,h=n)}n=r[o]}else Number.isInteger(t)&&(n=r[t]);let i=[];for(let t=0;t<e;++t)i.push(n.pop());return i.forEach((t=>n.push(t.element))),i}}function p(t){const[r,n]=t.shape,o=new i(r,n,"identity"),h=new i(n,n,0);for(let i=0;i<n;++i){let n=t.col(i);for(let t=0;t<i;++t){const e=o.col(t),r=s(e.map(((t,e)=>t*n[e])));h.set_entry(t,i,r),n=n.map(((t,s)=>t-r*e[s]))}const l=a(n,e);for(let t=0;t<r;++t)o.set_entry(t,i,n[t]/l);h.set_entry(i,i,l)}return{R:h,Q:o}}function m(t,e=2,r=100,n=1212){const o=n instanceof l?n:new l(n);t instanceof i||(t=i.from(t));const h=t.shape[0];let{Q:a,R:_}=p(new i(h,e,(()=>o.random)));for(;r--;){const e=_.clone(),n=p(t.dot(a));a=n.Q,_=n.R,s(_.sub(e).diag)/h<1e-12&&(r=0)}return{eigenvalues:_.diag,eigenvectors:a.transpose().to2dArray}}class y{get parameter_list(){return this._parameter_list}set parameter_list(t){return this._parameter_list=t,this}constructor(t,s=2,r=e,n=1212){if(Array.isArray(t))this._type="array",this.X=i.from(t);else{if(!(t instanceof i))throw"no valid type for X";this._type="matrix",this.X=t}return[this._N,this._D]=this.X.shape,this._d=s,this._metric=r,this._seed=n,this._randomizer=new l(n),this._is_initialized=!1,this}parameter(t,e=null){if(-1===this.parameter_list.findIndex((e=>e===t)))throw t+" is not a valid parameter!";return e?(this["_"+t]=e,this):this["_"+t]}para(t,e=null){return this.parameter(t,e)}p(t,e=null){return this.parameter(t,e)}transform(){return this.check_init(),this.Y}generator(){return this.transform()}check_init(){this._is_initialized||"function"!=typeof this.init||(this.init(),this._is_initialized=!0)}get projection(){return"matrix"===this._type?this.Y:this.Y.to2dArray}async transform_async(){return this.transform()}static transform(...t){return new this(...t).transform()}static async transform_async(...t){return this.transform(...t)}static*generator(...t){const e=new this(...t).generator();for(const t of e)yield t}}class w extends y{constructor(t,e=2){return super(t,e),this}transform(){let t=this.X,e=t.shape[1],s=new i(e,e,"center"),r=t.dot(s),n=r.transpose().dot(r),{eigenvectors:o}=m(n,this._d);return o=i.from(o).transpose(),this.Y=t.dot(o),this.projection}}class g extends y{constructor(t,s=2,r=e,n=1212){return super(t,s,r,n),this}transform(){const t=this.X,e=t.shape[0],s=this._metric,r="precomputed"===s?t:o(t,s),n=r.meanCols,h=r.meanRows,a=r.mean;this._d_X=r;const l=new i(e,e,((t,e)=>r.entry(t,e)-n[t]-h[e]+a)),{eigenvectors:_}=m(l,this._d);return this.Y=i.from(_).transpose(),this.projection}get stress(){const t=this.X.shape[0],s=this.Y,r=this._d_X,n=new i;n.shape=[t,t,(t,r)=>t<r?e(s.row(t),s.row(r)):n.entry(r,t)];let o=0,h=0;for(let e=0;e<t;++e)for(let s=e+1;s<t;++s)o+=Math.pow(r.entry(e,s)-n.entry(e,s),2),h+=Math.pow(r.entry(e,s),2);return Math.sqrt(o/h)}}function x(t,e,s=300){const r=e.length;let n=.001,i=1e4,o=e.slice(),h=t(o),a=!1;for(;s-- >=0&&!a;){a=!0;for(let e=0;e<r;++e){o[e]+=1e-6;let s=t(o);o[e]-=1e-6;let r=(s-h)/1e-6;Math.abs(r)>.01&&(a=!1),o[e]-=n*r,h=t(o)}n*=i>=h?1.05:.4,i=h}return o}class A{constructor(t,e,s,r,n,i,o,h){return this.id=t,this.left=e,this.right=s,this.dist=r,this.index=i,this.size=o??e.size+s.size,this.depth=h??1+Math.max(e.depth,s.depth),this.centroid=n??this._calculate_centroid(e,s),this.parent=null,this}_calculate_centroid(t,e){const s=t.size,r=e.size,n=t.centroid,i=e.centroid,o=this.size,h=t.centroid.length,a=new Float64Array(h);for(let t=0;t<h;++t)a[t]=(s*n[t]+r*i[t])/o;return a}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this];const t=this.left,e=this.right;return(t.isLeaf?[t]:t.leaves()).concat(e.isLeaf?[e]:e.leaves())}descendants(){if(this.isLeaf)return[this];const t=this.left.descendants(),e=this.right.descendants();return t.concat(e).concat([this])}}class M{constructor(t,s,r=null,n=e,o=1212){this._metric=n,this._matrix=t,this._A=this._matrix.to2dArray,this._K=s;const[h,a]=t.shape;return this._N=h,this._D=a,this._max_iter=r||10*Math.log10(h),this._distance_matrix=new i(h,h,"zeros"),s>h&&(s=h),this._randomizer=new l(o),this._clusters=new Array(h).fill(void 0),this._cluster_medoids=this._get_random_medoids(s),this._is_initialized=!1,this}get_clusters(){const t=this._K,e=this._A;this._is_initialized||this.init(t,this._cluster_medoids);const s=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>{s[this._nearest_medoid(t,e).index_nearest].push(e)})),s.medoids=this._cluster_medoids,s}async*generator(){const t=this._max_iter;yield this.get_clusters();let e=!1,s=0;do{e=this._iteration(),yield this.get_clusters()}while(!e&&++s<t)}_iteration(){const t=this._A,e=this._K,s=this._cluster_medoids,r=t.map(((t,e)=>this._nearest_medoid(t,e))),n=new Array(e).fill(0),i=new Array(e).fill(null);if(t.forEach(((o,h)=>{if(s.findIndex((t=>t===h))<0){const s=r[h].distance_nearest,a=new Array(e).fill(-s);t.forEach(((t,s)=>{if(h===s)return;const n=this._get_distance(s,h,t,o),{index_nearest:i,distance_nearest:l,distance_second:_}=r[s];if(a[i]+=Math.min(n,_)-l,n<l)for(let t=0;t<e;++t)t!==i&&(a[t]+=n-l)})),a.map(((t,e)=>[t,e])).filter((([t,e])=>t<n[e])).forEach((([t,e])=>{t<n[e]&&(n[e]=t,i[e]=h)}))}})),Math.min(...n)>=0)return!0;for(;Math.min(...n)<0;){const e=n.map(((t,e)=>[t,e])).sort((([t],[e])=>t-e))[0][1];0==s.filter((t=>t==i[e])).length&&(s[e]=i[e]),n[e]=0,n.map(((t,e)=>[t,e])).filter((([t])=>t<0)).forEach((([i,o])=>{const h=t[o];let a=0;t.forEach(((t,n)=>{s.findIndex((t=>t!=o&&t==n))>=0||e!=o&&(r[n].index_nearest===s[o]?a+=Math.min(this._get_distance(n,o,t,h),r[n].distance_second)-r[n].distance_nearest:a+=Math.min(this._get_distance(n,o,t,h)-r[n].distance_nearest,0))})),n[o]=a}))}return this._cluster_medoids=s,!1}_get_distance(t,e,s=null,r=null){if(t===e)return 0;const n=this._distance_matrix,i=this._A,o=this._metric;let h=n.entry(t,e);return 0===h&&(h=o(s||i[t],r||i[e]),n.set_entry(t,e,h),n.set_entry(e,t,h)),h}_nearest_medoid(t,e){const s=this._cluster_medoids,r=this._A,[n,i]=s.map(((s,n)=>{const i=r[s];return[this._get_distance(e,s,t,i),n]})).sort(((t,e)=>t[0]-e[0]));return{distance_nearest:n[0],index_nearest:n[1],distance_second:i[0],index_second:i[1]}}init(t,e){t||(t=this._K),e||(e=this._get_random_medoids(t));const s=this._max_iter;let r=!1,n=0;do{r=this._iteration()}while(!r&&++n<s);return this}_get_random_medoids(t){const e=this._N,s=this._A,r=h(0,e-1),n=this._randomizer,i=Math.min(e,10+Math.ceil(Math.sqrt(e))),o=new Array(i).fill(1/0),a=[];let l=1/0,_=n.choice(r,i);for(let t=0;t<i;++t){const e=_[t],r=s[e];for(let e=0;e<i;++e){if(e===t)continue;const n=s[_[e]];o[t]+=this._get_distance(t,e,r,n)}o[t]<l&&(l=o[t],a.push(e))}for(let e=1;e<t;++e){let t=1/0;_=n.choice(r.filter((t=>a.findIndex((e=>e===t))<0)),i);for(let e=0;e<i;++e){let r=0;const n=_[e],o=s[n];for(let t=0;t<i;++t){if(t===e)continue;const i=_[t],h=s[i];let l=this._get_distance(n,i,o,h)-Math.min(...a.map((t=>this._get_distance(i,t,h))));l<0&&(r+=l)}r<t&&(t=r,a.push(n))}l+=t}return a.slice(0,t)}}t.BallTree=f,t.DisjointSet=u,t.FASTMAP=class extends y{constructor(t,s=2,r=e,n=1212){return super(t,s,r,n),this}_choose_distant_objects(t){const e=this.X.shape[0];let s=this._randomizer.random_int%e-1,r=null,n=-1/0;for(let i=0;i<e;++i){const e=t(s,i);e>n&&(n=e,r=i)}n=-1/0;for(let i=0;i<e;++i){const e=t(r,i);e>n&&(n=e,s=i)}return[s,r,n]}transform(){const t=this.X,e=t.shape[0],s=this._d,r=this._metric,n=new i(e,s,0);let o=(e,s)=>r(t.row(e),t.row(s));for(let t=0;t<s;++t){let s=o;const[r,i,h]=this._choose_distant_objects(o);if(0!==h){for(let s=0;s<e;++s){const e=(o(r,s)**2+h**2-o(i,s)**2)/(2*h);n.set_entry(s,t,e)}o=(e,r)=>Math.sqrt(s(e,r)**2-(n.entry(e,t)-n.entry(r,t))**2)}}return this.Y=n,this.projection}},t.Heap=c,t.Hierarchical_Clustering=class{constructor(t,s="complete",r=e){if(this._id=0,this._matrix=t instanceof i?t:i.from(t),this._metric=r,this._linkage=s,"precomputed"===r&&t.shape[0]!==t.shape[1])throw"If metric is 'precomputed', then matrix has to be square!";return this.init(),this.root=this.do(),this}get_clusters(t,e="distance"){let s,r=[];switch(e){case"distance":s=t=>t.dist;break;case"depth":s=t=>t.depth;break;default:throw"invalid type"}return this._traverse(this.root,s,t,r),r}_traverse(t,e,s,r){e(t)<=s?r.push(t.leaves()):(this._traverse(t.left,e,s,r),this._traverse(t.right,e,s,r))}init(){const t=this._metric,e=this._matrix,s=this._n=e.shape[0],r=this._d_min=new Float64Array(s);let n;if("precomputed"!==t){n=new i(s,s,0);for(let i=0;i<s;++i){r[i]=0;for(let o=0;o<s;++o)n.set_entry(i,o,i===o?1/0:t(e.row(i),e.row(o))),n.entry(i,r[i])>n.entry(i,o)&&(r[i]=o)}}else{n=this._matrix.clone();for(let t=0;t<s;++t)for(let e=0;e<s;++e)t===e?n.set_entry(t,e,1/0):n.entry(t,r[t])>n.entry(t,e)&&(r[t]=e)}this._distance_matrix=n;const o=this._clusters=new Array(s),h=this._c_size=new Uint16Array(s);for(let t=0;t<s;++t)o[t]=[],o[t][0]=new A(this._id++,null,null,0,e.row(t),t,1,0),h[t]=1;return this}do(){const t=this._n,e=this._d_min,s=this._distance_matrix,r=this._clusters,n=this._c_size,i=this._linkage;let o=null;for(let h=0,a=t-1;h<a;++h){let h=0;for(let r=0;r<t;++r)s.entry(r,e[r])<s.entry(h,e[h])&&(h=r);let a=e[h],l=r[h][0],_=r[a][0],c=l.isLeaf?[l.index]:l.index,u=_.isLeaf?[_.index]:_.index,f=c.concat(u),d=new A(this._id++,l,_,s.entry(h,a),null,f);l.parent=d,_.parent=d,r[h].unshift(d),n[h]+=n[a];for(let e=0;e<t;++e)switch(i){case"single":s.entry(h,e)>s.entry(a,e)&&(s.set_entry(e,h,s.entry(a,e)),s.set_entry(h,e,s.entry(a,e)));break;case"complete":s.entry(h,e)<s.entry(a,e)&&(s.set_entry(e,h,s.entry(a,e)),s.set_entry(h,e,s.entry(a,e)));break;case"average":const t=(n[h]*s.entry(h,e)+n[a]*s.entry(a,e))/(n[h]+n[e]);s.set_entry(e,h,t),s.set_entry(h,e,t)}s.set_entry(h,h,1/0);for(let e=0;e<t;++e)s.set_entry(e,a,1/0),s.set_entry(a,e,1/0);for(let r=0;r<t;++r)e[r]===a&&(e[r]=h),s.entry(h,r)<s.entry(h,e[h])&&(e[h]=r);o=d}return o}},t.ISOMAP=class extends y{constructor(t,s,r=2,n=e,i=1212){return super(t,r,n,i),super.parameter_list=["k"],this.parameter("k",Math.min(s??Math.max(Math.floor(this.X.shape[0]/10),2),this._N-1)),this}transform(){this.check_init();const t=this.X,e=this._N,s=this._metric,r=new i;r.shape=[e,e,(e,n)=>e<=n?s(t.row(e),t.row(n)):r.entry(n,e)];const n=[];for(let t=0;t<e;++t){const s=[];for(let n=0;n<e;++n)s.push({index:n,distance:r.entry(t,n)});const i=new c(s,(t=>t.distance),"min");n.push(i.toArray().slice(1,this._k+1))}const o=new i(e,e,((t,e)=>{const s=n[t].find((t=>t.index===e));return s?s.distance:1/0}));for(let t=0;t<e;++t)for(let s=0;s<e;++s)for(let r=0;r<e;++r)o.set_entry(t,s,Math.min(o.entry(t,s),o.entry(t,r)+o.entry(r,s)));let h=new Float64Array(e),a=new Float64Array(e),l=0,_=new i(e,e,((t,e)=>{let s=o.entry(t,e);return s=s===1/0?0:s,h[t]+=s,a[e]+=s,l+=s,s}));h=h.map((t=>t/e)),a=a.map((t=>t/e)),l/=e**2;const u=new i(e,e,((t,e)=>_.entry(t,e)-h[t]-a[e]+l)),{eigenvectors:f}=m(u,this._d);return this.Y=i.from(f).transpose(),this.projection}},t.KMeans=class{constructor(t,s,r=e,n=1987,i=!0){this._metric=r,this._matrix=t,this._K=s;const[o,h]=t.shape;return this._N=o,this._D=h,s>o&&(s=o),this._randomizer=new l(n),this._clusters=new Array(o).fill(void 0),this._cluster_centroids=this._get_random_centroids(s),i&&this.init(s,this._cluster_centroids),this}get_clusters(){const t=this._K,e=this._clusters,s=new Array(t).fill().map((()=>new Array));return e.forEach(((t,e)=>s[t].push(e))),s}_furthest_point(t,e){const s=this._matrix,r=this._metric;let n=t.length;return c.heapify(e,(e=>{const i=s.row(e);let o=0;for(let e=0;e<n;++e)o+=r(i,t[e]);return o}),"max").pop().element}_get_random_centroids(t){const e=this._N,s=this._randomizer,r=this._matrix,n=new Array(t).fill(),i=h(0,e-1),o=s.random_int%(e-1);n[0]=r.row(o);const a=[o],l=Math.floor((e-t)/t);for(let e=1;e<t;++e){const t=s.choice(i.filter((t=>-1==a.indexOf(t))),l),o=this._furthest_point(n.slice(0,e),t);a.push(o),n[e]=r.row(o)}return n}_iteration(t){const e=t.length,s=this._N,r=this._D,n=this._matrix,i=this._metric,o=this._clusters;let h=!1;for(let r=0;r<s;++r){const s=n.row(r);let a=1/0,l=null;for(let r=0;r<e;++r){let e=i(t[r],s);e<a&&(a=e,l=r)}o[r]!==l&&(h=!0),o[r]=l}for(let s=0;s<e;++s){const e=t[s];for(let t=0;t<r;++t)e[t]=0}return this._compute_centroid(t),{clusters_changed:h,cluster_centroids:t}}_compute_centroid(t){const e=t.length,s=this._N,r=this._D,n=this._matrix,i=this._clusters,o=new Array(e).fill(0);for(let e=0;e<s;++e){const s=n.row(e),h=i[e];o[h]++;const a=t[h];for(let t=0;t<r;++t)a[t]+=s[t]}for(let s=0;s<e;++s){const e=o[s];t[s]=t[s].map((t=>t/e))}}init(t,e){t||(t=this._K),e||(e=this._get_random_centroids(t));let s=!1;do{const t=this._iteration(e);e=t.cluster_centroids,s=t.clusters_changed}while(s)}},t.KMedoids=M,t.KNN=d,t.LDA=class extends y{constructor(t,s,r=2,n=e,i=1212){return super(t,r,n,i),super.parameter_list=["labels"],this.parameter("labels",s),this}transform(){let t=this.X,[e,s]=t.shape,r=this._labels,n={},o=0;r.forEach(((e,s)=>{e in n?(n[e].count++,n[e].rows.push(t.row(s))):n[e]={id:o++,count:1,rows:[t.row(s)]}}));let h=t.mean,a=new i(o,s);for(let t in n){let e=i.from(n[t].rows).meanCols;for(let r=0;r<s;++r)a.set_entry(n[t].id,r,e[r])}let l=new i(s,s);for(let t in n){let e=a.row(n[t].id),r=new i(s,1,(t=>e[t]-h)),o=n[t].count;l=l.add(r.dot(r.transpose()).mult(o))}let _=new i(s,s);for(let t in n){let e=a.row(n[t].id),r=new i(s,1,(t=>e[t])),o=n[t].rows;for(let e=0,h=n[t].count;e<h;++e){let t=new i(s,1,((t,s)=>o[e][t]-r.entry(t,0)));_=_.add(t.dot(t.transpose()))}}let{eigenvectors:c}=m(_.inverse().dot(l),this._d);return c=i.from(c).transpose(),this.Y=t.dot(c),this.projection}},t.LLE=class extends y{constructor(t,s,r=2,n=e,i=1212){return super(t,r,n,i),super.parameter_list=["k"],this.parameter("k",Math.min(s??Math.max(Math.floor(this._N/10),2),this._N-1)),this}transform(){const t=this.X,e=this._d,r=this._N,o=this._D,h=this.parameter("k"),a=n(t,h,null,this._metric),l=new i(h,1,1),_=new i(r,r);for(let e=0;e<r;++e){const r=a[e],n=new i(h,o,((s,n)=>t.entry(r[s].j,n)-t.entry(e,n))),c=n.dot(n.T);if(h>o){const t=s(c.diag)/1e3;for(let e=0;e<h;++e)c.set_entry(e,e,c.entry(e,e)+t)}let u=i.solve_CG(c,l,this._randomizer);u=u.divide(u.sum);for(let t=0;t<h;++t)_.set_entry(e,r[t].j,u.entry(t,0))}const c=new i(r,r,"identity").sub(_),u=c.T.dot(c),{eigenvectors:f}=m(u.T.inverse(),e+1);return this.Y=i.from(f.slice(1,1+e)).T,this.projection}},t.LSP=class extends y{constructor(t,s,r,n=2,i=e,o=1212){return super(t,n,i,o),super.parameter_list=["k","control_points"],this.parameter("k",Math.min(s??Math.max(Math.floor(this._N/10),2),this._N-1)),this.parameter("control_points",Math.min(r??Math.ceil(Math.sqrt(this._N)),this._N-1)),this._is_initialized=!1,this}init(t=g,e=[],s=f){if(this._is_initialized)return this;const r=this.X,n=this._N,o=this.parameter("k"),h=this._d,a=this._metric,l=this.parameter("control_points"),_=new M(r,l,null,a).get_clusters().medoids,c=new i(l,n,"zeros");_.forEach(((t,e)=>{c.set_entry(e,t,1)}));const u=new t(i.from(_.map((t=>r.row(t)))),...e,h).transform(),d=r.to2dArray,p=new s(d,a),m=new i(n,n,"I"),y=-1/o;d.forEach(((t,e)=>{for(const{index:s}of p.search(t,o).iterate())e!==s&&m.set_entry(e,s,y)}));const w=m.concat(c,"vertical"),x=new i(n,h,"zeros").concat(u,"vertical");return this._A=w,this._b=x,this._is_initialized=!0,this}transform(){this.check_init();const t=this._A,e=t.T,s=this._b,r=e.dot(t),n=e.dot(s);return this.Y=i.solve_CG(r,n,this._randomizer),this.projection}},t.LTSA=class extends y{constructor(t,s,r=2,n=e,i=1212){if(super(t,r,n,i),super.parameter_list=["k"],this.parameter("k",Math.min(s??Math.max(Math.floor(this._N/10),2),this._N-1)),this._D<=r)throw`Dimensionality of X (D = ${this._D}) must be greater than the required dimensionality of the result (d = ${r})!`;return this}transform(){const t=this.X,e=this._d,[s,r]=t.shape,o=this.parameter("k"),h=n(t,o,null,this._metric),a=new i(r,r,"center"),l=new i(s,s,0);for(let r=0;r<s;++r){const s=[r,...h[r].map((t=>t.j))];let n=i.from(s.map((e=>t.row(e))));n=n.dot(a);const _=n.dot(n.transpose()),{eigenvectors:c}=m(_,e),u=i.from(c),f=u.transpose().dot(u).add(1/Math.sqrt(o+1));for(let t=0;t<o+1;++t)for(let e=0;e<o+1;++e)l.set_entry(s[t],s[e],l.entry(s[t],s[e])-(t===e?1:0)+f.entry(t,e))}const{eigenvectors:_}=m(l,e+1);return this.Y=i.from(_.slice(1)).transpose(),this.projection}},t.MDS=g,t.Matrix=i,t.OPTICS=class{constructor(t,s,r,n=e){return this._matrix=t,this._epsilon=s,this._min_points=r,this._metric=n,this._ordered_list=[],this._clusters=[],this._DB=new Array(t.shape[0]).fill(),this.init(),this}init(){const t=this._ordered_list,e=this._matrix,s=e.shape[0],r=this._DB,n=this._clusters;let i=this._cluster_index=0;for(let t=0;t<s;++t)r[t]={element:e.row(t),index:t,reachability_distance:void 0,processed:!1};for(const e of r)if(!e.processed&&(e.neighbors=this._get_neighbors(e),e.processed=!0,n.push([e.index]),i=n.length-1,t.push(e),null!=this._core_distance(e))){const t=new c(null,(t=>t.reachability_distance),"min");this._update(e,t),this._expand_cluster(t,n[i])}return this}_get_neighbors(t){if("neighbors"in t)return t.neighbors;const e=this._DB,s=this._metric,r=this._epsilon,n=[];for(const i of e)i.index!=t.index&&s(t.element,i.element)<r&&n.push(i);return n}_core_distance(t){const e=this._min_points,s=this._metric;if(!(t.neighbors&&t.neighbors.length<=e))return s(t.element,t.neighbors[e].element)}_update(t,e){const s=this._metric,r=this._core_distance(t),n=this._get_neighbors(t);for(const i of n){if(i.processed)continue;const n=Math.max(r,s(t.element,i.element));e.raw_data().findIndex((t=>t.element==i))<0?(i.reachability_distance=n,e.push(i)):n<i.reachability_distance&&(i.reachability_distance=n,e=c.heapify(e.data(),(t=>t.reachability_distance),"min"))}}_expand_cluster(t,e){const s=this._ordered_list;for(;!t.empty;){const r=t.pop().element;r.neighbors=this._get_neighbors(r),r.processed=!0,e.push(r.index),s.push(r),null!=this._core_distance(r)&&(this._update(r,t),this._expand_cluster(t,e))}}get_clusters(){const t=[],e=[],s=this._min_points;for(const r of this._clusters)r.length<s?e.push(...r):t.push(r);return t.push(e),t}get_cluster_affirmation(){const t=this._matrix.shape[0],e=new Array(t).fill(),s=this.get_clusters();for(let t=0,r=s.length;t<r;++t){const n=s[t];for(const s of n)e[s]=t<r-1?t:-1}return e}},t.PCA=w,t.Randomizer=l,t.SAMMON=class extends y{constructor(t,s=.1,r=2,n=e,i=1212){return super(t,r,n,i),super.parameter_list=["magic"],this.parameter("magic",s),[this._N,this._D]=this.X.shape,this}init(t="random",e=null){const s=this._N,r=this._d;if("random"===t){const t=this._randomizer;this.Y=new i(s,r,(()=>t.random))}else this.Y=t.transform(this.X);return this.Y,this._metric,this.distance_matrix=e||this.__distance_matrix(this.X),this}__distance_matrix(t){const e=this._metric,s=t.shape[0],r=new i(s,s);for(let n=0;n<s;++n){const i=t.row(n);for(let o=n;o<s;++o){let s=n===o?0:e(i,t.row(o));r.set_entry(n,o,s),r.set_entry(o,n,s)}}return r}transform(t=100){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step();return this.projection}*generator(t=200){this._is_initialized||this.init();for(let e=0;e<t;++e)this._step(),yield this.projection;return this.projection}_step(){const t=this.parameter("magic"),e=this.distance_matrix,s=this._N,r=this._d,n=this._metric;let o=this.Y,h=new i(s,r,0),a=new Float64Array(r);for(let i=0;i<s;++i){let l=new Float64Array(r),_=new Float64Array(r);const c=o.row(i);for(let t=0;t<s;++t){if(i===t)continue;const s=o.row(t),h=new Float64Array(r);for(let t=0;t<r;++t)h[t]=c[t]-s[t];const a=n(c,s),u=e.entry(i,t),f=u-a,d=Math.max(u*a,.01);for(let t=0;t<r;++t)l[t]+=h[t]*f/d,_[t]+=(f-Math.pow(h[t],2)*(1+f/a)/a)/d}for(let e=0;e<r;++e){const s=o.entry(i,e)+(t*l[e]/Math.abs(_[e])||0);h.set_entry(i,e,s),a[e]+=s}}for(let t=0;t<r;++t)a[t]/=s;for(let t=0;t<s;++t)for(let e=0;e<r;++e)o.set_entry(t,e,h.entry(t,e)-a[e]);return o}},t.TSNE=class extends y{constructor(t,s=50,r=10,n=2,o=e,h=1212){return super(t,n,o,h),super.parameter_list=["perplexity","epsilon"],[this._N,this._D]=this.X.shape,this.parameter("perplexity",Math.min(s,this._N-1)),this.parameter("epsilon",r),this._iter=0,this.Y=new i(this._N,this._d,(()=>this._randomizer.random)),this}init(t=null){const e=Math.log(this._perplexity),s=this._N,r=this._D,n=this._metric,o=this.X;let h;if(t)h=t;else{h=new i(s,s);for(let t=0;t<s;++t){const e=o.row(t);for(let r=t+1;r<s;++r){const s=n(e,o.row(r));h.set_entry(t,r,s),h.set_entry(r,t,s)}}}const a=new i(s,s,"zeros");this._ystep=new i(s,r,"zeros"),this._gains=new i(s,r,1);let l=new Array(s).fill(0);for(let t=0;t<s;++t){let r=-1/0,n=1/0,i=1,o=!1,_=0;for(;!o;){let a=0;for(let e=0;e<s;++e){let s=Math.exp(-h.entry(t,e)*i);t===e&&(s=0),l[e]=s,a+=s}let c=0;for(let t=0;t<s;++t){let e=0===a?0:l[t]/a;l[t]=e,e>1e-7&&(c-=e*Math.log(e))}c>e?(r=i,i=n===1/0?2*i:(i+n)/2):(n=i,i=r===-1/0?i/2:(i+r)/2),++_,Math.abs(c-e)<1e-4&&(o=!0),_>=50&&(o=!0)}for(let e=0;e<s;++e)a.set_entry(t,e,l[e])}const _=new i(s,s,"zeros"),c=2*s;for(let t=0;t<s;++t)for(let e=t;e<s;++e){const s=Math.max((a.entry(t,e)+a.entry(e,t))/c,1e-100);_.set_entry(t,e,s),_.set_entry(e,t,s)}return this._P=_,this}transform(t=500){this.check_init();for(let e=0;e<t;++e)this.next();return this.projection}*generator(){for(this.check_init();;)this.next(),yield this.projection}next(){const t=++this._iter,e=this._P,s=this._ystep,r=this._gains,n=this._N,o=this._epsilon,h=this._d;let a=this.Y;const l=t<100?4:1,_=new i(n,n,"zeros");let c=0;for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){let s=0;for(let r=0;r<h;++r){const n=a.entry(t,r)-a.entry(e,r);s+=n*n}const r=1/(1+s);_.set_entry(t,e,r),_.set_entry(e,t,r),c+=2*r}const u=new i(n,n,0);for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){const s=Math.max(_.entry(t,e)/c,1e-100);u.set_entry(t,e,s),u.set_entry(e,t,s)}const f=new i(n,h,"zeros");for(let t=0;t<n;++t)for(let s=0;s<n;++s){const r=4*(l*e.entry(t,s)-u.entry(t,s))*_.entry(t,s);for(let e=0;e<h;++e)f.set_entry(t,e,f.entry(t,e)+r*(a.entry(t,e)-a.entry(s,e)))}let d=new Float64Array(h);for(let e=0;e<n;++e)for(let n=0;n<h;++n){const i=f.entry(e,n),h=s.entry(e,n),l=r.entry(e,n);let _=Math.sign(i)===Math.sign(h)?.8*l:l+.2;_<.01&&(_=.01),r.set_entry(e,n,_);const c=(t<250?.5:.8)*h-o*_*i;s.set_entry(e,n,c),a.set_entry(e,n,a.entry(e,n)+c),d[n]+=a.entry(e,n)}for(let t=0;t<n;++t)for(let e=0;e<2;++e)a.set_entry(t,e,a.entry(t,e)-d[e]/n);return this.Y}},t.TopoMap=class extends y{constructor(t,s=2,r=e,n=1212){return super(t,s,r,n),super.parameter_list=[],[this._N,this._D]=this.X.shape,this._distance_matrix=new i(this._N,this._N,0),this}__lazy_distance_matrix(t,e,s){const r=this._distance_matrix,n=this.X,i=r.entry(t,e);if(0===i){let i=s(n.row(t),n.row(e));return r.set_entry(t,e,i),r.set_entry(e,t,i),i}return i}_make_minimum_spanning_tree(t=e){const s=this._N,r=[...this.X];let n=new u(r);const i=[];let o=[];for(let e=0;e<s;++e)for(let r=e+1;r<s;++r)o.push([e,r,this.__lazy_distance_matrix(e,r,t)]);o=o.sort(((t,e)=>t[2]-e[2]));for(const[t,e,s]of o){const o=n.find(r[t]),h=n.find(r[e]);o!==h&&(i.push([t,e,s]),n.union(o,h))}return i.sort(((t,e)=>t[2]-e[2]))}init(){return this.Y=new i(this._N,this._d,0),this._Emst=this._make_minimum_spanning_tree(this._metric),this._is_initialized=!0,this}__hull_cross([t,e],[s,r],[n,i]){return(s-t)*(i-e)-(r-e)*(n-t)<=0}__hull(t){const e=t.sort((([t,e],[s,r])=>e-r||t-s)),s=e.length;if(s<=2)return e;const r=[];for(let t=0;t<s;++t){for(;r.length>=2&&this.__hull_cross(r[r.length-2],r[r.length-1],e[t]);)r.pop();r.push(e[t])}const n=[];for(let t=s-1;t>=0;--t){for(;n.length>=2&&this.__hull_cross(n[n.length-2],n[n.length-1],e[t]);)n.pop();n.push(e[t])}return n.pop(),r.pop(),r.concat(n)}__findAngle([t,s],[r,n]){const i=e([t,s],[r,n]);if(0===i)return{sin:0,cos:1};const o=[(r-t)/i,(n-s)/i],h=o[0];let a=Math.sqrt(1-h*h);return a=o[1]>=0?-a:a,{sin:a,cos:h}}__align_hull(t,s,r){let n,i,o,h=-1;for(let r=0;r<t.length;++r){const i=e(t[r],s);(-1===h||n>i)&&(n=i,h=r)}r?(i=t[h],o=t[(h+1)%t.length]):(0==h&&(h=t.length-1),i=t[h],o=t[(h-1)%t.length]);const a={tx:-t[h][0],ty:-t[h][1]};if(t.length>=2){const{sin:t,cos:e}=this.__findAngle(i,o);a.sin=t,a.cos=e}else a.sin=0,a.cos=1;return a}__transform([t,e],{tx:s,ty:r,sin:n,cos:i}){let o=t+s,h=e+r;return[o*i-h*n,o*n+h*i]}__transform_component(t,e,s){const r=t.length;for(let n=0;n<r;++n){const r=t[n],[i,o]=this.__transform(r,e);r[0]=i,r[1]=o+s}}__align_components(t,e,s){const r=[...t.__disjoint_set.children],n=[...e.__disjoint_set.children],i=this.__hull(r),o=this.__hull(n),h=this.__align_hull(i,t,!1),a=this.__align_hull(o,e,!0);this.__transform_component(r,h,0),this.__transform_component(n,a,s)}transform(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],s=new u(e.map(((t,e)=>(t.i=e,t))));for(const[r,n,i]of t){const t=s.find(e[r]),o=s.find(e[n]);t!==o&&(this.__align_components(t,o,i),s.union(t,o))}return this.projection}*generator(){this._is_initialized||this.init();const t=this._Emst,e=[...this.Y],s=new u(e.map(((t,e)=>(t.i=e,t))));for(const[r,n,i]of t){const t=s.find(e[r]),o=s.find(e[n]);t!==o&&(this.__align_components(t,o,i),s.union(t,o),yield this.projection)}return this.projection}},t.TriMap=class extends y{constructor(t,s=500,r=5,n=2,i=e,o=1212){return super(t,n,i,o),super.parameter_list=["weight_adj","c"],this.parameter("weight_adj",s),this.parameter("c",r),this}init(t=null,e=null){const s=this.X,r=s.shape[0],n=this._d,o=this._metric,h=this._c;this.n_inliers=2*h,this.n_outliers=1*h,this.n_random=1*h,this.Y=t||new w(s,n).transform(),this.knn=e||new f(s.to2dArray,o);const{triplets:a,weights:l}=this._generate_triplets(this.n_inliers,this.n_outliers,this.n_random);return this.triplets=a,this.weights=l,this.lr=1e3*r/a.shape[0],this.C=1/0,this.tol=1e-7,this.vel=new i(r,n,0),this.gain=new i(r,n,1),this}_generate_triplets(t,e,s){const r=this._metric,n=this._weight_adj,o=this.X,h=o.shape[0],a=this.knn,l=Math.min(t+20,h),_=new i(h,l),c=new i(h,l);for(let t=0;t<h;++t)a.search(o.row(t),l+1).raw_data().filter((t=>0!=t.value)).sort(((t,e)=>t.value-e.value)).forEach(((e,s)=>{_.set_entry(t,s,e.element.index),c.set_entry(t,s,e.value)}));const u=new Float64Array(h);for(let t=0;t<h;++t)u[t]=Math.max((c.entry(t,3)+c.entry(t,4)+c.entry(t,5)+c.entry(t,6))/4,1e-10);const f=this._find_p(c,u,_);let d=this._sample_knn_triplets(f,_,t,e),p=d.shape[0];const m=new Float64Array(p);for(let t=0;t<p;++t){const e=d.entry(t,0),s=d.entry(t,2);m[t]=r(o.row(e),o.row(s))}let y=this._find_weights(d,f,_,m,u);if(s>0){const{random_triplets:t,random_weights:e}=this._sample_random_triplets(o,s,u);d=d.concat(t,"vertical"),y=Float64Array.from([...y,...e])}p=d.shape[0];let w=-1/0;for(let t=0;t<p;++t)isNaN(y[t])&&(y[t]=0),w<y[t]&&(w=y[t]);let g=-1/0;for(let t=0;t<p;++t)y[t]/=w,y[t]+=1e-4,y[t]=Math.log(1+n*y[t]),g<y[t]&&(g=y[t]);for(let t=0;t<p;++t)y[t]/=g;return{triplets:d,weights:y}}_find_p(t,e,s){const[r,n]=t.shape;return new i(r,n,((r,n)=>Math.exp(-(t.entry(r,n)**2)/e[r]/e[s.entry(r,n)])))}_sample_knn_triplets(t,e,s,r){const n=e.shape[0],o=new i(n*s*r,3);for(let i=0;i<n;++i){let h=i*s*r;const a=this.__argsort(t.row(i).map((t=>-t)));for(let t=0;t<s;++t){let s=t*r;const l=e.entry(i,a[t]),_=this._rejection_sample(r,n,a.slice(0,t+1));for(let t=0;t<r;++t){const e=h+s+t,r=_[t];o.set_entry(e,0,i),o.set_entry(e,1,l),o.set_entry(e,2,r)}}}return o}__argsort(t){return t.map(((t,e)=>({d:t,i:e}))).sort(((t,e)=>t.d-e.d)).map((t=>t.i))}_rejection_sample(t,e,s){const r=this._randomizer,n=h(0,e-1).filter((t=>s.indexOf(t)<0));return r.choice(n,Math.min(t,n.length-2))}_find_weights(t,e,s,r,n){const i=t.shape[0],o=new Float64Array(i);for(let h=0;h<i;++h){const i=t.entry(h,0),a=s.row(i).indexOf(t.entry(h,1)),l=e.entry(i,a);let _=Math.exp(-(r[h]**2)/(n[i]*n[t.entry(h,2)]));_<1e-20&&(_=1e-20),o[h]=l/_}return o}_sample_random_triplets(t,e,s){const r=this._metric,n=this._randomizer,o=t.shape[0],a=new i(o*e,3),l=new Float64Array(o*e);for(let i=0;i<o;++i){const _=i*e,c=[...h(0,i-1),...h(i+1,o-1)];for(let o=0;o<e;++o){let[e,h]=n.choice(c,2),u=Math.exp(-(r(t.row(i),t.row(e))**2)/(s[i]*s[e]));u<1e-20&&(u=1e-20);let f=Math.exp(-(r(t.row(i),t.row(h))**2)/(s[i]*s[h]));f<1e-20&&(f=1e-20),u<f&&([e,h]=[h,e],[u,f]=[f,u]);const d=_+o;a.set_entry(d,0,i),a.set_entry(d,1,e),a.set_entry(d,2,h),l[d]=u/f}}return{random_triplets:a,random_weights:l}}_grad(t){const e=this.n_inliers,s=this.n_outliers,r=this.triplets,n=this.weights,[o,h]=t.shape,a=r.shape[0],l=new i(o,h,0);let _=new Array(h).fill(0),c=new Array(h).fill(0),u=1,f=1,d=0,p=0;const m=o*e*s;for(let e=0;e<a;++e){const[i,o,a]=r.row(e);if(e%s==0||e>=m){u=1,f=1;for(let e=0;e<h;++e){const s=t.entry(i,e),r=t.entry(o,e),n=t.entry(a,e);_[e]=s-r,c[e]=s-n,u+=_[e]**2,f+=c[e]**2}}else{f=1;for(let e=0;e<h;++e){const s=t.entry(i,e),r=t.entry(a,e);c[e]=s-r,f+=c[e]**2}}u>f&&++d,p+=n[e]/(1+f/u);const y=(n[e]/(u+f))**2;for(let t=0;t<h;++t){const e=_[t]*f*y,s=c[t]*u*y;l.set_entry(i,t,l.entry(i,t)+e-s),l.set_entry(o,t,l.entry(o,t)-e),l.set_entry(a,t,l.entry(a,t)+s)}}return{grad:l,loss:p,n_viol:d}}transform(t=400){this.check_init();for(let e=0;e<t;++e)this._next(e);return this.projection}*generator(){this.check_init();for(let t=0;t<800;++t)this._next(t),yield this.projection;return this.projection}_next(t){const e=t>150?.5:.3,s=this.C,r=this.vel,n=this.Y.add(r.mult(e)),{grad:i,loss:o,n_viol:h}=this._grad(n);return this.C=o,this.Y=this._update_embedding(n,t,i),this.lr*=s>o+this.tol?1.01:.9,this.Y}_update_embedding(t,e,s){const[r,n]=t.shape,i=e>150?.9:.5,o=this.gain,h=this.vel,a=this.lr;for(let e=0;e<r;++e)for(let r=0;r<n;++r){const n=Math.sign(h.entry(e,r))!=Math.sign(s.entry(e,r))?o.entry(e,r)+.2:Math.max(.8*o.entry(e,r),.01);o.set_entry(e,r,n),h.set_entry(e,r,i*h.entry(e,r)-a*o.entry(e,r)*s.entry(e,r)),t.set_entry(e,r,t.entry(e,r)+h.entry(e,r))}return t}},t.UMAP=class extends y{constructor(t,s=15,r=1,n=1,o=2,h=e,a=1212){return super(t,o,h,a),super.parameter_list=["n_neighbors","local_connectivity","min_dist"],[this._N,this._D]=this.X.shape,s=Math.min(this._N-1,s),this.parameter("n_neighbors",s),this.parameter("local_connectivity",Math.min(r,s-1)),this.parameter("min_dist",n),this._iter=0,this._spread=1,this._set_op_mix_ratio=1,this._repulsion_strength=1,this._negative_sample_rate=5,this._n_epochs=350,this._initial_alpha=1,this.Y=new i(this._N,this._d,(()=>this._randomizer.random)),this}_find_ab_params(t,e){const r=h(0,3*t,300),n=h(0,3*t,300);for(let s=0,i=r.length;s<i;++s){const i=r[s];n[s]=i<e?1:Math.exp(-(i-e)/t)}return x((t=>{const e=h(1,300).map(((e,s)=>{return n[s]-(i=r[s],o=t[0],h=t[1],1/(1+o*Math.pow(i,2*h)));var i,o,h}));return Math.sqrt(s(e.map((t=>t*t))))}),[1,1])}_compute_membership_strengths(t,e,s){for(let r=0,n=t.length;r<n;++r)for(let n=0,i=t[r].length;n<i;++n){const i=t[r][n].value-s[r];t[r][n].value=i>0?Math.exp(-i/e[r]):1}return t}_smooth_knn_dist(t,e){const s=1e-5,r=.001,n=this._local_connectivity,i=Math.log2(e),o=[],h=[],a=this.X,l=a.shape[0],_=[];if("precomputed"===this._metric)for(let s=0;s<l;++s)_.push(t.search(s,e).reverse());else for(const s of a)_.push(t.search(s,e).raw_data().reverse());for(let t=0;t<l;++t){let a=0,l=1/0,c=1;const u=_[t],f=u.filter((t=>t.value>0)),d=f.length;if(d>=n){const e=Math.floor(n),r=n-e;e>0?(o.push(f[e-1]),r>s&&(o[t].value+=r*(f[e].value-f[e-1]))):o[t].value=r*f[0].value}else d>0&&(o[t]=f[d-1].value);for(let r=0;r<64;++r){let r=0;for(let s=0;s<e;++s){const e=u[s].value-o[t];r+=e>0?Math.exp(-e/c):1}if(Math.abs(r-i)<s)break;r>i?[l,c]=[c,(a+l)/2]:[a,c]=l===1/0?[c,2*c]:[c,(a+l)/2]}h[t]=c;const p=u.reduce(((t,e)=>t+e.value),0)/u.length;if(o[t]>0)h[t]<r*p&&(h[t]=r*p);else{const e=_.reduce(((t,e)=>t+e.reduce(((t,e)=>t+e.value),0)/e.length));h[t]>r*e&&(h[t]=r*e)}}return{distances:_,sigmas:h,rhos:o}}_fuzzy_simplicial_set(t,e){const s=t.shape[0],r=this._metric,n="precomputed"===r?new d(t,"precomputed"):new f(t.to2dArray,r);let{distances:o,sigmas:h,rhos:a}=this._smooth_knn_dist(n,e);o=this._compute_membership_strengths(o,h,a);const l=new i(s,s,"zeros");for(let t=0;t<s;++t){const e=o[t];for(let s=0;s<e.length;++s)l.set_entry(t,e[s].element.index,e[s].value)}const _=l.T,c=l.mult(_);return l.add(_).sub(c).mult(this._set_op_mix_ratio).add(c.mult(1-this._set_op_mix_ratio))}_make_epochs_per_sample(t){const e=this._weights,s=new Float32Array(e.length).fill(-1),r=_(e),n=e.map((e=>t*(e/r)));for(let e=0;e<s.length;++e)n[e]>0&&(s[e]=Math.round(t/n[e]));return s}_tocoo(t){const e=[],s=[],r=[],[n,i]=t.shape;for(let o=0;o<n;++o)for(let n=0;n<i;++n){const i=t.entry(o,n);0!==i&&(e.push(o),s.push(n),r.push(i))}return{rows:e,cols:s,data:r}}init(){const[t,e]=this._find_ab_params(this._spread,this._min_dist);this._a=t,this._b=e,this._graph=this._fuzzy_simplicial_set(this.X,this._n_neighbors);const{rows:s,cols:r,data:n}=this._tocoo(this._graph);return this._head=s,this._tail=r,this._weights=n,this._epochs_per_sample=this._make_epochs_per_sample(this._n_epochs),this._epochs_per_negative_sample=this._epochs_per_sample.map((t=>t*this._negative_sample_rate)),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice(),this}set local_connectivity(t){this._local_connectivity=t}get local_connectivity(){return this._local_connectivity}set min_dist(t){this._min_dist=t}get min_dist(){return this._min_dist}graph(){return this.check_init(),{cols:this._head,rows:this._tail,weights:this._weights}}transform(t){this.check_init(),t=t||this._n_epochs;for(let e=0;e<t;++e)this.next();return this.projection}*generator(){for(this.check_init(),this._iter=0;this._iter<this._n_epochs;)this.next(),yield this.projection;return this.projection}_clip(t){return t>4?4:t<-4?-4:t}_optimize_layout(t,e,s,n){const{_d:i,_alpha:o,_repulsion_strength:h,_a:a,_b:l,_epochs_per_sample:_,_epochs_per_negative_sample:c,_epoch_of_next_negative_sample:u,_epoch_of_next_sample:f,_clip:d}=this,p=n.length;for(let m=0,y=_.length;m<y;++m)if(f[m]<=this._iter){const y=s[m],w=n[m],g=t.row(y),x=e.row(w),A=r(g,x);let M=0;A>0&&(M=-2*a*l*Math.pow(A,l-1)/(a*Math.pow(A,l)+1));for(let s=0;s<i;++s){const r=d(M*(g[s]-x[s]))*o,n=g[s]+r,i=x[s]-r;g[s]=n,x[s]=i,t.set_entry(y,s,n),e.set_entry(w,s,i)}f[m]+=_[m];const v=(this._iter-u[m])/c[m];for(let s=0;s<v;++s){const s=Math.floor(this._randomizer.random*p),_=e.row(n[s]),c=r(g,_);let u=0;if(c>0)u=2*h*l/((.01+c)*(a*Math.pow(c,l)+1));else if(y===s)continue;for(let r=0;r<i;++r){const i=d(u*(g[r]-_[r]))*o,h=g[r]+i,a=_[r]-i;g[r]=h,_[r]=a,t.set_entry(y,r,h),e.set_entry(n[s],r,a)}}u[m]+=v*c[m]}return t}next(){let t=++this._iter,e=this.Y;return this._alpha=this._initial_alpha*(1-t/this._n_epochs),this.Y=this._optimize_layout(e,e,this._head,this._tail),this.Y}},t.canberra=function(t,e){if(t.length!==e.length)return;let s=t.length,r=0;for(let n=0;n<s;++n)r+=Math.abs(t[n]-e[n])/(Math.abs(t[n])+Math.abs(e[n]));return r},t.chebyshev=function(t,e){if(t.length!=e.length)return;let s=t.length,r=[];for(let n=0;n<s;++n)r.push(Math.abs(t[n]-e[n]));return Math.max(...r)},t.cosine=function(t,e){if(t.length!==e.length)return;let s=t.length,r=0,n=0,i=0;for(let o=0;o<s;++o)r+=t[o]*e[o],n+=t[o]*t[o],i+=e[o]*e[o];return Math.acos(r/(Math.sqrt(n)*Math.sqrt(i)))},t.distance_matrix=o,t.euclidean=e,t.euclidean_squared=r,t.hamming=function(t,e){if(t.length!=e.length)return;const s=t.length;let r=0;for(let n=0;n<s;++n){r+=t[n]!=e[n]}return r/s},t.jaccard=function(t,e){if(t.length!=e.length)return;const s=t.length;let r=0,n=0;for(let i=0;i<s;++i){const s=0!=t[i],o=0!=e[i];r+=s||o,n+=s&&o}return(r-n)/r},t.k_nearest_neighbors=n,t.kahan_sum=function(t){let e,s,r=t.length,n=0,i=0;for(let o=0;o<r;++o)e=t[o]-i,s=n+e,i=s-n-e,n=s;return n},t.linspace=h,t.manhattan=function(t,e){if(t.length!=e.length)return;let s=t.length,r=0;for(let n=0;n<s;++n)r+=Math.abs(t[n]-e[n]);return r},t.max=_,t.neumair_sum=s,t.norm=a,t.powell=x,t.qr=p,t.simultaneous_poweriteration=m,t.sokal_michener=function(t,e){if(t.length!=e.length)return;const s=t.length;let r=0;for(let n=0;n<s;++n){r+=0!=t[n]!=(0!=e[n])}return 2*r/(s+r)},t.version="0.3.16",t.yule=function(t,e){if(t.length!=e.length)return;const s=t.length;let r=0,n=0,i=0;for(let o=0;o<s;++o){const s=0!=t[o],h=0!=e[o];r+=s&&h,n+=s&&!h,i+=!s&&s}return 0==n||0==i?0:2*n*i/(r*(s-r-n-i)+n*i)},Object.defineProperty(t,"__esModule",{value:!0})}));
