// https://renecutura.eu v0.0.2 Copyright 2019 Rene Cutura
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t=t||self).druid=t.druid||{})}(this,function(t){"use strict";function e(t,e){return Math.sqrt(s(t,e))}function r(t){let e=t.length,r=0,s=0;for(let i=0;i<e;++i){let e=t[i],n=r+e;Math.abs(r)>=Math.abs(e)?s+=r-n+e:s+=e-n+r,r=n}return r+s}function s(t,e){if(t.length!=e.length)return;let s=t.length,i=new Array(s);for(let r=0;r<s;++r){let s=t[r],n=e[r];i[r]=(s-n)*(s-n)}return r(i)}function i(t,e){if(t.length!=e.length)return;let r=t.length,s=[];for(let i=0;i<r;++i)s.push(Math.abs(t[i]-e[i]));return Math.max(...s)}function n(t,r,s=null,i=e){let n=t.length,h=s||l(t,i);for(let t=0;t<n;++t)h[t]=h[t].map((e,r)=>({i:t,j:r,distance:h[t][r]})).sort((t,e)=>t.distance-e.distance).slice(1,r+1);return h}function l(t,r=e){let s=r;if(void 0===s)return;let i=t.length,n=new Array(i);for(let t=0;t<i;++t)n[t]=new Float64Array(i);for(let e=0;e<i;++e)for(let r=e+1;r<i;++r)n[e][r]=n[r][e]=s(t[e],t[r]);return n}function h(t,e,r=null){if(r||(r=Math.max(Math.round(e-t)+1,1)),r<2)return 1===r?[t]:[];let s=new Array(r);for(let i=r-=1;i>=0;--i)s[i]=(i*e+(r-i)*t)/r;return s}function o(t,r=e){let s=null;if(t instanceof c){let[e,r]=t.shape;if(1===e)s=t.row(0);else{if(1!==r)throw"matrix must be 1d!";s=t.col(0)}}else s=t;let i=s.length,n=new Array(i);return n.fill(0),r(s,n)}function _(t){let[s,i]=t.shape,n=new c(s,i,"identity"),l=new c(i,i,0);for(let h=0;h<i;++h){let i=t.col(h);for(let t=0;t<h;++t){let e=n.col(t),s=r(e.map((t,e)=>t*i[e]));l.set_entry(t,h,s),i=i.map((t,r)=>t-s*e[r])}let _=o(i,e);for(let t=0;t<s;++t)n.set_entry(t,h,i[t]/_);l.set_entry(h,h,_)}return{R:l,Q:n}}function a(t,e=2,s=100,i=19870307){let n=new m(i);t instanceof c||(t=c.from(t));let l=t.shape[0],{Q:h,R:o}=_(new c(l,e,()=>n.random));for(;s--;){let e=o.clone(),i=_(t.dot(h));[h,o]=[i.Q,i.R],r(o.sub(e).diag)/l<1e-12&&(s=0)}return{eigenvalues:o.diag,eigenvectors:h.transpose().to2dArray}}class c{constructor(t=null,e=null,r=null){if(this._rows=t,this._cols=e,this._data=null,t&&e){if(!r)return this._data=new Float64Array(t*e),this;if("function"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}if("string"==typeof r){if("zeros"===r)return new c(t,e,0);if("identity"===r||"I"===r){this._data=new Float64Array(t*e);for(let r=0;r<t;++r)this._data[r*e+r]=1;return this}if("center"===r&&t==e){this._data=new Float64Array(t*e),r=((e,r)=>(e===r?1:0)-1/t);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}}if("number"==typeof r){this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r;return this}}return this}static from(t,e="row"){if(t instanceof c)return t.clone();if(!(Array.isArray(t)||t instanceof Float64Array)){if("number"==typeof t)return new c(1,1,t);throw"error"}{let r=t.length;if(0===r)throw"Array is empty";if(!(Array.isArray(t[0])||t[0]instanceof Float64Array)){if("row"===e)return new c(1,r,(e,r)=>t[r]);if("col"===e)return new c(r,1,(e,r)=>t[e]);throw"1d array has NaN entries"}if(Array.isArray(t[0])||t[0]instanceof Float64Array){let e=t[0].length;for(let s=0;s<r;++s)if(t[s].length!==e)throw"various array lengths";return new c(r,e,(e,r)=>t[e][r])}}}row(t){let e=new Array(this._cols);for(let r=0;r<this._cols;++r)e[r]=this._data[t*this._cols+r];return e}set_row(t,e){let r=this._cols;if(Array.isArray(e)&&e.length===r){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e[t]}else if(e instanceof c&&e.shape[1]===r&&1===e.shape[0]){let s=t*r;for(let t=0;t<r;++t)this._data[s+t]=e._data[t]}return this}col(t){let e=new Array(this._rows);for(let r=0;r<this._rows;++r)e[r]=this._data[r*this._cols+t];return e}entry(t,e){return this._data[t*this._cols+e]}set_entry(t,e,r){return this._data[t*this._cols+e]=r,this}transpose(){return new c(this._cols,this._rows,(t,e)=>this.entry(e,t))}get T(){return this.transpose()}inverse(){const t=this._rows,e=this._cols;let r=new c(t,2*e,(t,r)=>r>=e?t===r-e?1:0:this.entry(t,r)),s=0,i=0;for(;s<t&&i<e;){var n=0;let l=-1/0;for(let e=s;e<t;++e){let t=Math.abs(r.entry(e,i));l<t&&(n=e,l=t)}if(0==r.entry(n,i))i++;else{for(let t=0;t<2*e;++t){let e=r.entry(s,t),i=r.entry(n,t);r.set_entry(s,t,e),r.set_entry(n,t,i)}for(let n=s+1;n<t;++n){let t=r.entry(n,i)/r.entry(s,i);r.set_entry(n,i,0);for(let l=i+1;l<2*e;++l)r.set_entry(n,l,r.entry(n,l)-r.entry(s,l)*t)}s++,i++}}for(let s=0;s<t;++s){let t=r.entry(s,s);for(let i=s;i<2*e;++i)r.set_entry(s,i,r.entry(s,i)/t)}for(let s=t-1;s>=0;--s){let t=r.entry(s,s);for(let i=0;i<s;i++){let n=r.entry(i,s)/t;for(let t=i;t<2*e;++t){let e=r.entry(i,t);e-=r.entry(s,t)*n,r.set_entry(i,t,e)}}}return new c(t,e,(t,s)=>r.entry(t,s+e))}dot(t){if(t instanceof c){let e=this;if(e.shape[1]!==t.shape[0])return;let s=e.shape[1];return new c(e.shape[0],t.shape[1],(i,n)=>{let l=e.row(i),h=t.col(n);for(let t=0;t<s;++t)l[t]*=h[t];return r(l)})}if(Array.isArray(t)||t instanceof Float64Array){let e=this._rows;if(t.length!==e)return;let s=new Array(e);for(let i=0;i<e;++i)s[i]=r(this.row(i).map(e=>e*t[i]));return s}}outer(t){let e=this,r=e._data.length;if(r!=t._data.length)return;let s=new c;return s.shape=[r,r,(r,i)=>r<=i?e._data[r]*t._data[i]:s.entry(i,r)],s}static bidiagonal(t){t=t.clone();let[e,r]=t.shape;for(let s=0;s<r;++s){let i=t.col(s).slice(s),n=o(i),l=t.col(s).slice(s);l[0]=i[0]+(i[0]<0?-1:1)*n;let h=o(l);l=l.map(t=>t/=h),l=c.from(l,"col");let _=t.get_block(s,s);_=_.sub(l.mult(2).outer(l).dot(_)),t.set_block(s,s,_);for(let r=s+1;r<e;++r)t.set_entry(r,s,0);if(s<=r-2){let e=t.row(s).slice(s+1),i=o(e),n=t.row(s).slice(s+1);n[0]=e[0]+(e[0]<0?-1:1)*i;let l=o(n);n=n.map(t=>t/=l),n=c.from(n,"col");let h=t.get_block(s,s+1);h=h.sub(h.dot(n.mult(2).outer(n))),t.set_block(s,s+1,h);for(let e=s+2;e<r;++e)t.set_entry(s,e,0)}}return t}set_block(t,e,r){let[s,i]=r.shape;for(let n=0;n<s;++n)if(!(n>this._rows))for(let s=0;s<i;++s)s>this._cols||this.set_entry(n+t,s+e,r.entry(n,s));return this}get_block(t,e){let[r,s]=this.shape;return new c(r-t,s-e,(r,s)=>this.entry(r+t,s+e))}_apply_array(t,e){const r=this._data,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let l=0;l<i;++l){const i=s+l,h=r[i];r[i]=t(h,e(n,l))}}return this}_apply_rowwise_array(t,e){return this._apply_array(e,(e,r)=>t[r])}_apply_colwise_array(t,e){const r=this._data,[s,i]=this.shape;for(let n=0;n<s;++n){const s=n*i;for(let l=0;l<i;++l){const i=s+l,h=r[i];r[i]=e(h,t[n])}}return this}_apply(t,e){let r=this._data;if(t instanceof c){let[s,i]=t.shape,[n,l]=this.shape;if(1===s){if(l!==i)return;for(let s=0;s<n;++s)for(let i=0;i<l;++i)r[s*l+i]=e(r[s*l+i],t.entry(0,i))}else if(1===i){if(n!==s)return;for(let s=0;s<n;++s)for(let i=0;i<l;++i)r[s*l+i]=e(r[s*l+i],t.entry(s,0))}else{if(n!=s||l!=i)return;for(let s=0;s<n;++s)for(let i=0;i<l;++i)r[s*l+i]=e(r[s*l+i],t.entry(s,i))}}else if(Array.isArray(t)){let s=this._rows,i=this._cols;if(t.length===s)for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[n]);else{if(t.length!==i)return;for(let n=0;n<s;++n)for(let s=0;s<i;++s)r[n*i+s]=e(r[n*i+s],t[s])}}else for(let s=0,i=this._rows*this._cols;s<i;++s)r[s]=e(r[s],t);return this}clone(){let t=new c;return t._rows=this._rows,t._cols=this._cols,t._data=this._data.slice(0),t}mult(t){return this.clone()._apply(t,(t,e)=>t*e)}divide(t){return this.clone()._apply(t,(t,e)=>t/e)}add(t){return this.clone()._apply(t,(t,e)=>t+e)}sub(t){return this.clone()._apply(t,(t,e)=>t-e)}get shape(){return[this._rows,this._cols]}set shape([t,e,r=(()=>0)]){this._rows=t,this._cols=e,this._data=new Float64Array(t*e);for(let s=0;s<t;++s)for(let t=0;t<e;++t)this._data[s*e+t]=r(s,t);return this}get to2dArray(){const t=this._rows,e=this._cols;let r=new Array(t);for(let s=0;s<t;++s){let t=new Array(e);for(let r=0;r<e;++r)t[r]=this.entry(s,r);r[s]=t}return r}get diag(){const t=this._rows,e=this._cols,r=Math.min(t,e);let s=new Array(r);for(let t=0;t<r;++t)s[t]=this.entry(t,t);return s}get mean(){const t=this._data,e=this._rows*this._cols;let r=0;for(let s=0;s<e;++s)r+=t[s];return r/e}get meanRows(){const t=this._data,e=this._rows,r=this._cols;let s=[];for(let i=0;i<e;++i){s[i]=0;for(let e=0;e<r;++e)s[i]+=t[i*r+e];s[i]/=r}return s}get meanCols(){const t=this._data,e=this._rows,r=this._cols;let s=[];for(let i=0;i<r;++i){s[i]=0;for(let n=0;n<e;++n)s[i]+=t[n*r+i];s[i]/=e}return s}static solve(t,e){let[r,s]=t.shape,{L:i,U:n}=c.LU(t),l=e.clone();for(let t=0;t<r;++t){for(let e=0;e<t-1;++e)l.set_entry(0,t,l.entry(0,t)-i.entry(t,e)*l.entry(1,e));l.set_entry(0,t,l.entry(0,t)/i.entry(t,t))}for(let t=r-1;t>=0;--t){for(let e=r-1;e>t;--e)l.set_entry(0,t,l.entry(0,t)-n.entry(t,e)*l.entry(0,e));l.set_entry(0,t,l.entry(0,t)/n.entry(t,t))}return l}static LU(t){let e,r=t.shape[0],s=new c(r,r,"zeros"),i=new c(r,r,"identity");for(let n=0;n<r;++n){for(let l=n;l<r;++l){e=0;for(let t=0;t<n;++t)e+=s.entry(l,t)*i.entry(t,n);s.set_entry(l,n,t.entry(l,n)-e)}for(let l=n;l<r;++l){if(0===s.entry(n,n))return;e=0;for(let t=0;t<n;++t)e+=s.entry(n,t)*i.entry(t,l);i.set_entry(n,l,(t.entry(n,l)-e)/s.entry(n,n))}}return{L:s,U:i}}static SVD(t,e=2){let r=t.transpose().dot(t),s=t.dot(t.transpose()),{eigenvectors:i,eigenvalues:n}=a(r,e),{eigenvectors:l}=a(s,e);return{U:l,Sigma:n.map(t=>Math.sqrt(t)),V:i}}}class f{constructor(t,r="single",s=e){return this._id=0,this._matrix=t,this._metric=s,this._linkage=r,this.init(),this.root=this.do(),this}get_clusters(t,e="distance"){let r,s=[];switch(e){case"distance":r=(t=>t.dist);break;case"depth":r=(t=>t.depth);break;default:throw"invalid type"}return this._traverse(this.root,r,t,s),s}_traverse(t,e,r,s){e(t)<=r?s.push(t.leaves()):(this._traverse(t.left,e,r,s),this._traverse(t.right,e,r,s))}init(){const t=this._metric,e=this._matrix,r=this._n=e.shape[0],s=this._d_min=new Float64Array(r),i=this._distance_matrix=new Array(r);for(let n=0;n<r;++n){s[n]=0,i[n]=new Float64Array(r);for(let l=0;l<r;++l)i[n][l]=n===l?1/0:t(e.row(n),e.row(l)),i[n][s[n]]>i[n][l]&&(s[n]=l)}const n=this._clusters=new Array(r),l=this._c_size=new Uint16Array(r);for(let t=0;t<r;++t)n[t]=[],n[t][0]=new d(this._id++,null,null,0,e.row(t),t,1,0),l[t]=1;return this}do(){const t=this._n,e=this._d_min,r=this._distance_matrix,s=this._clusters,i=this._c_size,n=this._linkage;let l=null;for(let h=0,o=t-1;h<o;++h){let h=0;for(let s=0;s<t;++s)r[s][e[s]]<r[h][e[h]]&&(h=s);let o=e[h],_=s[h][0],a=s[o][0],c=new d(this._id++,_,a,r[h][o]);s[h].unshift(c),i[h]+=i[o];for(let e=0;e<t;++e)switch(n){case"single":r[h][e]>r[o][e]&&(r[e][h]=r[h][e]=r[o][e]);break;case"complete":r[h][e]<r[o][e]&&(r[e][h]=r[h][e]=r[o][e]);break;case"average":r[e][h]=r[h][e]=(i[h]*r[h][e]+i[o]*r[o][e])/(i[h]+i[e])}r[h][h]=1/0;for(let e=0;e<t;++e)r[e][o]=r[o][e]=1/0;for(let s=0;s<t;++s)e[s]===o&&(e[s]=h),r[h][s]<r[h][e[h]]&&(e[h]=s);l=c}return l}}class d{constructor(t,e,r,s,i,n,l,h){return this.id=t,this.left=e,this.right=r,this.dist=s,this.index=n,this.size=null!=l?l:e.size+r.size,this.depth=null!=h?h:1+Math.max(e.depth,r.depth),this.centroid=null!=i?i:this._calculate_centroid(e,r),this}_calculate_centroid(t,e){const r=t.size,s=e.size,i=t.centroid,n=e.centroid,l=this.size,h=t.centroid.length,o=new Float64Array(h);for(let t=0;t<h;++t)o[t]=(r*i[t]+s*n[t])/l;return o}get isLeaf(){return 0===this.depth}leaves(){if(this.isLeaf)return[this.index];const t=this.left,e=this.right;return(t.isLeaf?[t.index]:t.leaves()).concat(e.isLeaf?[e.index]:e.leaves())}}class u{constructor(t,r=e){this._A=t,this._metric=r,this._N=t.shape[0];const s=this._fiedler_vector(t);return this._ordering=h(0,this._N-1).sort((t,e)=>s[t]-s[e]),this}get ordering(){return this._ordering}_fiedler_vector(t){const e=this._gershgorin_bound(t),r=t.shape[0];return a(new c(r,r,(r,s)=>r===s?e-t.entry(r,s):-t.entry(r,s)),2).eigenvectors[1]}_gershgorin_bound(t){let e=0,r=t.shape[0];for(let s=0;s<r;++s){let i=t.entry(s,s);for(let e=0;e<r;++e)s!==e&&(i+=Math.abs(t.entry(s,e)));e=e>i?e:i}return e}}class p{constructor(t,r=e){this._A=t;const s=t.shape[0],i=this._hclust=new f(t,"complete",r),n=this._distance_matrix=new Array(s);for(let e=0;e<s;++e){n[e]=new Float64Array(s);for(let i=0;i<s;++i)n[e][i]=e===i?1/0:r(t.row(e),t.row(i))}this._order_map=new Map;let l=1/0;this._optimal_order=null;let h=i.root.left.leaves(),o=i.root.right.leaves();for(let t=0,e=h.length;t<e;++t)for(let e=0,r=o.length;e<r;++e){let r=this.order(i.root,h[t],o[e]);r[0]<l&&(l=r[0],this._optimal_order=r[1])}return this}get ordering(){return this._optimal_order}order(t,e,r){const s=this._order_map,i=`k${t.id}-${e}-${r}`;if(s.has(i))return s.get(i);{let n=this._order(t,e,r);return s.set(i,n),n}}_order(t,e,r){if(t.isLeaf)return[0,[t.index]];const s=this._distance_matrix;let i,n,l=t.left,h=t.right,o=l?l.leaves():[],_=h?h.leaves():[];if(-1!==o.indexOf(e)&&-1!==_.indexOf(r))i=l,n=h;else{if(-1===_.indexOf(e)||-1===o.indexOf(r))throw"Node is not common ancestor of i and j";i=h,n=l}let a=i.left?i.left.leaves():[],c=i.right?i.right.leaves():[],f=-1!=c.indexOf(e)?a:c;0===f.length&&(f=[e]);let d=n.left?n.left.leaves():[],u=n.right?n.right.leaves():[],p=-1!=u.indexOf(r)?d:u;0===p.length&&(p=[r]);let m=1/0,y=[];for(let t=0,l=f.length;t<l;++t){let l=this.order(i,e,f[t]);for(let e=0,i=p.length;e<i;++e){let i=this.order(n,p[e],r),h=l[0]+s[f[t]][p[e]]+i[0];h<m&&(m=h,y=l[1].concat(i[1]))}}return[m,y]}}class m{constructor(t){return this._N=624,this._M=397,this._MATRIX_A=2567483615,this._UPPER_MASK=2147483648,this._LOWER_MASK=2147483647,this._mt=new Array(this._N),this._mti=this.N+1,this.seed=t||(new Date).getTime(),this}set seed(t){this._seed=t;let e=this._mt;for(e[0]=t>>>0,this._mti=1;this._mti<this._N;this._mti+=1){let t=this._mti,r=e[t-1]^e[t-1]>>>30;e[t]=(1812433253*((4294901760&r)>>>16)<<16)+1812433253*(65535&r)+t,e[t]>>>=0}}get seed(){return this._seed}get random(){return this.random_int*(1/4294967296)}get random_int(){let t,e=new Array(0,this._MATRIX_A);if(this._mti>=this._N){let r;this._mti==this._N+1&&(this.seed=5489);let s=this._N-this._M,i=this._M-this._N;for(r=0;r<s;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+this._M]^t>>>1^e[1&t];for(;r<this._N-1;++r)t=this._mt[r]&this._UPPER_MASK|this._mt[r+1]&this._LOWER_MASK,this._mt[r]=this._mt[r+i]^t>>>1^e[1&t];t=this._mt[this._N-1]&this._UPPER_MASK|this._mt[0]&this._LOWER_MASK,this._mt[this._N-1]=this._mt[this._M-1]^t>>>1^e[1&t],this._mti=0}return t=this._mt[this._mti+=1],t^=t>>>11,t^=t<<7&2636928640,t^=t<<15&4022730752,(t^=t>>>18)>>>0}static choice(t,e,r=19870307){let[s,i]=t.shape;if(e>s)throw"n bigger than A!";let n=new m(r),l=new Array(e),o=h(0,s-1);for(let t=0,r=o.length;t<e;++t,--r){let e=n.random_int%r;l[t]=o.splice(e,1)[0]}return l.map(e=>t.row(e))}}class y{constructor(t=null,e=(t=>t),r="min"){if(this._accessor=e,this._container=[],this._comparator="min"==r?(t,e)=>t<=e:"max"==r?(t,e)=>t>=e:r,t&&t.length>0){let e=this;t.forEach(t=>e.push(t))}}_get_left_child_index(t){return 2*t+1}_get_right_child_index(t){return 2*t+2}_get_parent_index(t){return Math.floor((t-1)/2)}_has_parent(t){return this._get_parent_index(t)>=0}_has_left_child(t){return this._get_left_child_index(t)<this._container.length}_has_right_child(t){return this._get_right_child_index(t)<this._container.length}_left_child(t){return this._container[this._get_left_child_index(t)]}_right_child(t){return this._container[this._get_right_child_index(t)]}_parent(t){return this._container[this._get_parent_index(t)]}_swap(t,e){let r=this._container[e];this._container[e]=this._container[t],this._container[t]=r}push(t){const e=this._accessor(t),r=new g(t,e);return this._container.push(r),this._heapify_up(),this}_heapify_up(t){let e=t||this._container.length-1;for(;this._has_parent(e)&&!this._comparator(this._parent(e).value,this._container[e].value);)this._swap(e,this._get_parent_index(e)),e=this._get_parent_index(e)}pop(){if(0===this._container.length)return null;if(1===this._container.length)return this._container.pop().element;const t=this._container[0];return this._container[0]=this._container.pop(),this._heapify_down(),t}_heapify_down(t=0){let e=t,r=null;for(;this._has_left_child(e)&&(r=this._has_right_child(e)&&this._comparator(this._right_child(e).value,this._left_child(e).value)?this._get_right_child_index(e):this._get_left_child_index(e),!this._comparator(this._comparator(this._container[e].value,this._container[r].value)));)this._swap(e,r),e=r}get first(){return this._container.length>0?this._container[0]:null}*iterate(){for(let t=0,e=this._container.length;t<e;++t)yield this._container[t].element}toArray(){const t=this._comparator,e=this._accessor;return this._container.sort((r,s)=>t(e(r.element),e(s.element))?-1:1)}get length(){return this._container.length}get empty(){return 0===this.length}}class g{constructor(t,e){this.element=t,this.value=e}}class w{constructor(t=null,r=e){return this._Node=class{constructor(t,e=null,r=null,s=null){this.pivot=t,this.child1=e,this.child2=r,this.radius=s}},this._Leaf=class{constructor(t){this.points=t}},this._metric=r,t&&this.add(t),this}add(t){return t=t.map((t,e)=>({index:e,element:t})),this._root=this._construct(t),this}_construct(t){if(1===t.length)return new this._Leaf(t);{let e,r=this._greatest_spread(t),s=t.sort((t,e)=>t.element[r]-e.element[r]),i=s.length,n=Math.floor(i/2),l=t[n],h=s.slice(0,n),o=s.slice(n,i),_=Math.max(...t.map(t=>this._metric(l.element,t.element)));return e=h.length>0&&o.length>0?new this._Node(l,this._construct(h),this._construct(o),_):new this._Leaf(t)}}_greatest_spread(t){let e=t[0].element.length,r=new Array(e);for(let t=0;t<e;++t)r[t]=[1/0,-1/0];let s=t.reduce((t,r)=>{for(let s=0;s<e;++s)t[s][0]=Math.min(t[s][0],r.element[s]),t[s][1]=Math.max(t[s][1],r.element[s]);return t},r);s=s.map(t=>t[1]-t[0]);let i=0;for(let t=0;t<e;++t)i=s[t]>s[i]?t:i;return i}search(t,e=5){return this._search(t,e,new y(null,e=>this._metric(e.element,t),"max"),this._root)}_search(t,e,r,s){if(r.length>=e&&s.pivot&&s.radius&&this._metric(t,s.pivot.element)-s.radius>=r.first.value)return r;if(s.child1&&this._search(t,e,r,s.child1),s.child2&&this._search(t,e,r,s.child2),s.points)for(let t=0,i=s.points.length;t<i;++t){let i=s.points[t];e>r.length?r.push(i):(r.push(i),r.pop())}return r}}class v{constructor(t,r=2,s=e){this.X=t,this.d=r,this._metric=s}transform(){const t=this.X,e=t.shape[0],r=this._metric;let s=[],i=[];for(let t=0;t<e;++t)s.push(0),i.push(0);let n=0;const l=new c;l.shape=[e,e,(e,h)=>{let o=0;return e<h?o=r(t.row(e),t.row(h)):e>h&&(o=l.entry(h,e)),s[e]+=o,i[h]+=o,n+=o,o}],this._d_X=l,s=s.map(t=>t/e),i=i.map(t=>t/e),n/=e**2;const h=new c(e,e,(t,e)=>l.entry(t,e)-s[t]-i[e]+n),{eigenvectors:o}=a(h,this.d);return this.Y=c.from(o).transpose(),this.Y}get projection(){return this.Y}get stress(){const t=this.X.shape[0],r=this.Y,s=this._d_X,i=new c;i.shape=[t,t,(t,s)=>t<s?e(r.row(t),r.row(s)):i.entry(s,t)];let n=0,l=0;for(let e=0;e<t;++e)for(let r=e+1;r<t;++r)n+=Math.pow(s.entry(e,r)-i.entry(e,r),2),l+=Math.pow(s.entry(e,r),2);return Math.sqrt(n/l)}}function A(t,e,r=300){const s=e.length;let i=.001,n=1e4,l=e.slice(),h=t(l),o=!1;for(;r-- >=0&&!o;){o=!0;for(let e=0;e<s;++e){l[e]+=1e-6;let r=t(l);l[e]-=1e-6;let s=(r-h)/1e-6;Math.abs(s)>.01&&(o=!1),l[e]-=i*s,h=t(l)}i*=n>=h?1.05:.4,n=h}return l}t.Randomizer=m,t.kahan_sum=function(t){let e,r,s=t.length,i=0,n=0;for(let l=0;l<s;++l)n=(r=i+(e=t[l]-n))-i-e,i=r;return i},t.neumair_sum=r,t.euclidean=e,t.euclidean_squared=s,t.cosine=function(t,e){if(t.length!==e.length)return;let r=t.length,s=0,i=0,n=0;for(let l=0;l<r;++l)s+=t[l]*e[l],i+=t[l]*t[l],n+=e[l]*e[l];return s/(Math.sqrt(i)*Math.sqrt(n))},t.manhattan=function(t,e){if(t.length!=e.length)return;let r=t.length,s=0;for(let i=0;i<r;++i)s+=Math.abs(t[i]-e[i]);return s},t.chebyshev=i,t.k_nearest_neighbors=n,t.distance_matrix=l,t.linspace=h,t.norm=o,t.Matrix=c,t.Reorder=class{constructor(t){this._A=t,this._optimal_leaf_order=null}get available(){return["optimal_leaf_order","spectral_order"]}reorder(t="optimal_leaf_order",r=e){let s=null;switch(t){case"optimal_leaf_order":this._optimal_leaf_order=new p(this._A,r),s=this._optimal_leaf_order.ordering;break;case"spectral_order":this._spectral_order=new u(this._A,r),s=this._spectral_order.ordering}return s}},t.HNSW=class{constructor(t=e,r=!0,s=5,i=200,n=null,l=null){this._metric=t,this._select=r?this._select_heuristic:this._select_simple,this._m=s,this._ef=i,this._m0=n||2*s,this._graph=[],this._ep=null,this._L=null,this._mL=null===l?1/Math.log2(s):l,this.search=this.search}addOne(t){this.add([t])}add(...t){const e=this._m,r=this._ef,s=this._m0,i=this._mL;let n=this._graph;for(const l of t){let t=this._ep?Array.from(this._ep):null,h=[],o=this._L,_=Math.floor(-Math.log(Math.random()*i)),a=Math.min(o,_);if(o){for(let e=n.length-1;e>a;--e)t=this._search_layer(l,t,1,e);for(let i=a;i>=0;--i){let o=n[i];o.points.push(l),h=this._search_layer(l,t,r,i);let _=this._select(l,h,e,i);_.forEach(t=>{t!==l&&(o.edges.push({idx1:t,idx2:l}),o.edges.push({idx1:l,idx2:t}))});let a=0===i?s:e;for(let t of _){let e=o.edges.filter(e=>e.idx1===t).map(t=>t.idx2);if(e.length>a){let r=this._select(t,e,a,i);o.edges=o.edges.filter(e=>e.idx1!==t),r.forEach(e=>{t!==e&&o.edges.push({idx1:t,idx2:e})})}}t=h}}if(n.length<_||_>o){for(let t=_,e=n.length;t>=e;--t){let e={l_c:t,points:[l],edges:new Array};n.push(e),t===_&&(this._ep=[l],this._L=_)}n=n.sort((t,e)=>t.l_c-e.l_c)}}return this}_select_heuristic(t,e,r,s,i=!0,n=!0){if(s>this._graph.length-1)return e;const l=this._metric,h=this._graph[s];let o=[],_=new Set(e);if(i)for(let t of e)for(let{idx2:e}of h.edges.filter(e=>e.idx1===t))_.add(e);let a=new y(Array.from(_),e=>l(e,t),"min"),c=new y(null,e=>l(e,t),"min");for(;a.first&&o.length<r;){let e=a.pop(),r=Math.floor(Math.random()*o.length);0===o.length||e.value<l(o[r],t)?o.push(e.element):c.push(e.element)}if(n)for(;c.first&&o.length<r;)o.push(c.pop().element);return o}_select_simple(t,e,r){const s=this._metric;return e.sort((e,r)=>s(e,t)-s(r,t)).slice(0,r)}_search_layer(t,e,r,s){const i=this._metric,n=this._graph.find(t=>t.l_c===s);let l=new Set(e),h=new y(e,e=>i(e,t),"min"),o=new y(e,e=>i(e,t),"max");for(;h.length>0;){let e=h.pop(),s=o.first;if(e.value>s.value)break;for(let{idx2:_}of n.edges.filter(t=>t.idx1===e.element))l.has(_)||(l.add(_),s=o.first.element,(i(_,t)<i(s,t)||o.length<r)&&(h.push(_),o.push(_),o.length>r&&o.pop()))}return o.toArray().reverse().slice(0,r)}search(t,e,r=null){r=r||1;let s=this._ep;for(let e=this._L;e>0;--e)s=this._search_layer(t,s,r,e);return s=this._search_layer(t,s,e,0)}*search_iter(t,e,r=null){r=r||1;let s=this._ep?Array.from(this._ep):null,i=this._L;yield{l_c:i,ep:[t]};for(let e=i;e>0;--e)yield{l_c:e,ep:s},s=this._search_layer(t,s,r,e),yield{l_c:e,ep:s};yield{l_c:0,ep:s},s=this._search_layer(t,s,e,0),yield{l_c:0,ep:s}}},t.BallTree=w,t.Heap=y,t.qr=_,t.qr_householder=function(t){let[e,r]=t.shape,s=new c(e,e,"identity"),i=t.clone();for(let t=0;t<r;++t){let e=i.get_block(t,t).col(0),r=o(e),n=e[0],l=-Math.sign(n),h=n-l*r,_=e.map(t=>t/h);_[0]=1;let a=-l*h/r;_=c.from(_,"col");let f=i.get_block(t,0);i.set_block(t,0,f.sub(_.dot(_.T.dot(f)).mult(a)));let d=s.get_block(0,t);s.set_block(0,t,d.sub(d.dot(_).dot(_.T)))}for(let t=1;t<e;++t)for(let e=0;e<t;++e)i.set_entry(t,e,0);return{R:i,Q:s}},t.simultaneous_poweriteration=a,t.lu=function(t){let e,r=t.shape[0],s=new c(r,r,"zeros"),i=new c(r,r,"identity");for(let n=0;n<r;++n){for(let l=n;l<r;++l){e=0;for(let t=0;t<n;++t)e+=s.entry(l,t)*i.entry(t,n);s.set_entry(l,n,t.entry(l,n)-e)}for(let l=n;l<r;++l){if(0===s.entry(n,n))return;e=0;for(let t=0;t<n;++t)e+=s.entry(n,t)*i.entry(t,l);i.set_entry(n,l,(t.entry(n,l)-e)/s.entry(n,n))}}return{L:s,U:i}},t.svrg=function(t,e,r,s=20,i=10,n=1,l){let[h,_]=t.shape;const a=new m(l);let f=(e=(e=new c(_,1,()=>a.random)).divide(o(e))).clone(),d=t.T.dot(t).divide(h),u=e.clone();for(let l=0;l<s;++l){const s=d.dot(u);for(let l=0;l<i;++l){const i=e.T.dot(u).entry(0,0),l=c.from(m.choice(t,n)),h=l.T.dot(l),_=e.clone(),a=h.dot(e.divide(n)),d=h.dot(u.mult(i/n));e=a.sub(d).add(s.mult(i).sub(f.mult(r))),f=_;const p=o(e);e=e.divide(p),f=f.divide(p)}u=e.clone()}return e},t.poweriteration_m=function(t,e,r,s=20,i){let n=new m(i),[l,h]=t.shape,_=t.T.dot(t).divide(l);null===e&&(e=new c(h,1,()=>n.random));let a=(e=e.divide(o(e))).clone();for(let t=0;t<s;++t){let t=a.clone();a=_.dot(a).sub(e.mult(r)),e=t;let s=o(a);a=a.divide(s),e=e.divide(s)}return a},t.poweriteration_n=function(t,e,s,i,n=100,l){const h=new m(l),_=t.shape[0];let a=[];if(null==s){s=new Array(e);for(let t=0;t<e;++t){s[t]=new Float64Array(_),a[t]=new Float64Array(_);for(let e=0;e<_;++e){const r=h.random;s[t][e]=r,a[t][e]=r}let e=o(s[t]);s[t]=s[t].map(t=>t/e)}}for(let i=0;i<e;++i){let e=a[i];for(let l=0;l<n;++l){for(let t=0;t<i;++t){const s=a[t],i=r(new Float64Array(_).map((t,r)=>e[r]*s[r]));for(let t=0;t<_;++t)e[t]=e[t]-i*s[t]}let n=t.dot(e);const l=o(n);if(s[i]=n.map(t=>t/l),r(new Float64Array(_).map((t,r)=>n[r]*e[r]))>1-1e-12)break;[e,n]=[n,e]}}return{eigenvalues:a,eigenvectors:s}},t.PCA=class{constructor(t,e=2){this.X=t,this.d=e}transform(){let t=this.X,e=t.shape[1],r=new c(e,e,"center"),s=t.dot(r),i=s.transpose().dot(s),{eigenvectors:n}=a(i,this.d);return console.log(n),n=c.from(n).transpose(),this.Y=t.dot(n),this.Y}get projection(){return this.Y}},t.MDS=v,t.ISOMAP=class{constructor(t,r,s=2,i=e){this.X=t,this.k=r||Math.floor(this.X.shape[0]/10),this.d=s,this._metric=i}transform(){let t=this.X,e=t.shape[0],r=new c;r.shape=[e,e,(e,s)=>e<=s?this._metric(t.row(e),t.row(s)):r.entry(s,e)];let s=[];for(let t=0;t<e;++t){let e=r.row(t).map((t,e)=>({index:e,distance:t})),i=new y(e,t=>t.distance,"min");s.push(i.toArray().slice(1,this.k+1))}let i=new c(e,e,(t,e)=>{let r=s[t].find(t=>t.index===e);return r?r.distance:1/0});for(let t=0;t<e;++t)for(let r=0;r<e;++r)for(let s=0;s<e;++s)i.set_entry(t,r,Math.min(i.entry(t,r),i.entry(t,s)+i.entry(s,r)));let n=[],l=[];for(let t=0;t<e;++t)n.push(0),l.push(0);let h=0,o=new c(e,e,(t,e)=>{let r=i.entry(t,e);return r=r===1/0?0:r,n[t]+=r,l[e]+=r,h+=r,r});n=n.map(t=>t/e),l=l.map(t=>t/e),h/=e**2;let _=new c(e,e,(t,e)=>o.entry(t,e)-n[t]-l[e]+h),{eigenvectors:f}=a(_,this.d);return this.Y=c.from(f).transpose(),this.Y}get projection(){return this.Y}},t.FASTMAP=class{constructor(t,r=2,s=e){this.X=t,this.d=r,this._metric=s,this._col=-1,this.randomizer=new m(1212)}_choose_distant_objects(t){let e=this.X.shape[0],r=this.randomizer.random_int%e-1,s=null,i=-1/0;for(let n=0;n<e;++n){let e=t(r,n);e>i&&(i=e,s=n)}i=-1/0;for(let n=0;n<e;++n){let e=t(s,n);e>i&&(i=e,r=n)}return[r,s,i]}transform(){let t=this.X,[e,r]=t.shape,s=new c(e,this.d),i=(e,r)=>this._metric(t.row(e),t.row(r)),n=i;for(;this._col<this.d-1;){this._col+=1;let t=this._col,[r,l,h]=this._choose_distant_objects(i);if(0===h)for(let r=0;r<e;++r)s.set_entry(r,t,0);else{for(let n=0;n<e;++n){let e=(i(r,n)**2+h**2-i(l,n)**2)/(2*h);s.set_entry(n,t,e)}i=((e,r)=>Math.sqrt(n(e,r)**2-(s.entry(e,t)-s.entry(r,t))**2))}}return this.Y=s,this.Y}get projection(){return this.Y}},t.LDA=class{constructor(t,r,s=2,i=e){this.X=t,this._labels=r,this.d=s,this._metric=i}transform(){let t=this.X,[e,r]=t.shape,s=this._labels,i={},n=0;s.forEach((e,r)=>{e in i?(i[e].count++,i[e].rows.push(t.row(r))):i[e]={id:n++,count:1,rows:[t.row(r)]}});let l=t.mean,h=new c(n,r);for(let t in i){let e=c.from(i[t].rows).meanCols;for(let s=0;s<r;++s)h.set_entry(i[t].id,s,e[s])}let o=new c(r,r);for(let t in i){let e=h.row(i[t].id),s=new c(r,1,t=>e[t]-l),n=i[t].count;o=o.add(s.dot(s.transpose()).mult(n))}let _=new c(r,r);for(let t in i){let e=h.row(i[t].id),s=new c(r,1,t=>e[t]),n=i[t].rows;for(let e=0,l=i[t].count;e<l;++e){let t=new c(r,1,(t,r)=>n[e][t]-s.entry(t,0));_=_.add(t.dot(t.transpose()))}}let{eigenvectors:f}=a(_.inverse().dot(o),this.d);return f=c.from(f).transpose(),this.Y=t.dot(f),this.Y}get projection(){return this.Y}},t.LLE=class{constructor(t,r,s=2,i=e){this.X=t,this._k=r,this.d=s,this._metric=i}transform(){let t=this.X,e=this.d,[s,i]=t.shape,l=this._k,h=n(t.to2dArray,l,null,this._metric),o=new c(l,1,1),_=new c(s,s);for(let e=0;e<s;++e){let s=new c(l,i,(r,s)=>t.entry(h[e][r].j,s)-t.entry(e,s)),n=s.dot(s.transpose());if(l>i){let t=r(n.diag)/1e3;for(let e=0;e<l;++e)n.set_entry(e,e,n.entry(e,e)+t)}let a=c.solve(n,o),f=r(a.col(0));a=a.divide(f);for(let t=0;t<l;++t)_.set_entry(e,h[e][t].j,a.entry(t,0))}let f=new c(s,s,"identity").sub(_),d=f.transpose().dot(f),{eigenvectors:u}=a(d.transpose().inverse(),e+1);return this.Y=c.from(u.slice(1,1+e)).transpose(),this.Y}get projection(){return this.Y}},t.MLLE=class{constructor(t,r,s=2,i=e){this.X=t,this._k=r,this.d=s,this._metric=i}transform(){let t=this.X,e=this.d,[s,i]=t.shape,l=this._k,h=n(t.to2dArray,l,null,this._metric),_=new c(l,1,1),f=new c(s,l),d=new c(s,s),u=new Array(s),p=new Array(s),m=new Array(s);for(let i=0;i<s;++i){let s=h[i].map(t=>t.j),n=c.from(t.row(i),"row"),o=c.from(s.map(e=>t.row(e))),d=(o=o.sub(n)).dot(o.transpose()),y=r(d.diag)/1e3;for(let t=0;t<l;++t)d.set_entry(t,t,d.entry(t,t)+y);let{eigenvalues:g,eigenvectors:w}=a(d,l);u[i]=w,p[i]=g,m.push(r(g.slice(e+1))/r(g.slice(0,e)));let v=c.solve(d,_),A=r(v.col(0));v=v.divide(A);for(let t=0;t<l;++t)f.set_entry(i,t,v.entry(t,0))}let y=m.sort((t,e)=>t-e)[Math.ceil(s/2)];for(let t=0;t<s;++t){let s=h[t].map(t=>t.j),i=p[t],n=i.map((t,e)=>({l:e,ratio:r(i.slice(l-e+1))/r(i.slice(0,l-e)),"Î»":t}));n=n.filter(t=>t.ratio<y&&t.l<=l-e).map(t=>t.l).pop()||e;let _=u[t];_=_.slice(l-n);let a=1/Math.sqrt(n)*o(_[0].map((t,e)=>r(_.map(t=>t[e]))));_=c.from(_);let m=new c(n,1,a),g=new c(l,1,1),w=o((m=m.sub(_.dot(g))).col(0));m=w<1e-12?m.mult(0):m.divide(w),_=_.T,g=new c(n,1,1);let v=c.from(f.row(t),"col"),A=_.sub(_.dot(m).dot(m.T).mult(2)).add(v.mult(1-a).dot(g.T));A=A.dot(A.T);for(let t=0;t<l+1;++t)for(let e=0;e<n;++e)d.set_entry(s[t],s[e],d.entry(s[t],s[e])-(t===e?1:0)+A.entry(t,e))}let{eigenvectors:g}=a(d,e+1);return this.Y=c.from(g.slice(1)).transpose(),this.Y}get projection(){return this.Y}},t.LTSA=class{constructor(t,r,s=2,i=e){this.X=t,this._k=r,this.d=s,this._metric=i}transform(){let t=this.X,e=this.d,[r,s]=t.shape,i=this._k,l=n(t.to2dArray,i,null,this._metric),h=new c(s,s,"center"),o=new c(r,r,0);for(let s=0;s<r;++s){let r=[s,...l[s].map(t=>t.j)],n=c.from(r.map(e=>t.row(e))),_=(n=n.dot(h)).dot(n.transpose()),{eigenvectors:f}=a(_,e),d=c.from(f),u=d.transpose().dot(d).add(1/Math.sqrt(i+1));for(let t=0;t<i+1;++t)for(let e=0;e<i+1;++e)o.set_entry(r[t],r[e],o.entry(r[t],r[e])-(t===e?1:0)+u.entry(t,e))}let{eigenvectors:_}=a(o,e+1);return this.Y=c.from(_.slice(1)).transpose(),this.Y}get projection(){return this.Y}},t.TSNE=class{constructor(t,r,s,i=2,n=e,l=1212){this._X=t,this._d=i,[this._N,this._D]=t.shape,this._perplexity=r,this._epsilon=s,this._metric=n,this._iter=0,this.randomizer=new m(l),this._Y=new c(this._N,this._d,()=>this.randomizer.random)}init(t=null){let e=Math.log(this._perplexity),r=t||new c(this._N,this._N,(t,e)=>this._metric(this._X.row(t),this._X.row(e))),s=new c(this._N,this._N,"zeros");this._ystep=new c(this._N,this._D,"zeros").to2dArray,this._gains=new c(this._N,this._D,1).to2dArray;let i=new Array(this._N).fill(0);for(let t=0,n=this._N;t<n;++t){let l=-1/0,h=1/0,o=1,_=!1,a=50,c=1e-4,f=0;for(;!_;){let s=0;for(let e=0;e<n;++e){let n=Math.exp(-r.entry(t,e)*o);t===e&&(n=0),i[e]=n,s+=n}let d=0;for(let t=0;t<n;++t){let e=0===s?0:i[t]/s;i[t]=e,e>1e-7&&(d-=e*Math.log(e))}d>e?(l=o,o=h===1/0?2*o:(o+h)/2):(h=o,o=l===-1/0?o/2:(o+l)/2),++f,Math.abs(d-e)<c&&(_=!0),f>=a&&(_=!0)}for(let e=0;e<n;++e)s.set_entry(t,e,i[e])}let n=new c(this._N,this._N,"zeros"),l=2*this._N;for(let t=0,e=this._N;t<e;++t)for(let r=0;r<e;++r)n.set_entry(t,r,Math.max((s.entry(t,r)+s.entry(r,t))/l,1e-100));return this._P=n,this}set perplexity(t){this._perplexity=t}get perplexity(){return this._perplexity}set epsilon(t){this._epsilon=t}get epsilon(){return this._epsilon}transform(t=1e3){for(let e=0;e<t;++e)this.next();return this._Y}*transform_iter(){for(;;)this.next(),yield this._Y}next(){let t=++this._iter,e=this._P,r=this._ystep,s=this._gains,i=this._Y,n=this._N,l=this._epsilon,h=this._d,o=t<100?4:1,_=new c(n,n,"zeros"),a=0;for(let t=0;t<n;++t)for(let e=t+1;e<n;++e){let r=0;for(let s=0;s<h;++s){let n=i.entry(t,s)-i.entry(e,s);r+=n*n}let s=1/(1+r);_.set_entry(t,e,s),_.set_entry(e,t,s),a+=2*s}let f=new c(n,n,(t,e)=>Math.max(_.entry(t,e)/a,1e-100)),d=0,u=[];for(let t=0;t<n;++t){let r=new Array(h).fill(0);for(let s=0;s<n;++s){d+=-e.entry(t,s)*Math.log(f.entry(t,s));let n=4*(o*e.entry(t,s)-f.entry(t,s))*_.entry(t,s);for(let e=0;e<h;++e)r[e]+=n*(i.entry(t,e)-i.entry(s,e))}u.push(r)}let p=new Array(h).fill(0);for(let e=0;e<n;++e)for(let n=0;n<h;++n){let h=u[e][n],o=r[e][n],_=s[e][n],a=Math.sign(h)===Math.sign(o)?.8*_:_+.2;a<.01&&(a=.01),s[e][n]=a;let c=(t<250?.5:.8)*o-l*a*u[e][n];r[e][n]=c,i.set_entry(e,n,i.entry(e,n)+c),p[n]+=i.entry(e,n)}for(let t=0;t<n;++t)for(let e=0;e<2;++e)i.set_entry(t,e,i.entry(t,e)-p[e]/n);return this._Y}get projection(){return this._Y}},t.UMAP=class{constructor(t,r,s,i=2,n=e,l=1212){this._X=t,this._d=i,[this._N,this._D]=t.shape,this._local_connectivity=r,this._min_dist=s,this._metric=n,this._iter=0,this._n_neighbors=11,this._spread=1,this._set_op_mix_ratio=1,this._repulsion_strength=1,this._negative_sample_rate=5,this._n_epochs=200,this._initial_alpha=1,this._randomizer=new m(l),this._Y=new c(this._N,this._d,()=>this._randomizer.random)}_find_ab_params(t,e){for(var s=h(0,3*t,300),i=h(0,3*t,300),n=0,l=s.length;n<l;++n)s[n]<e?i[n]=1:i[n]=Math.exp(-(s[n]-e)/t);var[o,_]=A(function(t){var e=h(1,300).map((e,r)=>i[r]-function(t,e,r){return 1/(1+e*Math.pow(t,2*r))}(s[r],t[0],t[1]));return Math.sqrt(r(e.map(t=>t*t)))},[1,1]);return[o,_]}_compute_membership_strengths(t,e,r){for(let s=0,i=t.length;s<i;++s)for(let i=0,n=t[s].length;i<n;++i){let n=t[s][i].value-r[s],l=1;n>0&&(l=Math.exp(-n/e[s])),t[s][i].value=l}return t}_smooth_knn_dist(t,e){const r=this._local_connectivity,s=1*Math.log2(e),i=[],n=[],l=this._X;let h=[];for(let s=0,i=l.shape[0];s<i;++s){let i=l.row(s);h.push(t.search(i,Math.max(r,e)).toArray().reverse())}for(let t=0,r=l.shape[0];t<r;++t){let r=h[t];i.push(r[0].value);let l=0,o=1/0,_=1;for(let n=0;n<64;++n){let n=0;for(let s=0;s<e;++s){let e=r[s].value-i[t];n+=e>0?Math.exp(-e/_):1}if(Math.abs(n-s)<1e-5)break;n>s?_=(l+(o=_))/2:(l=_,o===1/0?_*=2:_=(l+o)/2)}n[t]=_;const a=r.reduce((t,e)=>t+e.value,0)/r.length;if(i[t]>0)n[t]<.001*a&&(n[t]=.001*a);else{const e=h.reduce((t,e)=>t+e.reduce((t,e)=>t+e.value,0)/e.length);n[t]>.001*e&&(n[t]=.001*e)}}return{distances:h,sigmas:n,rhos:i}}_fuzzy_simplicial_set(t,r){const s=new w(t.to2dArray,e);let{distances:i,sigmas:n,rhos:l}=this._smooth_knn_dist(s,r);i=this._compute_membership_strengths(i,n,l);let h=new c(t.shape[0],t.shape[0],"zeros");for(let e=0,s=t.shape[0];e<s;++e)for(let t=0;t<r;++t)h.set_entry(e,i[e][t].element.index,i[e][t].value);const o=h.T,_=h.mult(o);return h=h.add(o).sub(_).mult(this._set_op_mix_ratio).add(_.mult(1-this._set_op_mix_ratio))}_make_epochs_per_sample(t,e){const{data:r}=this._tocoo(t);let s=new Array(r.length).fill(-1);const i=Math.max(...r),n=r.map(t=>e*(t/i));return s=s.map((t,r)=>n[r]>0?Math.round(e/n[r]):t)}_tocoo(t){const e=[],r=[],s=[],[i,n]=t.shape;for(let l=0;l<i;++l)for(let i=0;i<n;++i){const n=t.entry(l,i);0!==n&&(e.push(l),r.push(i),s.push(n))}return{rows:e,cols:r,data:s}}init(){const[t,e]=this._find_ab_params(this._spread,this._min_dist);this._a=t,this._b=e,this._graph=this._fuzzy_simplicial_set(this._X,this._n_neighbors),this._epochs_per_sample=this._make_epochs_per_sample(this._graph,this._n_epochs),this._epochs_per_negative_sample=this._epochs_per_sample.map(t=>t*this._negative_sample_rate),this._epoch_of_next_sample=this._epochs_per_sample.slice(),this._epoch_of_next_negative_sample=this._epochs_per_negative_sample.slice();const{rows:r,cols:s}=this._tocoo(this._graph);return this._head=r,this._tail=s,this}set local_connectivity(t){this._local_connectivity=t}get local_connectivity(){return this._local_connectivity}set min_dist(t){this._min_dist=t}get min_dist(){return this._min_dist}transform(t=1e3){for(let e=0;e<t;++e)this.next();return this._Y}*transform_iter(){for(this._iter=0;this._iter<this._n_epochs;)this.next(),yield this._Y;return this._Y}_clip(t){return t>4?4:t<-4?-4:t}_optimize_layout(t,r,s,i){const{_d:n,_alpha:l,_repulsion_strength:h,_a:o,_b:_,_epochs_per_sample:a,_epochs_per_negative_sample:c,_epoch_of_next_negative_sample:f,_epoch_of_next_sample:d,_clip:u}=this,p=i.length;for(let m=0,y=a.length;m<y;++m)if(d[m]<=this._iter){const y=s[m],g=i[m],w=t.row(y),v=r.row(g),A=e(w,v);let x=0;A>0&&(x=-2*o*_*Math.pow(A,_-1)/(o*Math.pow(A,_)+1));for(let e=0;e<n;++e){const s=u(x*(w[e]-v[e]))*l,i=w[e]+s,n=v[e]-s;w[e]=i,v[e]=n,t.set_entry(y,e,i),r.set_entry(g,e,n)}d[m]+=a[m];const M=(this._iter-f[m])/c[m];for(let s=0;s<M;++s){const s=Math.floor(this._randomizer.random*p),a=r.row(i[s]),c=e(w,a);let f=0;if(c>0)f=2*h*_/((.01+c)*(o*Math.pow(c,_)+1));else if(y==s)continue;for(let e=0;e<n;++e){const n=u(f*(w[e]-a[e]))*l,h=w[e]+n,o=a[e]-n;w[e]=h,a[e]=o,t.set_entry(y,e,h),r.set_entry(i[s],e,o)}}f[m]+=M*c[m]}return t}next(){let t=++this._iter,e=this._Y;return this._alpha=this._initial_alpha*(1-t/this._n_epochs),this._Y=this._optimize_layout(e,e,this._head,this._tail),this._Y}get projection(){return this._Y}},t.OAP=class{constructor(t,r,s,i,n=2,l=e,h=1212){this._X=t,this._d=n,[this._N,this._D]=t.shape,this._depth_field_lag=r,this._step_size=s,this._depth_weight=i,this._J=3,this._max_iter=1,this._metric=l,this._seed=h,this._randomizer=new m(h)}_data_depth(t="chebyshev"){const e=this._X,r=this._N,s=new Float32Array(r);let n=0;if("mdb"===t)s.fill(1);else if("chebyshev"===t)for(let t=0;t<r;++t){let l=e.row(t),h=0;for(let s=0;s<r;++s)t!==s&&(h+=i(l,e.row(s)));s[t]=1/(1+h/r),s[n]<s[t]&&(n=t)}this._h=s,this._deepest_point=n}init(){this._iter=0;const t=new v(this._X,this._d,this._metric);return this._Y=t.transform(),this._X_distances=t._d_X,this._data_depth(),this._M=this._monotonic_field(this._Y),this}set depth_field_lag(t){this._depth_field_lag=t}get depth_field_lag(){return this._depth_field_lag}set step_size(t){this._step_size=t}get step_size(){return this._step_size}set depth_weight(t){this._depth_weight=t}get depth_weight(){return this._depth_weight}transform(t=this._max_iter){for(let e=0;e<t;++e)this.next();return this._Y}*transform_iter(){for(;;)this.next(),yield this._Y}_monotonic_field(t){const e=this._h,r=(this._Y_,new w);return r.add(t.to2dArray),t=>{let s=r.search(t,5).toArray(),i=0,n=0;for(let t=0;t<5;++t)i+=s[t].value,n+=e[s[t].element.index]*s[t].value;return n/=i}}next(){const t=++this._iter,s=this._depth_field_lag,i=this._step_size,n=this._depth_weight,l=this._N,h=this._d,o=this._X_distances,_=this._h;let a=this._Y;t%s==1&&(this._Y_=this._Y.clone(),this._M=this._monotonic_field(a));const f=this._M,d=new c;d.shape=[l,l,(t,r)=>t<r?e(a.row(t),a.row(r)):d.entry(r,t)];const u=new c;u.shape=[l,l,(t,e)=>t===e?1e-8:t<e?-o.entry(t,e)/d.entry(t,e):u.entry(e,t)];for(let t=0;t<l;++t)u.set_entry(t,t,u.entry(t,t)-r(u.row(t)));const p=u.dot(a).divide(l),m=new c(l,h,(t,e)=>p.entry(t,e)-a.entry(t,e));for(let t=0;t<l;++t){const e=f(a.row(t)),r=f(p.row(t)),s=_[t];for(let l=0;l<h;++l)a.set_entry(t,l,a.entry(t,l)+i*(m.entry(t,l)+2*n*(e-s)*r))}return this._Y=a,this._Y}get projection(){return this._Y}},t.powell=A,t.Hierarchical_Clustering=f,Object.defineProperty(t,"__esModule",{value:!0})});
