<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: matrix/Matrix.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="qR4yTNPnKLOyvQg7l5Nnz"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-clustering.html">clustering</a></div><div class="sidebar-section-children"><a href="module-datastructure.html">datastructure</a></div><div class="sidebar-section-children"><a href="module-dimensionality_reduction.html">dimensionality_reduction</a></div><div class="sidebar-section-children"><a href="module-knn.html">knn</a></div><div class="sidebar-section-children"><a href="module-linear_algebra.html">linear_algebra</a></div><div class="sidebar-section-children"><a href="module-matrix.html">matrix</a></div><div class="sidebar-section-children"><a href="module-metrics.html">metrics</a></div><div class="sidebar-section-children"><a href="module-numerical.html">numerical</a></div><div class="sidebar-section-children"><a href="module-optimization.html">optimization</a></div><div class="sidebar-section-children"><a href="module-utils.html">utils</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="caSScVQ_fQ_SCfWKPmdUA"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BallTree.html">BallTree</a></div><div class="sidebar-section-children"><a href="DisjointSet.html">DisjointSet</a></div><div class="sidebar-section-children"><a href="DR.html">DR</a></div><div class="sidebar-section-children"><a href="FASTMAP.html">FASTMAP</a></div><div class="sidebar-section-children"><a href="Heap.html">Heap</a></div><div class="sidebar-section-children"><a href="Hierarchical_Clustering.html">Hierarchical_Clustering</a></div><div class="sidebar-section-children"><a href="HIPP.html">HIPP</a></div><div class="sidebar-section-children"><a href="HNSW.html">HNSW</a></div><div class="sidebar-section-children"><a href="ISOMAP.html">ISOMAP</a></div><div class="sidebar-section-children"><a href="KMeans.html">KMeans</a></div><div class="sidebar-section-children"><a href="KMedoids.html">KMedoids</a></div><div class="sidebar-section-children"><a href="KNN.html">KNN</a></div><div class="sidebar-section-children"><a href="LDA.html">LDA</a></div><div class="sidebar-section-children"><a href="LLE.html">LLE</a></div><div class="sidebar-section-children"><a href="LSP.html">LSP</a></div><div class="sidebar-section-children"><a href="LTSA.html">LTSA</a></div><div class="sidebar-section-children"><a href="Matrix.html">Matrix</a></div><div class="sidebar-section-children"><a href="MDS.html">MDS</a></div><div class="sidebar-section-children"><a href="module-dimensionality_reduction.exports.SQDMDS.html">exports.SQDMDS</a></div><div class="sidebar-section-children"><a href="NNDescent.html">NNDescent</a></div><div class="sidebar-section-children"><a href="OAP.html">OAP</a></div><div class="sidebar-section-children"><a href="OPTICS.html">OPTICS</a></div><div class="sidebar-section-children"><a href="PCA.html">PCA</a></div><div class="sidebar-section-children"><a href="Randomizer.html">Randomizer</a></div><div class="sidebar-section-children"><a href="SAMMON.html">SAMMON</a></div><div class="sidebar-section-children"><a href="TopoMap.html">TopoMap</a></div><div class="sidebar-section-children"><a href="TriMap.html">TriMap</a></div><div class="sidebar-section-children"><a href="TSNE.html">TSNE</a></div><div class="sidebar-section-children"><a href="UMAP.html">UMAP</a></div><div class="sidebar-section-children"><a href="XMeans.html">XMeans</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="uFORBgSD49s763-i2VFa2"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#Eigenpair">Eigenpair</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">matrix_Matrix.js</h1></header><article><pre class="prettyprint source lang-js"><code>import { neumair_sum } from "../numerical/index.js";
import { simultaneous_poweriteration } from "../linear_algebra/index.js";
import { Randomizer } from "../util/index.js";
/**
 * @class
 * @alias Matrix
 * @requires module:numerical/neumair_sum
 */
export class Matrix {
    /**
     * creates a new Matrix. Entries are stored in a Float64Array.
     * @memberof module:matrix
     * @param {number} rows - The amount of rows of the matrix.
     * @param {number} cols - The amount of columns of the matrix.
     * @param {(function|string|number)} value=0 - Can be a function with row and col as parameters, a number, or "zeros", "identity" or "I", or "center".
     *  - **function**: for each entry the function gets called with the parameters for the actual row and column.
     *  - **string**: allowed are
     *      - "zero", creates a zero matrix.
     *      - "identity" or "I", creates an identity matrix.
     *      - "center", creates an center matrix.
     *  - **number**: create a matrix filled with the given value.
     * @example
     *
     * let A = new Matrix(10, 10, () => Math.random()); //creates a 10 times 10 random matrix.
     * let B = new Matrix(3, 3, "I"); // creates a 3 times 3 identity matrix.
     * @returns {Matrix} returns a {@link rows} times {@link cols} Matrix filled with {@link value}.
     */
    constructor(rows = null, cols = null, value = null) {
        this._rows = rows;
        this._cols = cols;
        this._data = null;
        if (rows &amp;&amp; cols) {
            if (!value) {
                this._data = new Float64Array(rows * cols);
                return this;
            }
            if (typeof value === "function") {
                this._data = new Float64Array(rows * cols);
                for (let row = 0; row &lt; rows; ++row) {
                    for (let col = 0; col &lt; cols; ++col) {
                        this._data[row * cols + col] = value(row, col);
                    }
                }
                return this;
            }
            if (typeof value === "string") {
                if (value === "zeros") {
                    return new Matrix(rows, cols, 0);
                }
                if (value === "identity" || value === "I") {
                    this._data = new Float64Array(rows * cols);
                    for (let row = 0; row &lt; rows; ++row) {
                        this._data[row * cols + row] = 1;
                    }
                    return this;
                }
                if (value === "center" &amp;&amp; rows == cols) {
                    this._data = new Float64Array(rows * cols);
                    value = (i, j) => (i === j ? 1 : 0) - 1 / rows;
                    for (let row = 0; row &lt; rows; ++row) {
                        for (let col = 0; col &lt; cols; ++col) {
                            this._data[row * cols + col] = value(row, col);
                        }
                    }
                    return this;
                }
            }
            if (typeof value === "number") {
                this._data = new Float64Array(rows * cols);
                for (let row = 0; row &lt; rows; ++row) {
                    for (let col = 0; col &lt; cols; ++col) {
                        this._data[row * cols + col] = value;
                    }
                }
                return this;
            }
        }
        return this;
    }

    /**
     * Creates a Matrix out of {@link A}.
     * @param {(Matrix|Array|Float64Array|number)} A - The matrix, array, or number, which should converted to a Matrix.
     * @param {"row"|"col"|"diag"} [type = "row"] - If {@link A} is a Array or Float64Array, then type defines if it is a row- or a column vector.
     * @returns {Matrix}
     *
     * @example
     * let A = Matrix.from([[1, 0], [0, 1]]); //creates a two by two identity matrix.
     * let S = Matrix.from([1, 2, 3], "diag"); // creates a 3 by 3 matrix with 1, 2, 3 on its diagonal. [[1, 0, 0], [0, 2, 0], [0, 0, 3]]
     */
    static from(A, type = "row") {
        if (A instanceof Matrix) {
            return A.clone();
        } else if (Matrix.isArray(A)) {
            let m = A.length;
            if (m === 0) throw new Error("Array is empty");
            // 1d
            if (!Matrix.isArray(A[0])) {
                if (type === "row") {
                    return new Matrix(1, m, (_, j) => A[j]);
                } else if (type === "col") {
                    return new Matrix(m, 1, (i) => A[i]);
                } else if (type === "diag") {
                    return new Matrix(m, m, (i, j) => (i == j ? A[i] : 0));
                } else {
                    throw new Error("1d array has NaN entries");
                }
                // 2d
            } else {
                let n = A[0].length;
                for (let row = 0; row &lt; m; ++row) {
                    if (A[row].length !== n) {
                        throw new Error("various array lengths");
                    }
                }
                return new Matrix(m, n, (i, j) => A[i][j]);
            }
        } else if (typeof A === "number") {
            return new Matrix(1, 1, A);
        } else {
            throw new Error("error");
        }
    }

    /**
     * Returns the {@link row}&lt;sup>th&lt;/sup> row from the Matrix.
     * @param {Number} row
     * @returns {Float64Array}
     */
    row(row) {
        const data = this.values;
        const cols = this._cols;
        return data.subarray(row * cols, (row + 1) * cols);
    }

    /**
     * Returns an generator yielding each row of the Matrix.
     * @yields {Float64Array}
     */
    *iterate_rows() {
        const cols = this._cols;
        const rows = this._rows;
        const data = this.values;
        for (let row = 0; row &lt; rows; ++row) {
            yield data.subarray(row * cols, (row + 1) * cols);
        }
    }

    /**
     * Makes a {@link Matrix} object an iterable object.
     * @yields {Float64Array}
     */
    *[Symbol.iterator]() {
        for (const row of this.iterate_rows()) {
            yield row;
        }
    }

    /**
     * Sets the entries of {@link row}&lt;sup>th&lt;/sup> row from the Matrix to the entries from {@link values}.
     * @param {Number} row
     * @param {Array} values
     * @returns {Matrix}
     */
    set_row(row, values) {
        const cols = this._cols;
        if (Matrix.isArray(values) &amp;&amp; values.length === cols) {
            const offset = row * cols;
            for (let col = 0; col &lt; cols; ++col) {
                this.values[offset + col] = values[col];
            }
        } else if (values instanceof Matrix &amp;&amp; values.shape[1] === cols &amp;&amp; values.shape[0] === 1) {
            const offset = row * cols;
            for (let col = 0; col &lt; cols; ++col) {
                this.values[offset + col] = values._data[col];
            }
        } else {
            throw new Error("Values not valid! Needs to be either an Array, a Float64Array, or a fitting Matrix!")
        }
        return this;
    }

    /**
     * Swaps the rows {@link row1} and {@link row2} of the Matrix.
     * @param {Number} row1
     * @param {Number} row2
     * @returns {Matrix}
     */
    swap_rows(row1, row2) {
        const cols = this._cols;
        const data = this.values;
        for (let i = row1 * cols, j = row2 * cols, col = 0; col &lt; cols; ++col, ++i, ++j) {
            const t = data[i];
            data[i] = data[j];
            data[j] = t;
        }
    }

    /**
     * Returns the {@link col}&lt;sup>th&lt;/sup> column from the Matrix.
     * @param {Number} col
     * @returns {Array}
     */
    col(col) {
        const result_col = new Float64Array(this._rows);
        for (let row = 0; row &lt; this._rows; ++row) {
            result_col[row] = this.values[row * this._cols + col];
        }
        return result_col;
    }

    /**
     * Returns the {@link col}&lt;sup>th&lt;/sup> entry from the {@link row}&lt;sup>th&lt;/sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @returns {float64}
     */
    entry(row, col) {
        return this.values[row * this._cols + col];
    }

    /**
     * Sets the {@link col}&lt;sup>th&lt;/sup> entry from the {@link row}&lt;sup>th&lt;/sup> row of the Matrix to the given {@link value}.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */
    set_entry(row, col, value) {
        this.values[row * this._cols + col] = value;
        return this;
    }

    /**
     * Adds a given {@link value} to the {@link col}&lt;sup>th&lt;/sup> entry from the {@link row}&lt;sup>th&lt;/sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */
    add_entry(row, col, value) {
      this.values[row * this._cols + col] += value;
      return this;
    }

    /**
     * Subtracts a given {@link value} from the {@link col}&lt;sup>th&lt;/sup> entry from the {@link row}&lt;sup>th&lt;/sup> row of the Matrix.
     * @param {int} row
     * @param {int} col
     * @param {float64} value
     * @returns {Matrix}
     */
    sub_entry(row, col, value) {
      this.values[row * this._cols + col] -= value;
      return this;
    }

    /**
     * Returns a new transposed Matrix.
     * @returns {Matrix}
     */
    transpose() {
        let B = new Matrix(this._cols, this._rows, (row, col) => this.entry(col, row));
        return B;
    }

    /**
     * Returns a new transposed Matrix. Short-form of {@function transpose}.
     * @returns {Matrix}
     */
    get T() {
        return this.transpose();
    }

    /**
     * Returns the inverse of the Matrix.
     * @returns {Matrix}
     */
    inverse() {
        const rows = this._rows;
        const cols = this._cols;
        const A = this.clone();
        const B = new Matrix(rows, cols, 'I');

        // foreach column
        for (let col = 0; col &lt; cols; ++col) {
            // Search for maximum in this column (pivot)
            let max_idx = col;
            let max_val = Math.abs(A.entry(col, col));
            for (let row = col + 1; row &lt; rows; ++row) {
                const val = Math.abs(A.entry(row, col));
                if (max_val &lt; val) {
                    max_idx = row;
                    max_val = val;
                }
            }
            if (max_val === 0) {
                throw new Error('Cannot compute inverse of Matrix, determinant is zero');
            }
            // Swap maximum row with current row
            if (max_idx !== col) {
                A.swap_rows(col, max_idx);
                B.swap_rows(col, max_idx);
            }

            // eliminate non-zero values on the other rows at column c
            const A_col = A.row(col);
            const B_col = B.row(col);
            for (let row = 0; row &lt; rows; ++row) {
                if (row !== col) {
                    // eliminate value at column c and row r
                    const A_row = A.row(row);
                    const B_row = B.row(row);
                    if (A_row[col] !== 0) {
                        const f = A_row[col] / A_col[col];
                        // sub (f * row c) from row r to eliminate the value at column c
                        for (let s = col; s &lt; cols; ++s) {
                            A_row[s] -= (f * A_col[s]);
                        }
                        for (let s = 0; s &lt; cols; ++s) {
                            B_row[s] -= (f * B_col[s]);
                        }
                    }
                } else {
                    // normalize value at Acc to 1 (diagonal):
                    // divide each value of row r=c by the value at Acc
                    const f = A_col[col];
                    for (let s = col; s &lt; cols; ++s) {
                        A_col[s] /= f;
                    }
                    for (let s = 0; s &lt; cols; ++s) {
                        B_col[s] /= f;
                    }
                }
            }
        }
        return B;
    }

    /**
     * Returns the dot product. If {@link B} is an Array or Float64Array then an Array gets returned. If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */
    dot(B) {
        if (B instanceof Matrix) {
            let A = this;
            const [rows_A, cols_A] = A.shape;
            const [rows_B, cols_B] = B.shape;
            if (cols_A !== rows_B) {
                throw new Error(`A.dot(B): A is a ${A.shape.join(" ⨯ ")}-Matrix, B is a ${B.shape.join(" ⨯ ")}-Matrix:
                A has ${cols_A} cols and B ${rows_B} rows.
                Must be equal!`);
            }
            const C = new Matrix(rows_A, cols_B, (row, col) => {
                const A_i = A.row(row);
                const B_val = B.values;
                let sum = 0;
                for (let i = 0, j = col; i &lt; cols_A; ++i, j += cols_B) {
                    sum += A_i[i] * B_val[j];
                }
                return sum;
            });
            return C;
        } else if (Matrix.isArray(B)) {
            let rows = this._rows;
            if (B.length !== rows) {
                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);
            }
            let C = new Array(rows);
            for (let row = 0; row &lt; rows; ++row) {
                C[row] = neumair_sum(this.row(row).map((e) => e * B[row]));
            }
            return C;
        } else {
            throw new Error(`B must be Matrix or Array`);
        }
    }

    /**
     * Transposes the current matrix and returns the dot product with {@link B}.
     * If {@link B} is an Array or Float64Array then an Array gets returned.
     * If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */
    transDot(B) {
        if (B instanceof Matrix) {
            let A = this;
            const [cols_A, rows_A] = A.shape; // transpose matrix
            const [rows_B, cols_B] = B.shape;
            if (cols_A !== rows_B) {
                throw new Error(`A.dot(B): A is a ${[rows_A, cols_A].join(" ⨯ ")}-Matrix, B is a ${B.shape.join(" ⨯ ")}-Matrix:
                A has ${cols_A} cols and B ${rows_B} rows, which must be equal!`);
            }
            // let B = new Matrix(this._cols, this._rows, (row, col) => this.entry(col, row));
            // this.values[row * this._cols + col];
            const C = new Matrix(rows_A, cols_B, (row, col) => {
                const A_val = A.values;
                const B_val = B.values;
                let sum = 0;
                for (let i = 0, j = row, k = col; i &lt; cols_A; ++i, j += rows_A, k += cols_B) {
                    sum += A_val[j] * B_val[k];
                }
                return sum;
            });
            return C;
        } else if (Matrix.isArray(B)) {
            let rows = this._cols;
            if (B.length !== rows) {
                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);
            }
            let C = new Array(rows);
            for (let row = 0; row &lt; rows; ++row) {
                C[row] = neumair_sum(this.col(row).map((e) => e * B[row]));
            }
            return C;
        } else {
            throw new Error(`B must be Matrix or Array`);
        }
    }

    /**
     * Returns the dot product with the transposed version of {@link B}.
     * If {@link B} is an Array or Float64Array then an Array gets returned.
     * If {@link B} is a Matrix then a Matrix gets returned.
     * @param {(Matrix|Array|Float64Array)} B the right side
     * @returns {(Matrix|Array)}
     */
    dotTrans(B) {
        if (B instanceof Matrix) {
            let A = this;
            const [rows_A, cols_A] = A.shape;
            const [cols_B, rows_B] = B.shape;
            if (cols_A !== rows_B) {
                throw new Error(`A.dot(B): A is a ${A.shape.join(" ⨯ ")}-Matrix, B is a ${[rows_B, cols_B].join(" ⨯ ")}-Matrix:
                A has ${cols_A} cols and B ${rows_B} rows, which must be equal!`);
            }
            const C = new Matrix(rows_A, cols_B, (row, col) => {
                const A_i = A.row(row);
                const B_i = B.row(col);
                let sum = 0;
                for (let i = 0; i &lt; cols_A; ++i) {
                    sum += A_i[i] * B_i[i];
                }
                return sum;
            });
            return C;
        } else if (Matrix.isArray(B)) {
            let rows = this._rows;
            if (B.length !== rows) {
                throw new Error(`A.dot(B): A has ${rows} cols and B has ${B.length} rows. Must be equal!`);
            }
            let C = new Array(rows);
            for (let row = 0; row &lt; rows; ++row) {
                C[row] = neumair_sum(this.row(row).map((e) => e * B[row]));
            }
            return C;
        } else {
            throw new Error(`B must be Matrix or Array`);
        }
    }

    /**
     * Computes the outer product from {@link this} and {@link B}.
     * @param {Matrix} B
     * @returns {Matrix}
     */
    outer(B) {
        let A = this;
        let l = A._data.length;
        let r = B._data.length;
        if (l != r) return undefined;
        let C = new Matrix();
        C.shape = [
            l,
            l,
            (i, j) => {
                if (i &lt;= j) {
                    return A._data[i] * B._data[j];
                } else {
                    return C.entry(j, i);
                }
            },
        ];
        return C;
    }

    /**
     * Appends matrix {@link B} to the matrix.
     * @param {Matrix} B - matrix to append.
     * @param {"horizontal"|"vertical"|"diag"} [type = "horizontal"] - type of concatenation.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 1], [1, 1]]); // 2 by 2 matrix filled with ones.
     * let B = Matrix.from([[2, 2], [2, 2]]); // 2 by 2 matrix filled with twos.
     *
     * A.concat(B, "horizontal"); // 2 by 4 matrix. [[1, 1, 2, 2], [1, 1, 2, 2]]
     * A.concat(B, "vertical"); // 4 by 2 matrix. [[1, 1], [1, 1], [2, 2], [2, 2]]
     * A.concat(B, "diag"); // 4 by 4 matrix. [[1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 2, 2], [0, 0, 2, 2]]
     */
    concat(B, type = "horizontal") {
        const A = this;
        const [rows_A, cols_A] = A.shape;
        const [rows_B, cols_B] = B.shape;
        if (type == "horizontal") {
            if (rows_A != rows_B) {
                throw new Error(`A.concat(B, "horizontal"): A and B need same number of rows, A has ${rows_A} rows, B has ${rows_B} rows.`);
            }
            const X = new Matrix(rows_A, cols_A + cols_B, "zeros");
            X.set_block(0, 0, A);
            X.set_block(0, cols_A, B);
            return X;
        } else if (type == "vertical") {
            if (cols_A != cols_B) {
                throw new Error(`A.concat(B, "vertical"): A and B need same number of columns, A has ${cols_A} columns, B has ${cols_B} columns.`);
            }
            const X = new Matrix(rows_A + rows_B, cols_A, "zeros");
            X.set_block(0, 0, A);
            X.set_block(rows_A, 0, B);
            return X;
        } else if (type == "diag") {
            const X = new Matrix(rows_A + rows_B, cols_A + cols_B, "zeros");
            X.set_block(0, 0, A);
            X.set_block(rows_A, cols_A, B);
            return X;
        } else {
            throw new Error(`type must be "horizontal" or "vertical", but type is ${type}!`);
        }
    }

    /**
     * Writes the entries of B in A at an offset position given by {@link offset_row} and {@link offset_col}.
     * @param {int} offset_row
     * @param {int} offset_col
     * @param {Matrix} B
     * @returns {Matrix}
     */
    set_block(offset_row, offset_col, B) {
        const rows = Math.min(this._rows - offset_row, B.shape[0]);
        const cols = Math.min(this._cols - offset_col, B.shape[1]);
        for (let row = 0; row &lt; rows; ++row) {
            for (let col = 0; col &lt; cols; ++col) {
                this.set_entry(row + offset_row, col + offset_col, B.entry(row, col));
            }
        }
        return this;
    }

    /**
     * Extracts the entries from the {@link start_row}&lt;sup>th&lt;/sup> row to the {@link end_row}&lt;sup>th&lt;/sup> row, the {@link start_col}&lt;sup>th&lt;/sup> column to the {@link end_col}&lt;sup>th&lt;/sup> column of the matrix.
     * If {@link end_row} or {@link end_col} is empty, the respective value is set to {@link this.rows} or {@link this.cols}.
     * @param {Number} start_row
     * @param {Number} start_col
     * @param {Number} [end_row = null]
     * @param {Number} [end_col = null]
     * @returns {Matrix} Returns a end_row - start_row times end_col - start_col matrix, with respective entries from the matrix.
     * @example
     *
     * let A = Matrix.from([[1, 2, 3], [4, 5, 6], [7, 8, 9]]); // a 3 by 3 matrix.
     *
     * A.get_block(1, 1); // [[5, 6], [8, 9]]
     * A.get_block(0, 0, 1, 1); // [[1]]
     * A.get_block(1, 1, 2, 2); // [[5]]
     * A.get_block(0, 0, 2, 2); // [[1, 2], [4, 5]]
     */
    get_block(start_row, start_col, end_row = null, end_col = null) {
        const [rows, cols] = this.shape;
        end_row = end_row ?? rows;
        end_col = end_col ?? cols;
        if (end_row &lt;= start_row || end_col &lt;= start_col) {
            throw new Error(`
                end_row must be greater than start_row, and
                end_col must be greater than start_col, but
                end_row = ${end_row}, start_row = ${start_row}, end_col = ${end_col}, and start_col = ${start_col}!`);
        }
        const X = new Matrix(end_row - start_row, end_col - start_col, "zeros");
        for (let row = start_row, new_row = 0; row &lt; end_row; ++row, ++new_row) {
            for (let col = start_col, new_col = 0; col &lt; end_col; ++col, ++new_col) {
                X.set_entry(new_row, new_col, this.entry(row, col));
            }
        }
        return X;
        //return new Matrix(end_row - start_row, end_col - start_col, (i, j) => this.entry(i + start_row, j + start_col));
    }

    /**
     * Returns a new array gathering entries defined by the indices given by argument.
     * @param {Array&lt;Number>} row_indices - Array consists of indices of rows for gathering entries of this matrix
     * @param {Array&lt;Number>} col_indices  - Array consists of indices of cols for gathering entries of this matrix
     * @returns {Matrix}
     */
    gather(row_indices, col_indices) {
        const N = row_indices.length;
        const D = col_indices.length;

        const R = new Matrix(N, D);
        for (let i = 0; i &lt; N; ++i) {
            const row_index = row_indices[i];
            for (let j = 0; j &lt; N; ++j) {
                const col_index = col_indices[j];
                R.set_entry(i, j, this.entry(row_index, col_index));
            }
        }

        return R;
    }

    /**
     * Applies a function to each entry of the matrix.
     * @private
     * @param {Function} f function takes 2 parameters, the value of the actual entry and a value given by the function {@link v}. The result of {@link f} gets writen to the Matrix.
     * @param {Function} v function takes 2 parameters for row and col, and returns a value witch should be applied to the colth entry of the rowth row of the matrix.
     */
    _apply_array(f, v) {
        const data = this.values;
        const [rows, cols] = this.shape;
        for (let i = 0, row = 0; row &lt; rows; ++row) {
            for (let col = 0; col &lt; cols; ++col, ++i) {
                data[i] = f(data[i], v(row, col));
            }
        }
        return this;
    }

    _apply_rowwise_array(values, f) {
        return this._apply_array(f, (_, j) => values[j]);
    }

    _apply_colwise_array(values, f) {
        const data = this.values;
        const [rows, cols] = this.shape;
        for (let i = 0, row = 0; row &lt; rows; ++row) {
            const val = values[row];
            for (let col = 0; col &lt; cols; ++col, ++i) {
                data[i] = f(data[i], val);
            }
        }
        return this;
    }

    _apply(value, f) {
        const data = this.values;
        const [rows, cols] = this.shape;
        if (value instanceof Matrix) {
            const values = value.values;
            const [value_rows, value_cols] = value.shape;
            if (value_rows === 1) {
                if (cols !== value_cols) {
                    throw new Error(`cols !== value_cols`);
                }
                for (let i = 0, row = 0; row &lt; rows; ++row) {
                    for (let col = 0; col &lt; cols; ++col, ++i) {
                        data[i] = f(data[i], values[col]);
                    }
                }
            } else if (value_cols === 1) {
                if (rows !== value_rows) {
                    throw new Error(`rows !== value_rows`);
                }
                for (let i = 0, row = 0; row &lt; rows; ++row) {
                    const v =  values[row];
                    for (let col = 0; col &lt; cols; ++col, ++i) {
                        data[i] = f(data[i], v);
                    }
                }
            } else if (rows == value_rows &amp;&amp; cols == value_cols) {
                for (let i = 0, n = rows * cols; i &lt; n; ++i) {
                    data[i] = f(data[i], values[i]);
                }
            } else {
                throw new Error(`error`);
            }
        } else if (Matrix.isArray(value)) {
            if (value.length === rows) {
                for (let i = 0, row = 0; row &lt; rows; ++row) {
                    const v = value[row];
                    for (let col = 0; col &lt; cols; ++col, ++i) {
                        data[i] = f(data[i], v);
                    }
                }
            } else if (value.length === cols) {
                for (let i = 0, row = 0; row &lt; rows; ++row) {
                    for (let col = 0; col &lt; cols; ++col, ++i) {
                        data[i] = f(data[i], value[col]);
                    }
                }
            } else {
                throw new Error(`error`);
            }
        } else { // scalar value
            for (let i = 0, n = rows * cols; i &lt; n; ++i) {
                data[i] = f(data[i], value);
            }
        }
        return this;
    }

    /**
     * Clones the Matrix.
     * @returns {Matrix}
     */
    clone() {
        let B = new Matrix();
        B._rows = this._rows;
        B._cols = this._cols;
        B._data = this.values.slice(0);
        return B;
    }

    /**
     * Entrywise multiplication with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false]  - If true, applies multiplication to the element, otherwise it creates first a copy and applies the multiplication on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.mult(2); // [[2, 4], [6, 8]];
     * A.mult(B); // [[1, 4], [9, 16]];
     */
    mult(value, { inline = false } = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a * b);
    }

    /**
     * Entrywise division with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false] - If true, applies division to the element, otherwise it creates first a copy and applies the division on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.divide(2); // [[0.5, 1], [1.5, 2]];
     * A.divide(B); // [[1, 1], [1, 1]];
     */
    divide(value, { inline = false } = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a / b);
    }

    /**
     * Entrywise addition with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false]  - If true, applies addition to the element, otherwise it creates first a copy and applies the addition on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.add(2); // [[3, 4], [5, 6]];
     * A.add(B); // [[2, 4], [6, 8]];
     */
    add(value, {inline = false} = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a + b);
    }

    /**
     * Entrywise subtraction with {@link value}.
     * @param {Matrix|Array|Number} value
     * @param {Object} [options]
     * @param {Boolean} [options.inline = false] - If true, applies subtraction to the element, otherwise it creates first a copy and applies the subtraction on the copy.
     * @returns {Matrix}
     * @example
     *
     * let A = Matrix.from([[1, 2], [3, 4]]); // a 2 by 2 matrix.
     * let B = A.clone(); // B == A;
     *
     * A.sub(2); // [[-1, 0], [1, 2]];
     * A.sub(B); // [[0, 0], [0, 0]];
     */
    sub(value, { inline = false } = {}) {
        const A = inline ? this : this.clone();
        return A._apply(value, (a, b) => a - b);
    }

    /**
     * Returns the number of rows and columns of the Matrix.
     * @returns {Array} An Array in the form [rows, columns].
     */
    get shape() {
        return [this._rows, this._cols];
    }

    /**
     * Returns the matrix in the given shape with the given function which returns values for the entries of the matrix.
     * @param {Array} parameter - takes an Array in the form [rows, cols, value], where rows and cols are the number of rows and columns of the matrix, and value is a function which takes two parameters (row and col) which has to return a value for the colth entry of the rowth row.
     * @returns {Matrix}
     */
    set shape([rows, cols, value = () => 0]) {
        this._rows = rows;
        this._cols = cols;
        this._data = new Float64Array(rows * cols);
        for (let i = 0, row = 0; row &lt; rows; ++row) {
            for (let col = 0; col &lt; cols; ++col, ++i) {
                this._data[i] = value(row, col);
            }
        }
        return this;
    }

    /**
     * Returns the Matrix as a Array of Float64Arrays.
     * @returns {Array&lt;Float64Array>}
     */
    get to2dArray() {
        const result = [];
        for (const row of this.iterate_rows()) {
            result.push(row);
        }
        return result;
    }

    /**
     * Returns the Matrix as a Array of Arrays.
     * @returns {Array&lt;Array>}
     */
    get asArray() {
        const result = [];
        for (const row of this.iterate_rows()) {
            result.push(Array.from(row));
        }
        return result;
    }

    /**
     * Returns the diagonal of the Matrix.
     * @returns {Float64Array}
     */
    get diag() {
        const rows = this._rows;
        const cols = this._cols;
        const min_row_col = Math.min(rows, cols);
        let result = new Float64Array(min_row_col);
        for (let i = 0; i &lt; min_row_col; ++i) {
            result[i] = this.entry(i, i);
        }
        return result;
    }

    /**
     * Returns the mean of all entries of the Matrix.
     * @returns {Number}
     */
    get mean() {
        const sum = this.sum;
        const n = this._rows * this._cols;
        return sum / n;
    }

    /**
     * Returns the sum oof all entries of the Matrix.
     * @returns {Number}
     */
    get sum() {
        const data = this.values;
        return neumair_sum(data);
    }

    /**
     * Returns the entries of the Matrix.
     * @returns {Float64Array}
     */
    get values() {
        const data = this._data;
        return data;
    }

    /**
     * Returns the mean of each row of the matrix.
     * @returns {Float64Array}
     */
    get meanRows() {
        const data = this.values;
        const rows = this._rows;
        const cols = this._cols;
        const result = Float64Array.from({ length: rows });
        for (let i = 0, row = 0; row &lt; rows; ++row) {
            let sum = 0;
            for (let col = 0; col &lt; cols; ++col, ++i) {
                sum += data[i];
            }
            result[row] = sum / cols;
        }
        return result;
    }

    /** Returns the mean of each column of the matrix.
     * @returns {Float64Array}
     */
    get meanCols() {
        const data = this.values;
        const rows = this._rows;
        const cols = this._cols;
        const result = Float64Array.from({ length: cols });
        for (let col = 0; col &lt; cols; ++col) {
            let sum = 0;
            for (let i = col, row = 0; row &lt; rows; ++row, i += cols) {
                sum += data[i];
            }
            result[col] = sum / rows;
        }
        return result;
    }

    /**
     * Solves the equation {@link A}x = {@link b} using the conjugate gradient method. Returns the result x.
     * @param {Matrix} A - Matrix
     * @param {Matrix} b - Matrix
     * @param {Randomizer} [randomizer=null]
     * @param {Number} [tol=1e-3]
     * @returns {Matrix}
     */
    static solve_CG(A, b, randomizer, tol = 1e-3) {
        if (randomizer === null) {
            randomizer = new Randomizer();
        }
        const rows = A.shape[0];
        const cols = b.shape[1];
        let result = new Matrix(rows, 0);
        for (let i = 0; i &lt; cols; ++i) {
            const b_i = Matrix.from(b.col(i)).T;
            let x = new Matrix(rows, 1, () => randomizer.random);
            let r = b_i.sub(A.dot(x));
            let d = r.clone();
            do {
                const z = A.dot(d);
                const alpha = r.transDot(r).entry(0, 0) / d.transDot(z).entry(0, 0);
                x = x.add(d.mult(alpha));
                const r_next = r.sub(z.mult(alpha));
                const beta = r_next.transDot(r_next).entry(0, 0) / r.transDot(r).entry(0, 0);
                d = r_next.add(d.mult(beta));
                r = r_next;
            } while (Math.abs(r.mean) > tol);
            result = result.concat(x, "horizontal");
        }
        return result;
    }

    /**
     * Solves the equation {@link A}x = {@link b}. Returns the result x.
     * @param {Matrix} A - Matrix or LU Decomposition
     * @param {Matrix} b - Matrix
     * @returns {Matrix}
     */
    static solve(A, b) {
        let { L: L, U: U } = "L" in A &amp;&amp; "U" in A ? A : Matrix.LU(A);
        let rows = L.shape[0];
        let x = b.clone();

        // forward
        for (let row = 0; row &lt; rows; ++row) {
            for (let col = 0; col &lt; row - 1; ++col) {
                x.sub_entry(0, row, L.entry(row, col) * x.entry(1, col));
            }
            x.set_entry(0, row, x.entry(0, row) / L.entry(row, row));
        }

        // backward
        for (let row = rows - 1; row >= 0; --row) {
            for (let col = rows - 1; col > row; --col) {
                x.sub_entry(0, row, U.entry(row, col) * x.entry(0, col));
            }
            x.set_entry(0, row, x.entry(0, row) / U.entry(row, row));
        }

        return x;
    }

    /**
     * {@link L}{@link U} decomposition of the Matrix {@link A}. Creates two matrices, so that the dot product LU equals A.
     * @param {Matrix} A
     * @returns {{L: Matrix, U: Matrix}} result - Returns the left triangle matrix {@link L} and the upper triangle matrix {@link U}.
     */
    static LU(A) {
        const rows = A.shape[0];
        const L = new Matrix(rows, rows, "zeros");
        const U = new Matrix(rows, rows, "identity");

        for (let j = 0; j &lt; rows; ++j) {
            for (let i = j; i &lt; rows; ++i) {
                let sum = 0;
                for (let k = 0; k &lt; j; ++k) {
                    sum += L.entry(i, k) * U.entry(k, j);
                }
                L.set_entry(i, j, A.entry(i, j) - sum);
            }
            for (let i = j; i &lt; rows; ++i) {
                if (L.entry(j, j) === 0) {
                    return undefined;
                }
                let sum = 0;
                for (let k = 0; k &lt; j; ++k) {
                    sum += L.entry(j, k) * U.entry(k, i);
                }
                U.set_entry(j, i, (A.entry(j, i) - sum) / L.entry(j, j));
            }
        }

        return { L: L, U: U };
    }

    /**
     * Computes the determinante of {@link A}, by using the LU decomposition of {@link A}.
     * @param {Matrix} A
     * @returns {Number} det - Returns the determinate of the Matrix {@link A}.
     */
    static det(A) {
        const rows = A.shape[0];
        const { L, U } = Matrix.LU(A);
        const L_diag = L.diag;
        const U_diag = U.diag;
        let det = L_diag[0] * U_diag[0];
        for (let row = 1; row &lt; rows; ++row) {
            det *= L_diag[row] * U_diag[row];
        }
        return det;
    }

    /**
     * Computes the {@link k} components of the SVD decomposition of the matrix {@link M}
     * @param {Matrix} M
     * @param {int} [k=2]
     * @returns {{U: Matrix, Sigma: Matrix, V: Matrix}}
     */
    static SVD(M, k = 2) {
        let MtM = M.transDot(M);
        let MMt = M.dotTrans(M);
        let { eigenvectors: V, eigenvalues: Sigma } = simultaneous_poweriteration(MtM, k);
        let { eigenvectors: U } = simultaneous_poweriteration(MMt, k);
        return { U: U, Sigma: Sigma.map((sigma) => Math.sqrt(sigma)), V: V };

        //Algorithm 1a: Householder reduction to bidiagonal form:
        /* const [m, n] = A.shape;
        let U = new Matrix(m, n, (i, j) => i == j ? 1 : 0);
        console.log(U.to2dArray)
        let V = new Matrix(n, m, (i, j) => i == j ? 1 : 0);
        console.log(V.to2dArray)
        let B = Matrix.bidiagonal(A.clone(), U, V);
        console.log(U,V,B)
        return { U: U, "Sigma": B, V: V }; */
    }

    static isArray(A) {
      return Array.isArray(A) || A instanceof Float64Array || A instanceof Float32Array;
    }
}
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="qR4yTNPnKLOyvQg7l5Nnz"><div>Modules</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="module-clustering.html">clustering</a></div><div class="sidebar-section-children"><a href="module-datastructure.html">datastructure</a></div><div class="sidebar-section-children"><a href="module-dimensionality_reduction.html">dimensionality_reduction</a></div><div class="sidebar-section-children"><a href="module-knn.html">knn</a></div><div class="sidebar-section-children"><a href="module-linear_algebra.html">linear_algebra</a></div><div class="sidebar-section-children"><a href="module-matrix.html">matrix</a></div><div class="sidebar-section-children"><a href="module-metrics.html">metrics</a></div><div class="sidebar-section-children"><a href="module-numerical.html">numerical</a></div><div class="sidebar-section-children"><a href="module-optimization.html">optimization</a></div><div class="sidebar-section-children"><a href="module-utils.html">utils</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="caSScVQ_fQ_SCfWKPmdUA"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BallTree.html">BallTree</a></div><div class="sidebar-section-children"><a href="DisjointSet.html">DisjointSet</a></div><div class="sidebar-section-children"><a href="DR.html">DR</a></div><div class="sidebar-section-children"><a href="FASTMAP.html">FASTMAP</a></div><div class="sidebar-section-children"><a href="Heap.html">Heap</a></div><div class="sidebar-section-children"><a href="Hierarchical_Clustering.html">Hierarchical_Clustering</a></div><div class="sidebar-section-children"><a href="HIPP.html">HIPP</a></div><div class="sidebar-section-children"><a href="HNSW.html">HNSW</a></div><div class="sidebar-section-children"><a href="ISOMAP.html">ISOMAP</a></div><div class="sidebar-section-children"><a href="KMeans.html">KMeans</a></div><div class="sidebar-section-children"><a href="KMedoids.html">KMedoids</a></div><div class="sidebar-section-children"><a href="KNN.html">KNN</a></div><div class="sidebar-section-children"><a href="LDA.html">LDA</a></div><div class="sidebar-section-children"><a href="LLE.html">LLE</a></div><div class="sidebar-section-children"><a href="LSP.html">LSP</a></div><div class="sidebar-section-children"><a href="LTSA.html">LTSA</a></div><div class="sidebar-section-children"><a href="Matrix.html">Matrix</a></div><div class="sidebar-section-children"><a href="MDS.html">MDS</a></div><div class="sidebar-section-children"><a href="module-dimensionality_reduction.exports.SQDMDS.html">exports.SQDMDS</a></div><div class="sidebar-section-children"><a href="NNDescent.html">NNDescent</a></div><div class="sidebar-section-children"><a href="OAP.html">OAP</a></div><div class="sidebar-section-children"><a href="OPTICS.html">OPTICS</a></div><div class="sidebar-section-children"><a href="PCA.html">PCA</a></div><div class="sidebar-section-children"><a href="Randomizer.html">Randomizer</a></div><div class="sidebar-section-children"><a href="SAMMON.html">SAMMON</a></div><div class="sidebar-section-children"><a href="TopoMap.html">TopoMap</a></div><div class="sidebar-section-children"><a href="TriMap.html">TriMap</a></div><div class="sidebar-section-children"><a href="TSNE.html">TSNE</a></div><div class="sidebar-section-children"><a href="UMAP.html">UMAP</a></div><div class="sidebar-section-children"><a href="XMeans.html">XMeans</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="uFORBgSD49s763-i2VFa2"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#Eigenpair">Eigenpair</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>